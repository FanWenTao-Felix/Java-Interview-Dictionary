# JVM

## 1.Java代码到底是如何运行起来的？

1）编译：“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件。

2）采用“java”命令，实际上此时就会启动一个JVM进程。这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

3）JVM用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

4）**JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了**。

## 2.类从加载到使用过程

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

## 3.JVM在什么情况下会加载一个类？

在**你的代码中用到这个类的时候**。

首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码。

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。

**（1）验证阶段**

简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。

**（2）准备阶段**

我们写好的那些类，其实都有一些类变量，这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间。然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值。

**（3）解析阶段**

这个阶段干的事儿，实际上是把**符号引用替换为直接引用**的过程。

## 4.**什么时候会初始化一个类？**

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类。

## 5.Java里有哪些类加载器呢？

**（1）启动类加载器**

**Bootstrap ClassLoader**，他主要是负责加载我们在机器上安装的Java目录下的核心类的。

一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

**（2）扩展类加载器**

**Extension ClassLoader**，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

**（3）应用程序类加载器**

**Application ClassLoader**，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类。

其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

**（4）自定义类加载器**

除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

## 6.双亲委派机制

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载。但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

这就是所谓的**双亲委派模型：**先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。

## 7.JVM的内存区域划分？

### 存放类的方法区

这个方法区是在JDK 1.8以前的版本里，代表JVM中的一块区域。

主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。

但是在JDK 1.8以后，这块区域的名字改了，叫做“Metaspace”，可以认为是“元数据空间”这样的意思。当然这里主要还是存放我们自己写的各种类相关的信息。

### 执行代码指令用的程序计数器

**我们写好的Java代码会被翻译成字节码，对应各种字节码指令**。

现在Java代码通过JVM跑起来的第一件事情就明确了， 首先Java代码被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。

所以当JVM加载类信息到内存之后，实际就会使用自己的**字节码执行引擎**，去执行我们写的代码编译出来的代码指令。

那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”。

这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。

大家都知道JVM是支持多个线程的，所以其实你写好的代码可能会开启多个线程并发执行不同的代码，所以就会有多个线程来并发的执行不同的代码指令。

因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了。

### Java虚拟机栈

JVM必须有一块区域是来保存每个方法内的**局部变量**等数据的，这个区域就是Java虚拟机栈。

每个线程都有自己的Java虚拟机栈，如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧。栈帧里就有这个方法的局部变量表 、操作数栈、动态链接、方法出口等东西。

“Java虚拟机栈”这个组件的作用：调用执行任何方法时，都会给方法创建栈帧然后入栈。在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。

### Java堆内存

存放我们在代码中创建的各种对象的。

### 本地方法栈

其实在JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的。

如果大家去看他内部的源码，会发现很多地方都不是Java代码了，而是走的native方法去调用本地操作系统里面的一些方法，可能调用的都是c语言写的方法，或者一些底层类库。在调用这种native方法的时候，就会有线程对应的本地方法栈，这个里面也是跟Java虚拟机栈类似的，也是存放各种native方法的局部变量表之类的信息。

### 堆外内存空间

不属于JVM的，通过NIO中的allocateDirect这种API，可以在Java堆外分配内存空间。然后，通过Java虚拟机里的DirectByteBuffer来引用和操作堆外内存空间。

其实很多技术都会用这种方式，因为有一些场景下，堆外内存分配可以提升性能。

## 8.核心内存区域的全流程

首先，你的JVM进程会启动，就会先加载你的Kafka类到内存里。然后有一个main线程，开始执行你的Kafka中的main()方法。

main线程是关联了一个程序计数器的，那么他执行到哪一行指令，就会记录在这里。

其次，就是main线程在执行main()方法的时候，会在main线程关联的Java虚拟机栈里，压入一个main()方法的栈帧。

接着会发现需要创建一个ReplicaManager类的实例对象，此时会加载ReplicaManager类到内存里来。

然后会创建一个ReplicaManager的对象实例分配在Java堆内存里，并且在main()方法的栈帧里的局部变量表引入一个“replicaManager”变量，让他引用ReplicaManager对象在Java堆内存中的地址。

接着，main线程开始执行ReplicaManager对象中的方法，会依次把自己执行到的方法对应的栈帧压入自己的Java虚拟机栈。

执行完方法之后再把方法对应的栈帧从Java虚拟机栈里出栈。

## 9.自定义类加载器如何实现？

**答：**自己写一个类，继承ClassLoader类，重写类加载的方法，然后在代码里面可以用自己的类加载器去针对某个路径下的类加载到内存里来。

## 10.堆内存划分

JVM将Java堆内存划分为了两个区域，一个是年轻代，一个是老年代。

其中年轻代，顾名思义，就是把创建和使用完之后立马就要回收的对象放在里面。

然后老年代呢，就是把第二种代码示例中的那种，创建之后需要一直长期存在的对象放在里面。

## 11.为什么要分成年轻代和老年代？

因为这跟垃圾回收有关，对于年轻代里的对象，他们的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法。

对于老年代里的对象，他们的特点是需要长期存在，所以需要另外一种垃圾回收算法，所以需要分成两个区域来放不同的对象。

## 12.JVM是如何运行起来的

![image.png](D:\workspace\Java-Interview-Dictionary\images\jvm001.png)

## 13.堆外内存

堆外内存的优势？堆内的数据，要网络IO写出去，要先拷贝到堆外内存，再写入到socket里发送出去；如果直接数据分配在堆外内存，是不需要有一次额外的拷贝的，性能是比较高的.

 读写文件也是同理的，都可以节约数据拷贝次数.

1、如果堆外内存足够，就直接预留一部分内存

2、如果堆外内存不足，则将已经被 JVM 垃圾回收的 DirectBuffer 对象的堆外内存释放

3、如果进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则进行 System.gc()

4、如果 9 次尝试后依旧没有足够的可用堆外内存，则抛异常。

 -XX:MaxDirectMemorySize

