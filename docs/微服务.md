# 微服务

## 1.什么是微服务

- 微服务架构是一个分布式系统，按照业务进行划分成为不同的服务单元，解决单体系统性能等不足。
- 微服务是一种架构风格，一个大型软件应用由多个服务单元组成。系统中的服务单元可以单独部署，各个服务单元之间是松耦合的。

## 2.微服务架构的好处

- 通过分解巨大单体式应用为多个服务方法解决了复杂性问题。在功能不变的情况下，应用 被分解为多个可管理的分支或服务。每个服务都有一个用 RPC-或者消息驱动 API 定义清楚的边界。微服务架构模式给采用单体式编码方式很难实现的功能提供 了模块化的解决方案，由此，单个服务很容易开发、理解和维护。
- 这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供 API 服务。
- 微服务架构模式是每个微服务独立的部署。开发者不再需要协调其它服务部署对本服务的影响。这种改变可以加快部署速度。
- 微服务架构模式使得每个服务独立扩展。你可以根据每个服务的规模来部署满足需求的规模。甚至于，你可以使用更适合于服务资源需求的硬件。

## 3.微服务架构的不足

- 微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在 RPC 或者消息传递之间选择并完成进程间通讯机制。更甚 于，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。
- 来自于分区的数据库架构。最终你不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。
- 测试一个基于微服务架构的应用也是很复杂的任务。服务测试需要启动和它有关的所有服务.
- 微服务架构模式应用的改变将会波及多个服务。

## 4.微服务之间是如何独立通讯的

### 同步

#### REST HTTP 协议

REST 请求在微服务中是最为常用的一种通讯方式，它依赖于 HTTP\HTTPS 协议。RESTFUL 的特点是：

1. 每一个 URI 代表 1 种资源
2. 客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源
3. 通过操作资源的表现形式来操作资源
4. 资源的表现形式是 XML 或者 HTML
5. 客户端与服务端之间的交互在请求之间是无状态的,从客户端到服务端的每个请求都必须包含理解请求所必需的信息

#### RPC TCP 协议

RPC(Remote Procedure Call)远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。它的工作流程是这样的：

1. 执行客户端调用语句，传送参数
2. 调用本地系统发送网络消息
3. 消息传送到远程主机
4. 服务器得到消息并取得参数
5. 根据调用请求以及参数执行远程过程（服务）
6. 执行过程完毕，将结果返回服务器句柄
7. 服务器句柄返回结果，调用远程主机的系统网络服务发送结果
8. 消息传回本地主机
9. 客户端句柄由本地主机的网络服务接收消息
10. 客户端接收到调用语句返回的结果数据

### 异步

#### 消息中间件

常见的消息中间件有 Kafka、ActiveMQ、RabbitMQ、RocketMQ ，常见的协议有 AMQP、MQTTP、STOMP、XMPP。这里不对消息队列进行拓展了。

5.微服务技术栈

## 5.微服务技术栈

### 微服务开发

作用：快速开发服务。

- **Spring**
- **Spring MVC**
- **Spring Boot**

Spring 目前是 JavaWeb 开发人员必不可少的一个框架，SpringBoot 简化了 Spring 开发的配置目前也是业内主流开发框架。

### 微服务注册发现

作用：发现服务，注册服务，集中管理服务。

**Eureka**

- Eureka Server : 提供服务注册服务, 各个节点启动后，会在 Eureka Server 中进行注册。
- Eureka Client : 简化与 Eureka Server 的交互操作。

**Zookeeper**

Zookeeper 是一个集中的服务, 用于维护配置信息、命名、提供分布式同步和提供组服务。

Zookeeper 和 Eureka 区别

Zookeeper 保证 CP，Eureka 保证 AP：

- C：数据一致性；
- A：服务可用性；
- P：服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个。

### 微服务配置管理

作用：统一管理一个或多个服务的配置信息, 集中管理。

**Disconf**

Distributed Configuration Management Platform(分布式配置管理平台) , 它是专注于各种分布式系统配置管理 的通用组件/通用平台, 提供统一的配置管理服务, 是一套完整的基于 zookeeper 的分布式配置统一解决方案。

**SpringCloudConfig**

**Apollo**

Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，用于微服务配置管理场景。

### 权限认证

作用：根据系统设置的安全规则或者安全策略, 用户可以访问而且只能访问自己被授权的资源，不多不少。

**Spring Security**

**Apache Shiro**

### 批处理

作用: 批量处理同类型数据或事物

**Spring Batch**

### 定时任务

> 作用: 定时做什么。

**Quartz**

### 微服务调用 (协议)

> 通讯协议

**Rest**

- 通过 HTTP/HTTPS 发送 Rest 请求进行数据交互

**RPC**

- Remote Procedure Call
- 它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 不依赖于具体的网络传输协议，tcp、udp 等都可以。

**gRPC**

> A high-performance, open-source universal RPC framework

所谓 RPC(remote procedure call 远程过程调用) 框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从 server/client 模型。使用的时候客户端调用 server 端提供的接口就像是调用本地的函数一样。

**RMI**

- Remote Method Invocation
- 纯 Java 调用

### 服务接口调用

> 作用：多个服务之间的通讯

**Feign(HTTP)**

Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去调用，而 Feign 是一个使用起来更加方便的 HTTP 客戶端，使用起来就像是调用自身工程的方法，而感觉不到是调用远程方法。

### 服务熔断

> 作用: 当请求到达一定阈值时不让请求继续.

**Hystrix**

**Sentinel**

### 服务的负载均衡

> 作用：降低服务压力, 增加吞吐量

**Ribbon**

> Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具, 它基于 Netflix Ribbon 实现

**Nginx**

Nginx (engine x) 是一个高性能的 HTTP 和反向代理 web 服务器, 同时也提供了 IMAP/POP3/SMTP 服务

Nginx 与 Ribbon 区别

Nginx 属于服务端负载均衡，Ribbon 属于客户端负载均衡。Nginx 作用与 Tomcat，Ribbon 作用与各个服务之间的调用 (RPC)。

### 消息队列

> 作用: 解耦业务, 异步化处理数据

**Kafka**

**RabbitMQ**

**RocketMQ**

**activeMQ**

### 日志采集 (elk)

> 作用: 收集各服务日志提供日志分析、用户画像等

**Elasticsearch**

**Logstash**

**Kibana**

### API 网关

> 作用: 外部请求通过 API 网关进行拦截处理, 再转发到真正的服务

**Zuul**

### 服务监控

> 作用: 以可视化或非可视化的形式展示出各个服务的运行情况 (CPU、内存、访问量等)

**Zabbix**

**Nagios**

**Metrics**

### 服务链路追踪

> 作用: 明确服务之间的调用关系

**Zipkin**

**Brave**

### 数据存储

> 作用: 存储数据

#### 关系型数据库

**MySql**

**Oracle**

**MsSQL**

**PostgreSql**

#### 非关系型数据库

**Mongodb**

**Elasticsearch**

### 缓存

> 作用: 存储数据

**redis**

### 分库分表

> 作用: 数据库分库分表方案.

**ShardingSphere**

**Mycat**

### 服务部署

> 作用: 将项目快速部署、上线、持续集成.

**Docker**

**Jenkins**

**Kubernetes(K8s)**

**Mesos**

## 6.微服务治理策略

### 服务的注册和发现

解决问题：集中管理服务

解决方法：

- **Eureka**
- **Zookeeper**

### 负载均衡

解决问题：降低服务器硬件压力

解决方法：

- **Nginx**
- **Ribbon**

### 通讯

解决问题：各个服务之间的沟通桥梁

解决方法：

- **REST（同步）**
- **RPC（同步）**
- **MQ（异步）**

### 配置管理

解决问题：随着服务的增加配置也在增加，如何管理各个服务的配置。

解决方法：

- **Nacos**
- **Spring Cloud Config**
- **Apollo**

### 容错和服务降级

解决问题：在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可以，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。

解决方法：

- **Hystrix**

### 服务依赖关系

解决问题：多个服务之间来回依赖，启动关系的不明确。

解决方法：应用分层。

服务文档

解决问题：降低沟通成本

解决方法：

- **Swagger**
- **Java doc**

### 服务安全问题

解决问题：敏感数据的安全性

解决方法：

- **Oauth**
- **Shiro**
- **Spring Security**

### 流量控制

解决问题：避免一个服务上的流量过大拖垮整个服务体系

解决方法：

- **Hystrix**

### 自动化测试

解决问题：提前预知异常，确定服务是否可用

解决方法：

- **junit**

### 服务上线，下线的流程

解决问题：避免服务随意的上线下线

解决方法：新服务上线需要经过管理人员审核，服务下线需要告知各个调用方进行修改，直到没有调用该服务才可以进行下线。

兼容性

解决问题：服务开发持续进行如何做到兼容。

解决方法：通过版本号的形式进行管理，修改完成进行回归测试。

服务编排

解决问题：解决服务依赖问题的一种方式

解决方法：

- **Docker**
- **K8s**

### 资源调度

解决问题：每个服务的资源占用量不同，如何分配

解决方法：

- **JVM 隔离**
- **Classload 隔离**
- **硬件隔离**

### 容量规划

解决问题：随着时间增长，调用逐步增加，什么时候追加机器。

解决方法：统计每日调用量和响应时间，根据机器情况设置阈值，超过阈值就可以追加机器。