# 并发编程

## 1.synchronized关键字的底层原理

synchronized底层的原理，是跟jvm指令和monitor有关系的,你如果用到了synchronized关键字，在底层编译后的jvm指令中，会有monitorenter和monitorexit两个指令.

每个对象都有一个关联的monitor，比如一个对象实例就有一个monitor，一个类的Class对象也有一个monitor，如果要对这个对象加锁，那么必须获取这个对象关联的monitor的lock锁,monitor里面有一个计数器，从0开始的。如果一个线程要获取monitor的锁，就看看他的计数器是不是0，如果是0的话，那么说明没人获取锁，他就可以获取锁了，然后对计数器加1.

如果一个线程第一次synchronized那里，获取到了myObject对象的monitor的锁，计数器加1，然后第二次synchronized那里，会再次获取myObject对象的monitor的锁，这个就是重入加锁了，然后计数器会再次加1，变成2.

这个时候，其他的线程在第一次synchronized那里，会发现说myObject对象的monitor锁的计数器是大于0的，意味着被别人加锁了，然后此时线程就会进入block阻塞状态，什么都干不了，就是等着获取锁,接着如果出了synchronized修饰的代码片段的范围，就会有一个monitorexit的指令，在底层。此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0. 然后后面block住阻塞的线程，会再次尝试获取锁，但是只有一个线程可以获取到锁.

## 2.ConcurrentHashMap实现线程安全的底层原理

1.8以前是多个组数进行分段加锁,一个数组一个锁.在1.8之后,优化了细粒度,对数组的每个元素进行CAS,假设,多个线程同时操作Map但不是Map中的同一个数组,那么是没有关系的.如果是多个线程同时put操作Map中的一个数组,那么只有一个会成功,其他都会失败,此时需要基于链表或红黑树来处理,使用synchronized对当前数组加锁,然后进行操作.所以只要不是同时操作同一个位置的元素就不会触发同步的串行化操作,性能不会受影响.

## 3.volatile保证可见性

对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改.

 如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了.

