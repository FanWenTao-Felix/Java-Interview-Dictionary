# Spring

## 1.Spring IOC

spring ioc，spring容器，根据xml配置，或者是你的注解，去实例化你的一些bean对象，然后根据xml配置或者注解，去对bean对象之间的引用关系，去进行依赖注入，某个bean依赖了另外一个bean.

底层的核心技术，反射，他会通过反射的技术，直接根据你的类去自己构建对应的对象出来，用的就是反射技术

## 2.Spring AOP

AOP面向切面编程，所谓切面就是对一类重复业务的抽象，例如事务。本来事务的操作耦合在各个业务层代码中，不好统一管理，这也叫做编程式事务，不过用的不多了。我们就可以通过AOP将事务定义成一个切面，然后定义对应的通知与切点，这样事务的管理变得更加清晰，代码也变得更加优雅。 

关于AOP的实现，基于动态代理，动态代理的实现有两种，分别对应静态代理中的两种实现——组合/继承。一种通过组合的方式获取目标函数，一个通过继承目标类通过父类调用函数。

## 3.Spring中的Bean

Spring容器中的bean可以分为5个范围：

（1）singleton：默认，每个容器中只有一个bean的实例

（2）prototype：为每一个bean请求提供一个实例

一般来说下面几种作用域，在开发的时候一般都不会用，99.99%的时候都是用singleton单例作用域.

（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收

（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效

（5）global-session

Spring中的Bean不可能是线程安全的，spring bean默认来说，singleton，都是线程不安全的，java web系统，一般来说很少在spring bean里放一些实例变量，一般来说他们都是多个组件互相调用，最终去访问数据库的

## 4.事务传播机制

加了一个@Transactional注解，此时就spring会使用AOP思想，对你的这个方法在执行之前，先去开启事务，执行完毕之后，根据你方法是否报错，来决定回滚还是提交事务.

嵌套事务，外层的事务如果回滚，会导致内层的事务也回滚；但是内层的事务如果回滚，仅仅是回滚自己的代码

① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘

③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。

 