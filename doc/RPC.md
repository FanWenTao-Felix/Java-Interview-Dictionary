# RPC

## 1.什么是RPC

RPC（RemoteProcedureCallProtocol）远程过程调⽤协议，它是⼀种通过⽹络从远程计算机程序上请求服务，⽽不需要了解底层⽹络技术的协议。简⾔之，RPC使得程序能够像访问本地系统资源⼀样，去访问远端系统资源。⽐较关键的⼀些⽅⾯包括：通讯协议、序列化、资源（接⼝）描述、服务框架、性能、语⾔⽀持等。

简单的说，RPC就是从⼀台机器(客⼾端)上通过参数传递的⽅式调⽤另⼀台机器(服务器)上的⼀个函数或⽅法(可以统称为服务)并得到返回的结果。

## 2.PRC架构组件

⼀个基本的RPC架构⾥⾯应该⾄少包含以下4个组件：

1、客⼾端（Client）:服务调⽤⽅（服务消费者）

2、客⼾端存根（ClientStub）:存放服务端地址信息，将客⼾端的请求参数数据信息打包成⽹络消息，再通过⽹络传输发送给服务端

3、服务端存根（ServerStub）:接收客⼾端发送过来的请求消息并进⾏解包，然后再调⽤本地服务进⾏处理

4、服务端（Server）:服务的真正提供者

![](D:\workspace\Java-Interview-Offer\images\rpc001.png)

具体调⽤过程：

- 服务消费者（client客⼾端）通过调⽤本地服务的⽅式调⽤需要消费的服务；
- 客⼾端存根（clientstub）接收到调⽤请求后负责将⽅法、⼊参等信息序列化（组装）成能够进⾏⽹络传输的消息体；
- 客⼾端存根（clientstub）找到远程的服务地址，并且将消息通过⽹络发送给服务端；
- 服务端存根（serverstub）收到消息后进⾏解码（反序列化操作）；
- 服务端存根（serverstub）根据解码结果调⽤本地的服务进⾏相关处理；
- 本地服务执⾏具体业务逻辑并将处理结果返回给服务端存根（serverstub）；
- 服务端存根（serverstub）将返回结果重新打包成消息（序列化）并通过⽹络发送⾄消费⽅；
- 客⼾端存根（clientstub）接收到消息，并进⾏解码（反序列化）；
- 服务消费⽅得到最终结果；

⽽RPC框架的实现⽬标则是将上⾯的第2-10步完好地封装起来，也就是把调⽤、编码/解码的过程给封装起来，让⽤⼾感觉上像调⽤本地服务⼀样的调⽤远程服务。

## 3.RPC和SOA、SOAP、REST的区别

1、REST

可以看着是HTTP协议的⼀种直接应⽤，默认基于JSON作为传输格式,使⽤简单,学习成本低效率⾼,但是安全性较低。

2、SOAP

SOAP是⼀种数据交换协议规范,是⼀种轻量的、简单的、基于XML的协议的规范。⽽SOAP可以看着是⼀个重量级的协议，基于XML、SOAP在安全⽅⾯是通过使⽤XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个⼚商的⽀持。

它有什么优点？简单总结为：易⽤、灵活、跨语⾔、跨平台。

3、SOA

⾯向服务架构，它可以根据需求通过⽹络对松散耦合的粗粒度应⽤组件进⾏分布式部署、组合和使⽤。服务层是SOA的基础，可以直接被应⽤调⽤，从⽽有效控制系统中与软件代理交互的⼈为依赖性。

SOA是⼀种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接⼝进⾏通讯，不涉及底层编程接⼝和通讯模型。SOA可以看作是B/S模型、XML（标准通⽤标记语⾔的⼦集）/WebService技术之后的⾃然延伸。

4、REST和SOAP、RPC有何区别呢?

没什么太⼤区别，他们的本质都是提供可⽀持分布式的基础服务，最⼤的区别在于他们各⾃的的特点所带来的不同应⽤场景。

## 4.RPC框架需要解决的问题？

1、如何确定客⼾端和服务端之间的通信协议？

2、如何更⾼效地进⾏⽹络通信？

3、服务端提供的服务如何暴露给客⼾端？

4、客⼾端如何发现这些暴露的服务？

5、如何更⾼效地对请求对象和响应结果进⾏序列化和反序列化操作？

## 5.RPC的实现基础？

1、需要有⾮常⾼效的⽹络通信，⽐如⼀般选择Netty作为⽹络通信框架；

2、需要有⽐较⾼效的序列化框架，⽐如⾕歌的Protobuf序列化框架；

3、可靠的寻址⽅式（主要是提供服务的发现），⽐如可以使⽤Zookeeper来注册服务等等；

4、如果是带会话（状态）的RPC调⽤，还需要有会话和状态保持的功能；

## 6.RPC使⽤了哪些关键技术？

1、动态代理

⽣成ClientStub（客⼾端存根）和ServerStub（服务端存根）的时候需要⽤到Java动态代理技术，可以使⽤JDK提供的原⽣的动态代理机制，也可以使⽤开源的：CGLib代理，Javassist字节码⽣成技术。

2、序列化和反序列化

在⽹络中，所有的数据都将会被转化为字节进⾏传送，所以为了能够使参数对象在⽹络中进⾏传输，需要对这些参数进⾏序列化和反序列化操作。

序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。

反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。

⽬前⽐较⾼效的开源序列化框架：如Kryo、FastJson和Protobuf等。

3、NIO通信

出于并发性能的考虑，传统的阻塞式IO显然不太合适，因此我们需要异步的IO，即NIO。Java提供了NIO的解决⽅案，Java7也提供了更优秀的NIO.2⽀持。可以选择Netty或者MINA来解决NIO数据传输的问题。

4、服务注册中⼼

可选：Redis、Zookeeper、Consul、Etcd。⼀般使⽤ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中⼼)。

## 7.主流RPC框架有哪些

1、RMI

利⽤java.rmi包实现，基于Java远程⽅法协议(JavaRemoteMethodProtocol)和java的原⽣序列化。

2、Hessian

是⼀个轻量级的remotingonhttp⼯具，使⽤简单的⽅法提供了RMI的功能。基于HTTP协议，采⽤⼆进制编解码。

3、protobuf-rpc-pro

是⼀个Java类库，提供了基于Google的ProtocolBuffers协议的远程⽅法调⽤的框架。基于Netty底层的NIO技术。⽀持TCP重⽤/keep-alive、SSL加密、RPC调⽤取消操作、嵌⼊式⽇志等功能。

4、Thrift

是⼀种可伸缩的跨语⾔服务的软件框架。它拥有功能强⼤的代码⽣成引擎，⽆缝地⽀持C++，C#，Java，Python和PHP和Ruby。thrift允许你定义⼀个描述⽂件，描述数据类型和服务接⼝。依据该⽂件，编译器⽅便地⽣成RPC客⼾端和服务器通信代码。

最初由facebook开发⽤做系统内个语⾔之间的RPC通信，2007年由facebook贡献到apache基⾦，现在是apache下的opensource之⼀。⽀持多种语⾔之间的RPC⽅式的通信：php语⾔client可以构造⼀个对象，调⽤相应的服务⽅法来调⽤java语⾔的服务，跨越语⾔的C/SRPC调⽤。底层通讯基于SOCKET。

5、Avro

出⾃Hadoop之⽗DougCutting,在Thrift已经相当流⾏的情况下推出Avro的⽬标不仅是提供⼀套类似Thrift的通讯中间件,更是要建⽴⼀个新的，标准性的云计算的数据交换和存储的Protocol。⽀持HTTP，TCP两种协议。

6、Dubbo

Dubbo是阿⾥巴巴公司开源的⼀个⾼性能优秀的服务框架，使得应⽤可通过⾼性能的RPC实现服务的输出和输⼊功能，可以和Spring框架⽆缝集成。

## 8.RPC的实现原理架构图

![](D:\workspace\Java-Interview-Offer\images\rpc002.png)

也就是说两台服务器A，B，⼀个应⽤部署在A服务器上，想要调⽤B服务器上应⽤提供的函数/⽅法，由于不在⼀个内存空间，不能直接调⽤，需要通过⽹络来表达调⽤的语义和传达调⽤的数据。

⽐如说，A服务器想调⽤B服务器上的⼀个⽅法：

UsergetUserByName(StringuserName)

### 1、建⽴通信

⾸先要解决通讯的问题：即A机器想要调⽤B机器，⾸先得建⽴起通信连接。

主要是通过在客⼾端和服务器之间建⽴TCP连接，远程过程调⽤的所有交换的数据都在这个连接⾥传输。连接可以是按需连接，调⽤结束后就断掉，也可以是⻓连接，多个远程过程调⽤共享同⼀个连接。

通常这个连接可以是按需连接（需要调⽤的时候就先建⽴连接，调⽤结束后就⽴⻢断掉），也可以是⻓连接（客⼾端和服务器建⽴起连接之后保持⻓期持有，不管此时有⽆数据包的发送，可以配合⼼跳检测机制定期检测建⽴的连接是否存活有效），多个远程过程调⽤共享同⼀个连接。

### 2、服务寻址

要解决寻址的问题，也就是说，A服务器上的应⽤怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端⼝，⽅法的名称名称是什么。

通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端⼝，然后指定调⽤的⽅法或者函数的名称以及⼊参出参等信息，这样才能完成服务的⼀个调⽤。

可靠的寻址⽅式（主要是提供服务的发现）是RPC的实现基⽯，⽐如可以采⽤Redis或者Zookeeper来注册服务等等。

#### 2.1、从服务提供者的⻆度看：

- 当服务提供者启动的时候，需要将⾃⼰提供的服务注册到指定的注册中⼼，以便服务消费者能够通过服务注册中⼼进⾏查找；
- 当服务提供者由于各种原因致使提供的服务停⽌时，需要向注册中⼼注销停⽌的服务；
- 服务的提供者需要定期向服务注册中⼼发送⼼跳检测，服务注册中⼼如果⼀段时间未收到来⾃服务提供者的⼼跳后，认为该服务提供者已经停⽌服务，则将该服务从注册中⼼上去掉

#### 2.2、从调⽤者的⻆度看：

- 服务的调⽤者启动的时候根据⾃⼰订阅的服务向服务注册中⼼查找服务提供者的地址等信息；
- 当服务调⽤者消费的服务上线或者下线的时候，注册中⼼会告知该服务的调⽤者；
- 服务调⽤者下线的时候，则取消订阅。

### 3、⽹络传输

#### 3.1、序列化

当A机器上的应⽤发起⼀个RPC调⽤时，调⽤⽅法和其⼊参等信息需要通过底层的⽹络协议如TCP传输到B机器，由于⽹络协议是基于⼆进制的，所有我们传输的参数数据都需要先进⾏序列化（Serialize）或者编组（marshal）成⼆进制的形式才能在⽹络中进⾏传输。然后通过寻址操作和⽹络传输将序列化或者编组之后的⼆进制数据发送给B机器。

#### 3.2、反序列化

当B机器接收到A机器的应⽤发来的请求之后，⼜需要对接收到的参数等信息进⾏反序列化操作（序列化的逆操作），即将⼆进制信息恢复为内存中的表达⽅式，然后再找到对应的⽅法（寻址的⼀部分）进⾏本地调⽤（⼀般是通过⽣成代理Proxy去调⽤,通常会有JDK动态代理、CGLIB动态代理、Javassist⽣成字节码技术等），之后得到调⽤的返回值。

### 4、服务调⽤

B机器进⾏本地调⽤（通过代理Proxy和反射调⽤）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过⽹络传输将⼆进制数据发送回A机器，⽽当A机器接收到这些返回值之后，则再次进⾏反序列化操作，恢复为内存中的表达⽅式，最后再交给A机器上的应⽤进⾏相关处理，⼀般是业务逻辑处理操作。

通常，经过以上四个步骤之后，⼀次完整的RPC调⽤算是完成了，另外可能因为⽹络抖动等原因需要重试等。