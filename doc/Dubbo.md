# Dubbo

## 1.dubbo⽀持哪些通信协议？

### 1、dubbo协议

默认就是⾛dubbo协议，单⼀⻓连接，进⾏的是NIO异步通信，基于hessian作为序列化协议。使⽤的场景是：传输数据量⼩（每次请求在100kb以内），但是并发量很⾼。

为了要⽀持⾼并发场景，⼀般是服务提供者就⼏台机器，但是服务消费者有上百台，可能每天调⽤量达到上亿次！此时⽤⻓连接是最合适的，就是跟每个服务消费者维持⼀个⻓连接就可以，可能总共就100个连接。然后后⾯直接基于⻓连接NIO异步通信，可以⽀撑⾼并发请求。

⻓连接，通俗点说，就是建⽴连接过后可以持续发送请求，⽆须再建⽴连接。

### 2、rmi协议

⾛Java⼆进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适⽤于⽂件的传输，⼀般较少⽤。

### 3、hessian协议

⾛hessian序列化协议，多个短连接，适⽤于提供者数量⽐消费者数量还多的情况，适⽤于⽂件的传输，⼀般较少⽤。

### 4、http协议

⾛json序列化。

### 5、webservice

⾛SOAP⽂本

## 2.⽀持哪些序列化协议？

dubbo⽀持hession、Java⼆进制序列化、json、SOAP⽂本序列化多种序列化协议。但是hessian是其默认的序列化协议。

## 3.说⼀下Hessian的数据结构？

Hessian的对象序列化机制有8种原始类型：

- 原始⼆进制数据
- boolean
- 64-bit date（64位毫秒值的⽇期）
- 64-bit double
- 32-bit int
- 64-bit long
- null
- UTF-8编码的string

另外还包括3种递归类型：

- list for lists and arrays
- map for maps and dictionaries
- object for objects

还有⼀种特殊的类型：

- ref：⽤来表⽰对共享对象的引⽤。

## 4.PB知道吗？

Protocol Buffer其实是Google出品的⼀种轻量并且⾼效的结构化数据存储格式，性能⽐JSON、XML要⾼很多。

## 5.为什么PB的效率是最⾼的？

其实PB之所以性能如此好，主要得益于两个：

第⼀，它使⽤proto编译器，⾃动进⾏序列化和反序列化，速度⾮常快，应该⽐XML和JSON快上了20~100倍；

第⼆，它的数据压缩效果好，就是说它序列化后的数据量体积⼩。因为体积⼩，传输起来带宽和速度上会有优化。

## 6.dubbo是什么

dubbo是⼀个分布式框架，远程服务调⽤的分布式框架，其核⼼部分包含：集群容错：提供基于接⼝⽅法的透明远程过程调⽤，包括多协议⽀持，以及软负载均衡，失败容错，地址路由，动态配置等集群⽀持。远程通讯：提供对多种基于⻓连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换⽅式。⾃动发现：基于注册中⼼⽬录服务，使服务消费⽅能动态的查找服务提供⽅，使地址透明，使服务提供⽅可以平滑增加或减少机器。

## 7.dubbo能做什么

透明化的远程⽅法调⽤，就像调⽤本地⽅法⼀样调⽤远程⽅法，只需简单配置，没有任何API侵⼊。软负载均衡及容错机制，可在内⽹替代F5等硬件负载均衡器，降低成本，减少单点。服务⾃动注册与发现，不再需要写死服务提供⽅地址，注册中⼼基于接⼝名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。

## 8.服务调⽤是阻塞的吗？

默认是阻塞的，可以异步调⽤，没有返回值的可以这么做。

## 9.⼀般使⽤什么注册中⼼？还有别的选择吗？

推荐使⽤zookeeper注册中⼼，还有Multicast注册中⼼,Redis注册中⼼,Simple注册中⼼.

ZooKeeper的节点是通过像树⼀样的结构来进⾏维护的，并且每⼀个节点通过路径来标⽰以及访问。除此之外，每⼀个节点还拥有⾃⾝的⼀些信息，包括：数据、数据⻓度、创建时间、修改时间等等。

## 10.默认使⽤什么序列化框架，你知道的还有哪些？

默认使⽤Hessian序列化，还有Duddo、FastJson、Java⾃带序列化。hessian是⼀个采⽤⼆进制格式传输的服务框架，相对传统soapwebservice，更轻量，更快速。

Hessian原理与协议简析：

http的协议约定了数据传输的⽅式，hessian也⽆法改变太多：

1)hessian中client与server的交互，基于http-post⽅式。

2)hessian将辅助信息，封装在httpheader中，⽐如“授权token”等，我们可以基于http-header来封装关于“安全校验”“meta数据”等。hessian提供了简单的”校验”机制。

3)对于hessian的交互核⼼数据，⽐如“调⽤的⽅法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。

4)对于hessian的server端响应数据，将在response中通过字节流的⽅式直接输出。

hessian的协议本⾝并不复杂，在此不再赘⾔；所谓协议(protocol)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执⾏指定的⽅法，并将⽅法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列话成”对象”。

## 11.服务提供者能实现失效踢出是什么原理？

服务失效踢出基于zookeeper的临时节点原理。

## 12.服务上线怎么不影响旧版本？

采⽤多版本开发，不影响旧版本。在配置中添加version来作为版本区分

## 13.说说核⼼的配置有哪些？

核⼼配置有：

1)dubbo:service/

2)dubbo:reference/

3)dubbo:protocol/

4)dubbo:registry/

5)dubbo:application/

6)dubbo:provider/

7)dubbo:consumer/

8)dubbo:method/

## 14.dubbo在安全机制⽅⾯如何解决的？

dubbo通过token令牌防⽌⽤⼾绕过注册中⼼直连，然后在注册中⼼管理授权，dubbo提供了⿊⽩名单，控制服务所允许的调⽤⽅。

## 15.集群容错怎么做？

读操作建议使⽤Failover失败⾃动切换，默认重试两次其他服务器。写操作建议使⽤Failfast快速失败，发⼀次调⽤失败就⽴即报错。

## 16.在使⽤过程中都遇到了些什么问题？如何解决的？

1)同时配置了XML和properties⽂件，则properties中的配置⽆效

只有XML没有配置时，properties才⽣效。

2)dubbo缺省会在启动时检查依赖是否可⽤，不可⽤就抛出异常，阻⽌spring初始化完成，check属性默认为true。

测试时有些服务不关⼼或者出现了循环依赖，将check设置为false

3)为了⽅便开发测试，线下有⼀个所有服务可⽤的注册中⼼，这时，如果有⼀个正在开发中的服务提供者注册，可能会影响消费者不能正常运⾏。

解决：让服务提供者开发⽅，只订阅服务，⽽不注册正在开发的服务，通过直连测试正在开发的服务。设置dubbo:registry标签的register属性为false。

4)spring2.x初始化死锁问题。

在spring解析到dubbo:service时，就已经向外暴露了服务，⽽spring还在接着初始化其他bean，如果这时有请求进来，并且服务的实现类⾥有调⽤applicationContext.getBean()的⽤法。getBean线程和spring初始化线程的锁的顺序不⼀样，导致了线程死锁，不能提供服务，启动不了。

解决：不要在服务的实现类中使⽤applicationContext.getBean();如果不想依赖配置顺序，可以将dubbo:provider的deplay属性设置为-1，使dubbo在容器初始化完成后再暴露服务。

5)服务注册不上

检查dubbo的jar包有没有在classpath中，以及有没有重复的jar包

检查暴露服务的spring配置有没有加载

在服务提供者机器上测试与注册中⼼的⽹络是否通

6)出现RpcException:Noprovideravailableforremoteservice异常

表⽰没有可⽤的服务提供者，

a.检查连接的注册中⼼是否正确

b.到注册中⼼查看相应的服务提供者是否存在

c.检查服务提供者是否正常运⾏

7)出现”消息发送失败”异常

通常是接⼝⽅法的传⼊传出参数未实现Serializable接⼝。

## 17.dubbo和dubbox之间的区别？

dubbox是当当⽹基于dubbo上做了⼀些扩展，如加了服务可restful调⽤，更新了开源组件等。

## 18.Dubbo⽀持哪些协议，每种协议的应⽤场景，优缺点？

dubbo：单⼀⻓连接和NIO异步通讯，适合⼤并发⼩数据量的服务调⽤，以及消费者远⼤于提供者。传输协议TCP，异步，Hessian序列化；

rmi：采⽤JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接⼝，使⽤java标准序列化机制，使⽤阻塞式短连接，传输数据包⼤⼩混合，消费者和提供者个数差不多，可传⽂件，传输协议TCP。多个短连接，TCP协议传输，同步传输，适⽤常规的远程服务调⽤和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；关注微信公众号「web_resourc」,回复Java领取2019最新资源。

webservice:基于WebService的远程调⽤协议，集成CXF实现，提供和原⽣WebService的互操作。多个短连接，基于HTTP传输，同步传输，适⽤系统集成和跨语⾔调⽤；http：基于Http表单提交的远程调⽤协议，使⽤Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传⼊参数⼤⼩混合，提供者个数多于消费者，需要给应⽤程序和浏览器JS调⽤；hessian：集成Hessian服务，基于HTTP通讯，采⽤Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传⼊参数较⼤，提供者⼤于消费者，提供者压⼒较⼤，可传⽂件；

memcache：基于memcached实现的RPC协议redis：基于redis实现的RPC协议

## 19.Dubbo集群的负载均衡有哪些策略

Dubbo提供了常⻅的集群策略实现，并预扩展点予以⾃⾏实现。

RandomLoadBalance:随机选取提供者策略，有利于动态调整提供者权重。截⾯碰撞率⾼，调⽤次数越多，分布越均匀。

RoundRobinLoadBalance:轮循选取提供者策略，平均分布，但是存在请求累积的问题；

LeastActiveLoadBalance:最少活跃调⽤策略，解决慢提供者接收更少的请求；ConstantHashLoadBalance:⼀致性Hash策略，使相同参数请求总是发到同⼀提供者，⼀台机器宕机，可以基于虚拟节点，分摊⾄其他提供者，避免引起提供者的剧烈变动；

## 20.服务调⽤超时问题怎么解决

dubbo在调⽤服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，⽐如在发邮件时，可能就会发出多份重复邮件，执⾏注册请求时，就会插⼊多条重复的注册数据，那么怎么解决超时问题呢？如下

对于核⼼的服务中⼼，去除dubbo超时重试机制，并重新评估设置超时时间。业务处理代码必须放在服务端，客⼾端只做参数验证和服务调⽤，不涉及业务流程处理全局配置实例

```
<dubbo:provider delay="-1" timeout="6000" retries="0"/>
```

当然Dubbo的重试机制其实是⾮常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，⽽不是本机尝试，所以dubbo的重试机器也能⼀定程度的保证服务的质量。但是请⼀定要综合线上的访问情况，给出综合的评估。

