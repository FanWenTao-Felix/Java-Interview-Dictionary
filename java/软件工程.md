## 软件工程

### 1.软件工程

一句话概括一下软件工程：就是从0开始如何完成一个软件项目，涵盖了做一个软件项目的所有的流程。

- 业务调研：主要是完全跟技术无关，站在业务的角度去定义系统要干嘛
  - 组织结构图：部门+岗位
  - 业务流程图：泳道图，一级业务流程+二级业务流程
    - 系统多个模块的整体业务流程
    - 每个模块内部的业务流程
  - 业务表单
  - 业务需求
- 需求分析：站在技术的角度，去分析系统要干嘛
  - 用例图
    - 用例表：用例名称+多个参与者+每个参与者对这个用例做的事情
    - 用例描述+用例流程（泳道图）
    - 用例图：参与者+用例，一个用例就是一个功能需求
    - 用例划分
      - 每个模块都划分出对应的用例来
      - 从业务流程图的运行节点中，抽取用例
  - 领域类图
    - 主要根据业务表单来抽象
  - 非功能需求
    - 物理部署需求
    - 实施需求
    - 易用性需求
    - 性能需求
    - 可靠性需求
- 概要设计：架构师一个人去做的
  - 逻辑架构图：根据需求，画出来逻辑上，系统要长成什么样子
  - 运行架构图：时序图、活动图（可选）、状态图（可选），系统的逻辑架构有了，系统跑起来是什么流程
  - 物理架构图：组件图、配置图，系统长什么样子，系统跑起来流程是什么，系统真正怎么去部署
- 概要设计评审
- 详细设计：下推给项目组里的每个人去做
  - 数据架构图
    - 数据库ER模型图
    - 数据库逻辑设计图
    - 数据库物理设计图
  - 接口设计
  - 开发架构图：实现类图、包图
  - 系统运行流程图（活动图）
  - 测试用例设计
    - 单元测试用例设计
    - 冒烟测试用例设计
  - 日志设计
- 详细设计评审
- 项目管理计划（每个人给出自己的排期计划）
  - 活动图
  - 网络图
  - 进度计划（甘特图）
  - 资源配置
- 工程初始化
  - 每个人本地的开发环境搭建
  - 资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请
  - 数据库初始化
  - 代码初始化和上传
- 版本控制
- 编码开发
- 系统测试
  - 单元测试（白盒测试）
  - 冒烟测试
  - 静态代码扫描
  - 代码审查
  - 集成测试（联调测试，也可能是RD自己干，不是QA干）
  - 系统测试（QA去干，黑盒测试）
  - 验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM）
- 系统上线
- 系统运维：跟进bug的反馈，排查线上日志，解决bug

知道整个软件的流程和每一个步骤的规范要做什么，要怎么做。

### 2.项目管理

如何带着一个团队，给他们分配好任务，带着他们一步一步的把这个流程全部做完呢？

要做到这一点，就是要依靠项目管理，对整个项目进行管理和把控，确保说带着一个team可以把你定义好的一整套东西全部做出来。

（1）项目管理：项目管理计划、项目执行和监控、风险管理、变更管理、质量管理（配置管理+测试管理+缺陷管理），5大过程域、9大领域、44个定义

（2）瀑布式 vs 敏捷式

在一个项目从0到1的时候，采取瀑布式的方式来做，是挺靠谱的。需求变动是比较少的，还没有涉及到终端用户的反馈，其实就是一个初始产品的研发。

从1到10的时候，此时系统已经上线了，面向终端用户去使用了，大量的需求迭代，并行的多个项目，直接会喷涌而来，此时瀑布式的方式来做，就不太灵活了，这个时候可能就需要用到敏捷式的开发流程和项目管理。

### 3.开发流程

1.业务调研

产品经理搞明白需求是什么。

2.需求分析

作为架构师，你拿到了一份产品经理给的需求文档之后，这个需求文档里，定义清楚了整体的一个需求，包含系统需要哪些功能模块，整体系统的核心业务流程是什么样子的，还有一些其他的特殊需求。

我们第一件事情，就是要对这份需求文档，进行需求分析。

不是上来就开始进行需求分析了，而是说先去定下来需求分析的规范，怎么进行需求分析。

在规范里，我们是没有包含特定的项目相关的信息的，其实就是一份通用模板，包含了这个需求分析文档要有哪些部分，每个部分要放什么东西。

用例到底是什么？其实很简单，一个用例就是一个功能。

其实用例图怎么画呢？其实就是从我们之前写的那份需求文档里抽取出来的，在需求文档里系统流程中，执行的各种动词，一个动词基本就是这个系统要实现的一个功能，一个动词一般来说就对应着一个用例。

画这个用例图，其实就是要标明，这个系统他到底有哪些功能，这些功能是跟谁相关的。

需求分析，是基于需求文档来的（我们之前产出的那个需求文档），需求分析做完以后，我们应该非常清楚，系统的具体的功能有哪些，每个功能的具体业务流程是什么，系统在运转过程中需要的核心数据是什么（领域类）。

用例图、每个用例的泳道图

3.概要设计

作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构。

4.概要设计评审

在完成了概要设计之后，一般会召开这个概要设计的评审。而且可能不只是评审一次，可能会先第一次评审，然后一堆人指出一堆问题，然后负责设计的架构师回去修改，修改完之后，二次评审，可能还是不行，继续回去修改，接着进行三次评审。

每次评审，就是召开一个评审会议，架构师负责在评审会议上讲解自己整个设计方案，一般会邀请级别较高的人出席这个评审会议，来对技术架构进行严格的把关。比如我是一个部门的架构师，我的重要方案评审的时候，可能会找其他部门的架构师过来，帮忙评审。同时也会让项目组内的全体成员都出席，确保每个人都听明白了架构设计，有问题及时抛出，然后讨论。

之所以要评审，是为了保证说，架构师设计出来的架构方案，是比较合理的，而且没有什么明显的缺陷。

这份规范，是约定一下，在评审的时候，负责评审的人，主要从哪些方面去挑剔和挑战负责架构设计的同学，尽量去找出来系统可能存在的漏洞。

5.详细设计

概要设计已经完成，而且通过了评审

（1）逻辑架构 -> 技术架构，已经确定ok了

（2）运行架构 -> 时序图，已经确定ok了，系统跑起来是什么样子的

（3）物理架构 -> 系统开发、测试和线上环境部署的

团队内部每个人认领部分模块或者子系统，然后每个人自己做详细设计。

概要设计主要确定的是架构，详细设计主要确定的是如何去编码实现。

也就是说，一份良好的详细设计文档，写好之后，基本你看着文档，就是傻瓜式的将设计翻译为代码了。

实际上来说，你写代码的过程，就是一个傻瓜式的过程，因为你怎么写这个代码，在详细设计文档里基本都已经定义清楚了。

6.详细设计评审

每个人都完成各自的负责的子系统的详细设计之后，每个人各自要召开自己的详细设计评审会。

这个详细设计的评审，就不是从其他部门请来一些架构师来评审，人家精力有限，不会给你过那么细节的东西，概要设计评审的时候，给你看看主要的架构的设计。

详细设计，就落实到具体的细节的层面，主要是靠架构师来对自己的团队内的各个成员的详细设计来进行评审。

7.工程初始化

每个人本地的开发环境搭建。

资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请。

数据库初始化。

代码初始化和上传。

整个软件工程的流程，是环环相扣的，需求分析 -> 概要设计 -> 详细设计 -> 工程初始化。

8.版本控制

版本控制规范是什么意思呢？

这个时候代码还不能开始写，为什么呢？你这个时候不是在瞎写么？每个人用一个分支？每个人用不同的分支？分支与分支之间什么时候集成？怎么集成？在各个环境中流转的时候，分支怎么切换？

版本控制规范

（1）Git工作流，为你的团队和你的项目选择一套合理的Git工作流：分支如何管理，如何合并，分支工作的流程。

（2）在Git工作流之外的一些规范，比如commit的提交规范，每天提交一次？还是按照什么粒度提交一次？commit的时候，写comment的备注的规范是什么？

GitFlow工作流，大家会发现，严格要求版本稳定，一个大版本，一个大版本的往前走。

比较适合系统从0到1的时候。

9.编码开发

编码，可是要规范的啊。

如果编码这块随便瞎编写的话，那就很坑爹，很多人按照自己的风格来写代码，最后出来的这个代码很乱。

一个系统里，感觉不同的人写出来的代码差别很大。

比如有的人，把UserDAO；有的人，是写成UserDao。

还有的人，IUserService；有的人，就是UserService。

如果你没有一套统一的编码规范的话，会导致不同的人出来的这个代码看起来差别很大，增加以后的代码的维护成本。

别人要来读懂你的代码，要来维护和修改的话，会导致无所适从。

一般来说，正经的公司，对编码规范这块，需要两个东西，第一个东西，是说约定好编码按照什么样的一整套的规范来；第二个东西，是说后面你需要有一个机制来确保每个人都是按照这个规范来走的。

在以前很早的时候，编码规范是有的，然后靠哪个环节来控制编码规范呢？靠的是code review，代码审查，别人在你写好代码之后，来阅读你的代码，如果有发现没有按照编码规范来的情况，告诉你，让你来修改代码。这个方式有很大的弊端，首先就是靠人力一点一点去审查代码，看有没有按照标准来写代码，会耗费很大的人力成本。另外一个，靠人力来审查，很可能会漏掉一些问题，不一定能做到百分之百的准确。

比较好的一件事情，到我们今天为止，正好，就是有个比较大的福音，阿里发布了自己的一个Java开发手册。就是比较标准和完善的一份Java开发手册，基本上都是比较核心的，和重要的一些规范。如果规范写得太多太细了，没有人能记得住的。编码规范，就是提取比较重要的一些规范，精简，让人可以记住，可以按照这个去做就ok了。

直接采用阿里巴巴的java开发规范手册就可以了 。

阿里还有一点比较好，就是他们出版了对应这个java开发手册的一个静态代码扫描的插件，跟eclipse，IntelliJ IDEA整合起来。

我们就是需要熟悉一下阿里的java规范手册，写代码按照这个来；写完代码之后，用静态代码扫描插件，扫描一下我们的代码，它会按照它预定义的规则，去检查代码，如果有不符合标准的地方，然后按照插件给出的建议来修改即可。

我们基于这个蓝本去修改一下，简化一下，形成我们自己的一个word版本的一个文档。

10.系统测试

1. 单元测试（白盒测试）

1. 冒烟测试

1. 静态代码扫描

1. 代码审查

1. 集成测试（联调测试，也可能是RD自己干，不是QA干）

1. 系统测试（QA去干，黑盒测试）

1. 验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM）

11.系统上线

12.线上运维

### 4.项目管理

1.项目管理计划

项目管理计划：就是在完成所有的技术设计之后，我们已经知道要怎么做这个系统了。但是现在的问题在于说，按照什么样的节奏、步骤和进度去完成所有的开发、测试以及上线的工作呢？

在概要设计+详细设计都搞定之后，会有一个步骤，叫做排期。

每个人给出自己的排期，所有人的排期合并在一起，组成项目的一个完整的排期。就是每个人对自己负责的那个部分，给出来每个环节/功能要做完，需要花费多少时间，需要从几号到几号去做。然后的话呢，项目的总负责人，大R，就会按照这份排期去跟进和管理项目组的开发，直到最后确保项目的上线。

制定下来一套初步的立刻可以落地执行和实施的项目管理的规范，按照这套规范去执行整个项目的管理。

2.项目监控

项目中可能有很多个人，很多种角色，可能项目组里有4个人，5个人，10个人，20人，30人，50人。100人的大团队协同作战。

如果你只是定好了项目的管理计划，而没有做任何的项目执行的进度把控，那么其实那个计划，正常来说，就会流于形式和表面。设想一个场景，假设你把项目进度计划做的很棒，很好了，这份项目计划直接发下去。然后接下来你就不管了，你可以想象一下，项目会干成什么样子？两个问题，一定是人都是有惰性的，这个是人性，不是说一个人是好人，还是坏人，就是只要没有监督和管理，人一定是会或多或少有惰性的。哪怕是一个靠谱的人，在没有监管的情况下，惰性一旦发生，就可能会导致什么呢？

项目执行的监控和把控

如果不进行严格、科学以及良好的项目执行的监控，可能就会发生各种各样想不到的情况跟，到每周看一下进度的时候，各种delay，各种延期，各种没做完，找了一大堆的借口出来，死猪不怕开水烫的样子。项目就濒临崩溃。。。。

不是这个人有惰性，这个人，他可能是能力不够，做事情的过程中，一定是会遇到这样那样的一些困难、挑战以及问题的，自己没法解决，然后你又没有及时关注，最后直接导致这个人的工作delay。长此以往，项目崩溃。。。。

项目崩溃，本来预定的是6月5号上线，结果，6月12号，6月20号，7月1号。整整延期了1个月，一个10人的团队，每个人平均年薪24万。平均月薪2万。每个月公司的工资的成本就是20万。也就是说，项目胡乱管理，团队战斗力太差，项目每次延期一个月，给公司空耗20万的资金。

带两个同学，一块儿去做一个项目。性格上都有问题，计划的时候，颗粒度太粗了；拉不下面子去每天监控每个人的执行进度；有些人还有脾气，反正当时定的是5天干完一个事儿，那我就5天之内干完这个事儿不就得了。你干嘛每天来东厂太监一样来监视我，硬逼着我每天必须干完什么事情。歪理，项目，是一个变动性很高的事情，做的过程中，可能会有各种各样的一些变化，每天卡着进度是不合理的。

那个项目就失败了，原本预定是在8月底上线，结果一直拖拖拖拖到了10月底才上线，延期2个月，失败的项目管理的例子。

3.项目风险管理

4.项目变更管理

# 需求评审规范

### 1.需求评审规范

1、需求是否足够清晰

要判断这个需求，你看了以后，是否脑子里能完全展现出来整体的图，就是包括界面是怎么操作的，在界面上用户的操作流程是什么样子的？每一步操作，要显示什么表单、什么表格？查询条件的默认值？是否要分页？

原则，你必须要看了需求以后，脑子里直接出来一个产品的界面操作图，然后后台系统的一些流程，在你架构师的脑子里，基本都出来了。

2、对需求中不合理的地方提出改进建议

查询菜单，是默认就查询两级，或者是三级，但是我们考虑到了可能有的菜单是三级的，你要是就查询两级，就不对了。产品设计就错了。

思考说，按照这个需求去走，以后一些特殊的场景，会否导致需求和系统开发要全盘推翻，重新去做。需求流程是否合理。

3、对不需要做的需求提议砍掉

有些需求，在当前这个版本特殊的背景下，可能是不需要的，我们要去考虑说，是否建议放到下一个版本去做。我们有权利提议砍掉一些需求，集中力量干大事儿。

# 系统开发规范

## 系统开发流程

### 1.系统开发流程

（1）业务调研：产品经理搞明白需求是什么。

（2）需求分析：我们去分析产品经理给的需求文档，梳理出系统要干嘛。

（3）概要设计：作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构。

（4）概要设计评审：找其他部门的架构师来帮忙评审一下我们的架构方案。

（5）详细设计：指导团队里的各个同学，自己对自己负责的部分进行详细设计，数据库建模、接口设计、类设计、包设计、功能流程设计、单元测试设计、冒烟测试设计、日志设计。

（6）详细设计评审：我们作为架构师要仔细去看一下各个同学的详细设计，确保没问题。

（7）工程初始化：指派多个同学，完成所有的初始化的一些事情。

（8）版本控制：明确如何对代码进行版本控制，工作流是什么。

（9）编码开发：根据阿里的开发规范，写代码即可。

（10）单元测试：自己写所有的单元测试，测试每一个类。

（11）冒烟测试：自己对负责的系统跑起来，冒烟测一下核心功能。

（12）静态代码扫描：确保自己的代码符合规范。

（13）单元测试覆盖率报告：跑出来自己写的那些单元测试，覆盖了百分之多少的代码

（14）代码审查：由高级别的人去审查自己的代码

（15）集成测试：所有环节集成在一起，确保系统整体流程炮通

（16）系统测试：QA来严格测试每个功能

（17）验收测试：PM验收系统

（18）系统上线：按照严格的步骤去执行上线 （19）线上运维：按照标准化的流程去处理线上的bug

## 需求分析规范

### 1.需求分析规范

1、引言

1.1 编写目的

表明这份需求分析文档的核心目的是什么，比如说是用来定义系统的核心功能的，指导后续的系统设计的。

1.2 面向对象

该文档编写出来之后，是要给谁看的？其实主要是给RD看的，让工程师明白系统要做哪些东西。

1.3 参考文档

（1）《电商系统v1.0需求文档》

2、概述

2.1 开发意图

描述清楚咱们这个系统开发出来是用来干嘛的，主要的作用是什么。

2.2 功能结构图

功能结构图，主要是给人一目了然的看到这个系统需要包含哪些子系统，每个子系统包含哪些模块，每个模块包含哪些功能，同时对每个子系统以及其模块进行简单的介绍。功能结构图只是一个静态的这么一个东西。

2.3 功能简介

2.3.1 XX子系统

XX子系统主要是用来干什么的

2.3.1.1 模块1

模块1主要是用来干什么的

2.3.1.2 模块2

模块2是用来干什么的

2.3.2 XX子系统

3、用例图

用例图其实也是用来描述一个系统的这么一个功能的，但是他的意义不太一样，我们从另外一个角度来看一下这个系统的功能。他是每个子系统画一张用例图，这张用例图可能会很大。这个用例图最关键的一点是，强调出来系统的功能，但是同时要强调出来，是哪些参与者跟这些功能在交互。

举个例子，比如说商品中心，商品部门的运营专员，他会负责去使用这个新增商品这个用例，其实这里要体现出来，就是时候每个参与者跟每个用例的关系，每个用例就是对应着一个功能。同时这个参与者可能不是一个人，可能是外部的其他系统，比如说订单中心的更新订单状态的这么一个用例，可能是WMS系统是一个参与者，调用了更新订单状态的这么一个用例。

用例图，是在功能结构图基础之上， 再从另外一个角度来描述这个系统的功能，也就是说描述清楚哪些参与者跟哪些用例有关系。

3.1 XX子系统

每个子系统是一张用例图，一张用例图中包含了很多个用例 。

3.1.1 功能概述

说一下XX子系统的功能大概是干嘛的，这里可以说一下，这个子系统是干嘛的，里面包含了哪些模块 。

3.1.2 用例图

一般情况下，我们正常而言，一个用例就是一个单独的一个功能。但是，我们发现自己的系统中，有很多是CRUD类的用例，对某个数据列表、新增、删除、修改、启用/停用，基本就是这么些东西，或者是加上一些提交审核、审核。然后他的话呢就是有很多的重复性的东西。特别的琐碎。

再加上我们的系统比较庞大的，包含了16个中心，几十个模块，几百个功能。如果你每个中心去画一个用例图，每个中心可能都是几十个功能，那个用例图看起来会特别的庞杂无序。

这里我们来思考一下，我们画用例图的本质是为了什么？为了体现出系统中的一些功能跟参与者的一个关系，就可以了。

所以说，如果是这样子的话，我们可以考虑在画用例图的时候，可以考虑将一个模块作为一个用例，也是可以的，看透背后的本质，不要拘泥于固定的形式，一定要懂得变通。画出来这个子系统中，参与者跟模块用例之间的一个关系即可。如果以后觉得有时间了，一定要做一些扩展的话，可以考虑采用包含关系，去画出来一个模块用例里面包含的一些功能用例。

一般情况下，为了简化起见，可以就只是画关联关系就可以了，表明哪些参与者会去执行哪些用例 。

包含关闭、扩展关系，会相对增加复杂性，可以将那些太细的一些用例不画在里面了 。

3.1.3 用例描述

用例描述这块是这样，如果是系统很大，时间比较着急，同时的话呢某个用例功能对应的流程不是特别的复杂，而且呢，在需求文档里，如果对这个功能的使用流程有了较为详细的说明，我们可以简化，不在这里对每个功能，每个用例，做过于详细的描述。

但是这里需要写明，可以参考需求文档中的功能描述以及功能运行流程

什么情况下，需要对这个用例进行详细的描述呢？如果某个用例，他压根儿就不是产品需求文档里提到的，比如说你自己想到的系统应该做的某个事情，采购入库单的校验，采购入库单备份看，有些用例可能是会在需求分析的过程中，自己站在架构师的角度，初步加入了一些额外的系统层面的功能。那么这种你肯定就是要详细描述用例的。

另外一个，对于一些核心的，重要的功能，要求必须是得写详细的用例描述。常见于某个功能有较为复杂的流程，比如说我们后面的那个调度销售出库，这个用例，他的流程就较为复杂，要跟其他的系统做一些交互，可能光靠需求文档中的描述，不一定特别的清晰。需要我们架构师去对核心重要的功能，包含了复杂的业务流程，去要做详细的描述，画清楚他的泳道图。

3.1.3.1 用例1描述

（1）简要说明

这个用例对应的功能是干嘛的 。

比如说，新建订单用例主要是用户在购物车中，可以对要下单的商品进行选择，同时选择要使用的优惠，在订单计算出来金额之后，确定提交订单。

（2）事件流

在执行这个用例的时候，需要执行哪些操作和步骤。

步骤1：选择要订购的商品

步骤2：对商品的库存进行校验

步骤3：选择这个订单要使用的优惠是什么

步骤4：计算出来订单的最终金额

步骤5：点击确认提交订单

步骤6：生成订单

（3）事件流图（processon画泳道图）

将上面写好的事件流画成事件流图，一般用泳道图来表示 。

3.1.3.2 用例2描述

3.1.3.3 用例3描述

4、领域类图

领域类图，一般就是从系统间的调用和流转，使用的核心数据类。

订单类，就是一个典型的领域类。

一般来说，领域类如何抽象，其实就是将需求文档中比较核心的那些数据抽象成领域类，比如订单，库存调拨单，出库单，入库单。

这边是可以将一个较为复杂的领域类图拆分为多个领域类，比如说订单主信息，订单项信息，订单优惠信息。

还是这个从实践中来，如果说希望加快项目的进度，不要在写文档上耗费过多的时间，领域类图有一个实践，就是只要将核心的领域类与领域类之间的关系画出来就可以了，不需要给出这个领域类的字段。因为可能需求文档中已经将领域类的字段基本都给出来了。不需要再这个环节去确认这个字段。只是确认系统里核心的一些领域类。具体的字段可以参考需求文档。

在这个环节，要不要做的很仔细，考虑如何将一个领域类，比如说，商品领域类，拆分成商品基础信息，商品价格信息，一般建议不需要，因为这个环节里，主要还是面向需求的。

领域类图将每个子系统中，核心的领域数据，描述出来，让我们看一眼大概知道即可。

4.1 XX子系统

4.1.1 领域类1

4.1.2 领域类2

4.1.3 领域类3

## 系统设计规范

### 1.概要设计规范

1、引言

1.1 编写目的

1.2 面向对象

1.3 参考文档

2、逻辑架构

采用技术栈架构，包含业务架构，以及系统整体技术架构 。

2.1 逻辑架构图

没有固定的格式，将整体技术架构画清楚即可。

逻辑架构图，是在正儿八经做系统设计的时候，必须要画的第一张图，这张图必须得有，必须得有。这个图应该也是整套系统最最重要的一张图，直接就是体现了整套系统静态层面看起来长什么样子的。

2.2 设计细节

对架构设计中各个环节进行文字说明 。

3、运行架构

3.1 系统核心流程时序图

将系统整体的各个核心流程的时序图画出来，子系统之间的交互就很清楚了，要求粒度到每一个用例级别，每个子系统的用例都要在时序图上有所体现 。

整体的一个思路是什么呢？将系统的所有核心流程，一个一个的在这里用时序图表现出来，这个图里就涉及到了各个子系统在核心流程中会干什么，会负责什么事情，如何将多个子系统串联起来实现整个电商的一个核心的业务流程 。

生命线、激活、消息

3.1.1 系统核心流程1时序图

3.1.2 系统核心流程2时序图

3.2 XX子系统

这块是这样子的，如果你觉得有些功能，特别复杂，流程也很复杂，那么可以在这里就是对部分核心功能的运行流程，站在技术的角度，去给他画一张时序图出来，画的比较详细。而且流程结合了一些你的特殊的技术设计，重要的核心的功能，还是建议在这里画一些。

但是，如果说你已经把系统运行的核心流程的时序图给画出来了，那是个必不可少的，必画。但是具体的一些功能的运行流程，在这个地方，如果你觉得大体上跟之前的需求文档是差不多的，你可以不画。

3.2.1 XX模块

3.2.1.1 XX功能1时序图

对上面的核心流程时序图中的每个用例，都画出来具体的每个用例的时序图

3.2.1.2 XX功能2时序图

4、物理架构

4.1 软件架构（组件图）

子系统以及各个基础设施的交互

4.2 硬件架构（配置图）

具体的各个环境的系统以及基础设施的物理部署

4.2.1 开发环境硬件架构

4.2.2 集成测试环境的硬件架构

4.2.3 系统测试环境的硬件架构

4.2.4 验收测试环境的硬件架构

4.2.5 线上环境的硬件架构

### 2.概要设计评审规范

1、要评审的一些点

负责评审的同学，需要对架构设计方案，从以下的角度考虑：

（1）并发性：考量一下，现有的系统架构，能支撑多高的并发，如果说未来并发持续上升的话，这套架构会不会扛不住

（2）伸缩性：考量一下，如果未来系统架构撑不住并发量了 ，现有的这套系统架构，是否是可伸缩的，就是能否在需要的时候，通过加机器，扩容，来增强它能抗住的并发量

（3）可用性：现有的这套系统架构，是否可能会出现不可用的情况，比如说某个外部依赖挂掉了，或者是流量激增，等等，会不会有哪些情况导致系统跨掉了

（4）扩展性：如果后续要对系统进行大量的迭代，快速的业务需求开发，大量的代码改动，现有的这套架构，能否支撑系统快速扩展

（5）安全性：现有系统架构，存在了哪些安全性的漏洞，是否可能被攻击，导致系统挂掉，是否可能导致系统的数据丢失

（6）性能：现有的系统架构，是否会在哪些地方出现性能的瓶颈，或者性能较差的一些情况

（7）稳定性：现有系统是否考虑到了日志、监控、线上问题的快速排查和处理、系统功能运转的一个稳定性

2、要重点评审哪个部分

概要设计文档里面，逻辑架构、运行架构、物理架构

重点要考虑的，就是这个逻辑架构，因为这个逻辑架构就体现了所有的一切技术性的东西和设计

要考虑一下，逻辑架构体现的技术架构中，是否有哪些缺陷和漏洞

3、设计评审的记录

### 3.详细设计规范

1、数据架构设计

1.1 数据库ER模型图

PowerDesigner ER建模

数据库的ER建模，ER，Entity Relationship，实体关系，一个表就是一个实体，设计表与表之间的一个关系，也就是实体与实体之间的一个关系

包括每个实体包含哪些属性，表包含了哪些字段

一般就是根据需求分析以及概要设计中的内容来考量，就是说负责的这个模块，具体需要哪些数据库表去承载，才能实现出来

将所有需要的表，全部在一张ER模型图中体现出来

1.2 数据库逻辑设计

PowerDesigner将ER模型转为逻辑模型

1.2 数据库物理设计

PowerDesigner将逻辑模型转为物理模型

在正规的流程中，必须是对每个系统，都完成数据库ER模型之后，去完成后续的设计，包括接口、类图、运行流程，结合运行流程，你要执行哪些增删改查的操作，反过来完善物理模型的设计，包括索引、主外键关系。

但是我们这边说一个实践中可以权衡的这么一个方案，就是说，实现类图这一块，我们将增删改查的controller、service、dao、mappper，都没在类图中去设计。这个在实际开发中是可以的。

所以这就导致我们没法在现在这个阶段，就直接完成索引的设计，因为包括mapper里面有哪些方法和sql都不太清楚，就可以在开发的过程中，一边开发，一边结合你写的sql来设计数据库的索引。

然后在code review的时候，申请别人review一下索引的设计。

2、接口设计

（1）DO：Data Object，数据对象，一个DO一般是对应于一张表，或者是Mapper查询接口中的返回类型，mapper和dao返回的都是DO

（2）DTO：Data Transfer Object，数据传输对象，service组件需要将dao组件返回的DO对象给封装成DTO对象，再返回给controller组件，或者是别的service组件。service必须将数据封装为DTO，返回给其他的controller或者是service来使用

（3）VO：view object，其实就是将页面中需要展示的数据封装在VO里面，然后在以前是将VO给传输给页面模板，比如JSP（JSTL标签语法，可以将VO中的数据给展示出来），freemarker，velocity，thymeleaf。restful接口，在接口中可以将一个接口要返回的数据，封装在VO里面，从接口返回即可。

（4）Query：查询条件，controller里面接收的页面发送过来的查条件，哪怕是service层对外暴露的接口，也可以用query来接收复杂的一些查询条件

（5）PO：就是将DO不是作为data object，而是作为domain object，然后将PO作为persistence object，一个PO对应一张表，DO就是我们平时放在domain包中的领域模型对象

（6）BO：service组件对外可以返回这个BO，这个BO的话呢是包含业务逻辑的，不光是包含一堆数据和getter和setter方法，还包括了这个很多的业务逻辑方法

（7）AO：application object，就是跟展示层相关的一些数据

但是，有一点很重要的是，这个模块与模块之间的交互的接口，比如说采购中心和调度中心之间的交互，都是需要依靠接口的，而且我们需要在整个工程初始化的时候，就将这个接口给定义出来。所以模块与模块之间的交互的接口，必须是要设计的。

2.1 XX模块

2.1.1 XX接口

（1）接口类

（2）接口方法名称

（3）接口描述

（4）输入

（5）输出

3、开发架构设计

3.1 实现类图设计

根据之前的需求分析文档、概要设计文档、数据库模型、接口，去考虑，实现接口的功能，需要哪些类，类与类之间的关系是什么，每个类有哪些成员变量，每个类有哪些方法 。

在这里说明一点，这里其实就是所谓的Java面向对象编程的核心所在，这里其实是很体现一个工程师的水平的 。

UML的类图里，其实就三点

（1）把每个类都画出来

（2）类与类之间的继承关系画出来，实线+空心箭头

（3）接口实线关系，虚线+空心箭头

（4）依赖关系，虚线+简单箭头

（5）关联关系，实线+简单箭头

（6）组合关系，实心菱形+实线+简单箭头

（7）聚合关系，空心菱形+实线+简单箭头

在一个普通的业务系统里面，一定是有一些最最基本和最最简单的CRUD，增删改查，如果是最普通的增删改查的操作，可以不用画这个实现类图。此时，就是对于这种CRUD的功能，只要有这个接口，运行流程，你知道基于设计好的数据库模型，可以实现就ok了。

3.2 包设计

在UML中有包图的概念，我在这里先补讲，我比较少用

至少你要设计出来，你有哪些包，每个包下面有哪些类

com.zhss.eshop.order.domain

com.zhss.eshop.order.controller

com.zhss.eshop.order.mapper

com.zhss.eshop.order.dao

com.zhss.eshop.order.service

4、运行流程设计（活动图）

如果是有较为复杂的业务流程，则必须画活动图。

如果仅仅只是一些相对简单的CRUD，则文字描述清楚你的代码实现逻辑即可。

4.1 XX模块

4.1.1 XX功能1

每一个功能，参考之前概要设计中的每个功能的用例图，类图、数据库表，画出来这个活动图 。

用例图，基本上还是重点在体现较为高层的系统功能的运行流程 。

活动图，就要画出来，每个类和每个表之间的交互关系，完整体现出来你的功能要实现的时候，各个类以及表之间的交互顺序和逻辑 。

4.1.2 XX功能2

5、测试用例设计

5.1 单元测试用例设计

5.1.1 XX模块

5.1.1.1 测试用例1

对每个类设计对应的单元测试类，每个方法都要有单元测试的方法

（1）数据准备

（2）输入

（3）输出

（4）资源清理

5.1.1.2 测试用例2

5.2 冒烟测试用例设计

5.2.1 XX模块

5.2.1.1 测试用例1

（1）数据准备

（2）输入

（3）输出

（4）资源清理

5.2.1.2 测试用例2

6、日志设计

6.1 XX模块

6.1.1 XX功能

（1）日志埋点1

（2）日志埋点2

### 4.详细设计评审规范

详细设计，就落实到具体的细节的层面，主要是靠架构师来对自己的团队内的各个成员的详细设计来进行评审。

1、数据库设计的评审

重点关注一下数据库设计的索引，索引要确保说未来系统中已有的和可能有的各种功能，都可以用到索引，不会出现全表扫描的情况。

索引设计要好好结合业务需求，去考虑如何建联合索引。

要重点看一看数据库里面的索引设计。

数据库的设计这块，一方面你是看一看表名、字段名的命名，备注，你是否看得懂；数据库ER实体之间的关系是否正确；数据库整个设计，凭自己的感觉去看看，有没有什么问题；看看每个表都建立了哪些索引，让召开评审的同学说一说每个索引的用处。

2、接口设计的评审

主要是要调用这个人的接口的调用方，要好好仔细看一下接口设计，确认一下接口设计能否满足自己的需求。

主要不是架构师看的，同一个团队内部有互相调用关系的几个同学，互相之间要去看看对方的接口设计，能否满足自己的需求。包括，针对前端的接口，需要前端同学过来参加这个评审，让前端看看这个接口能否满足他的需求。

3、开发架构的评审

面向对象的类图的设计，好好考虑一下，面向对象做的怎么样，是否逻辑清晰，拆分合理，未来的可扩展性是否足够好。

设计模式，就体现在这里了，就类图设计里，看看有没有用合理的良好的设计模式，来进行面向对象的设计，保障代码有足够好的扩展性。

4、活动图的评审

仔细过一下，看看每个功能的活动图，里面逻辑是否准确。

对于一些不复杂的流程，可以手写文字版本的运行流程就可以了

但是对于一些核心的，复杂的，重要的业务流程，我们需要去画活动图，通过活动图体现出来一个正确的，清晰的系统运行的流程

5、测试用例的评审

这块需要好好看一下，是否对每个类的每个方法都设计了单元测试。

在项目初期，进度紧张，业务不是非常的复杂，技术架构不复杂的情况下，可以简略这块的设计，只要提一句，核心的类里面每个方法都要写单元测试就可以了。

到了后期，做一些较为复杂的系统的时候，技术架构也比较复杂，测试用例，正例、反例、异常情况，都需要去设计

6、日志的评审

这块也要好好看一下，对系统各个可能出异常的地方，是否打印了异常日志以及案发现场的保护日志。

刚开始项目初期，进度紧张，系统不是特别复杂，提一句就可以了，在每个类的每个方法中，尽量自己捕获自己的异常，能自己处理的异常就自己处理，有异常就打印出异常相关的完整的日志，日志是帮助我们在处理线上报错和bug的时候排查问题的

但是在系统后期，对于一些技术架构较为复杂的部分，都是需要去精心设计在什么地方打日志，每个日志包含什么内容的

## 工程初始化规范

### 1.工程初始化规范

1、每个人本地搭建好开发环境

（1）JDK

（2）开发IDE：eclipse、IntelliJ IDEA

（3）maven：配置nexus私服的地址，settings.xml

（4）git

2、完成资源申请

对你的技术架构中，所有需要使用的技术相关的资源进行申请。

如果是在大公司里面：需要跟对应的dba、redis运维团队、RabbitMQ运维团队，申请你需要使用的数据库、redis集群、RabbitMQ资源。

还有你的java服务需要部署的机器资源，也需要跟SRE（运维团队）来申请。

而且要申请好所有环境的资源。

（1）开发环境（dev）：在这个环境中，部署需要使用的mysql、redis、rabbitmq，等等，然后各个开发人员在自己本地，是直接连接统一的一个开发环境中的数据库、缓存、mq，来进行开发和测试的。单元测试，不跟外部依赖的基础设施打交道的；但是在本地冒烟测试，是需要将自己负责的程序跑起来，跟开发环境中的基础设施交互，确保主流程没问题。

（2）集成测试环境（beta）：在这个环境中，其实就是所有人对一个版本都开发好之后，需要进行联调，系统集成。将所有人负责的东西全部集成到一起，如果是单块应用，将每个人的代码分支全部集成到一个统一的分支上去，将那个分支上集成好的代码，部署到集成测试环境的机器上去，同时连的是集成测试环境中的数据库、缓存、MQ。集成测试，部署好之后，由QA来执行，有时候RD自己来做，要将整个系统的所有部分集成在一起，主流程，主功能，跑通。。

（3）系统测试环境（test）：在这个环境中，同样，是需要将集成好的代码，部署到系统测试环境中的机器上去，同时连的是系统测试环境中的数据库、缓存、MQ。主要就是测试工程师，QA介入，进行黑盒测试，他们会写各种测试用例，非常非常的细，这一步重点是测试系统的所有功能包括各个细节点，全部都正确。

（4）验收测试环境（staging）：在这个环境中，尽量保证跟线上环境一致的情况。比如说mysql，主从架构；开发环境、集成测试环境、系统测试环境里，可能就是单实例mysql；在验收测试环境中，就需要根线上尽量保持一致，必然线上规划的是mysql一主三从的架构，在staging环境，可以简化为一主一从。在这一步的重点意义是，模拟线上环境，甚至有时候会将部分线上环境的数据，或者是请求流量，导入到这个环境中来。这一步重点是需求方来做验收，比如说产品经理，准备好一堆测试用例，在这个环境去使用你的系统，看是否正确

（5）线上环境（prod）：线上环境，所有的基础设施全部按照规划好的线上环境配置来走。

可以看一下，这里各个环境的资源怎么申请，申请多少，怎么部署，是根据什么来的？

概要设计里面的物理架构：配置图，硬件层面去考虑，需要哪些机器，部署哪些基础设施，多少台机器，多少个集群，跨几个机房。

3、数据库初始化

基于详细设计中的数据库建模，PowerDesigner，里面设计好了各种物理表结构，导出来一份SQL文件。

直接基于那份SQL文件，在开发环境中的数据库里，建好需要的库，初始化好所有的表结构。

4、 工程搭建

一般会指定一个人，架构师，也可能是项目组中的其他人。

负责在自己本地的IDE中，建立好一个工程，对这个工程中完成系统需要的技术框架的整合（Spring Boot + Spring MVC + Spring + MyBatis）。

（1）maven的pom.xml中，引入所有的依赖。

（2）对所有需要使用的技术，完成对应的配置，注解 / xml。

（3）其他的工程结构，完成搭建：maven父子工程，maven pom.xml中配置跟nexus集成、用来打包的插件、用于单元测试的依赖、数据库连接池的依赖。

（4）本地写一个最基本的测试代码，将框架技术的整合全部跑通：接收http请求 -> 插入数据库，读写redis，读写rabbitmq，单元测试，日志的本地打印。

5、代码上传到仓库

负责搭建工程的那个哥儿们，将搭建好的工程代码，上传到GitLab的仓库中去。

项目组中其他的同学，就需要从GitLab中拉取代码下来，到自己本地，代码导入IDE中。

将负责搭建工程的那个哥儿们写好的那套测试代码，在本地运行一下，确保说，所有技术的整合以及运行全部能跑通。

## 版本控制规范

### 1.版本控制规范

1、Git工作流

初步定的是基于GitFlow工作流来做。

（1）feature分支

进入一个版本的开发之后，每个人自己拉对应的feature分支。feature分支的拉取，按照一个子系统一个feature分支；一个模块一个feature分支；一个需求一个feature分支；一个功能一个feature分支。不是固定死的，是根据当时的人力的任务分配情况，来定，怎么划分这个feature分支。

比如说我们现在，假设电商v1.0版本要做15个子系统，1+4的小team，一个架构师带4个初中级工程师。平均每个人分配到的是3个子系统。每个子系统拉一个feature分支，在那个子系统上，就专门开发需要的代码就可以了。

工程初始化的时候，负责工程搭建的同学，就将所有系统中需要的接口全部定义出来。

这样的话，每个人拉出来的featiure分支，自己仅仅写这个feature中需要的代码，但是如果你的feature中依赖了别人的子系统feature中的接口，没关系，一开始，所有的接口都定义好了。大家都面向接口开发就可以了。写单元测试的时候，对别人的接口实现，采取mock的方式来做。

每个人拉自己的feature分支，然后写自己的feature里的代码，对依赖别人的地方，面向接口编程。

feature的命名规范：feature/order-system-v1.0

（2）develop分支

代码初始化好之后，实际上代码是在master分支去初始化的。就直接从master分支拉一个develop分支出来，做为统一的代码集成的分支。

每个人的feature分支开发好之火，就每个人依次将自己的feature分支的代码，合并到develop分支，进行代码集成。所有人的代码，就在develop分支上，完成了集成，develop分支，就包含了系统这个版本需要的所有代码。

就可以基于develop分支的代码，去集成测试环境来部署，然后进行集成测试

集成测试的过程中，肯定是会不断的发现一些bug的，如何来修复bug呢？在什么分支上来修复bug？

一般来说，在集成测试环境，如果发现了这个bug的话，一般来说，对应有bug的同学，需要在自己的本地来复现这个bug。

这里，推荐说直接基于develop分支的代码来复现和修复bug，因为feature分支的代码是不完整的，可能是没法复现bug的，所以是不能通过feature分支的代码来复现和修复bug的。

负责修复bug的同学，将develop分支的代码拉到自己本地，本地跑起来，基于开发环境的基础设施，应该在自己本地是可以跑起来的。复现bug，追查bug产生的原因，然后可以直接在develop分支上来修复这个bug。

push develop分支的修改到GitLab上，然后所有人就基于最新的develop分支继续进行测试。

直到develop分支测试，感觉都保持稳定了，已经没有什么bug了，系统整体可以跑通，此时集成测试就结束了。

（3）release分支

针对当前这个整体的版本，来从develop分支拉一个release分支出来，命名规范就是release/v1.0.0

然后就可以基于release分支进行系统测试了，QA同学介入，对于release分支部署的环境，进行功能测试，确保所有的功能都是ok的。

如果此时发现有bug，同理，大家直接在release分支上去修复bug，包括在本地基于release分支代码复现bug，以及修复bug。

release分支如果测试到后面，稳定了，功能都ok了，测试结束了。

此时需要将release分支的代码合并到master分支上，同时将release分支的代码合并到develop分支上。

（4）master分支

在最一开始，工程初始化的时候，就是基于master分支去初始化的。

这边的话呢，每个版本的release分支都测试完之后，就可以将代码合并到master分支上来。此时master分支上的代码是经过了严格的测试的，单元测试、冒烟测试、集成测试、系统测试。

接下来，就是要进行验收测试了。

直接基于master分支的代码，部署到staging验收测试环境上去，在这个环境上，由PM来进行所有功能的验收。

一般来说，99%的情况，验收测试环节，就不应该有bug了，让需求方体验一把整体的流程，在上线之前，做最后一轮check。

如果这里发现了bug，那么在release分支上来复现这个bug，然后在release分支上来修改这个bug。

bug修复之后，QA会在release分支和系统测试环境中，来验证说bug修复了，然后还会再做一遍回归测试。

release分支分别合并到master分支和develop分支上去。

验收测试通过之后，对master分支来打tag，比如货v1.0.0，打完tag之后，基于这个tag的代码，来进行线上系统的部署。

（5）bugfix分支

线上发现了bug，而且判断这个bug的修复要超过1天的时间，那么需要从master分支拉一个bugfix分支下来，命名规范是bugfix/xx_bug。

在自己本地复现这个bug，基于bugfix分支上的代码，在自己本地来修复。

修复好bug之后，将bugfix分支的代码，合并一份到develop分支上去，然后让QA在集成测试环境，来初步验证一下说是ok的。

然后将bugfix的代码合并到master分支上去，将master分支代码在验收测试环境部署一下，让PM验证一下，bugfix是ok的。

给master分支打一个tag，再次将修复好bug的代码给上线。

（6）hotfix分支

线上发现了一个bug，很紧急，需要在1天之内必须修复，哪怕加班到凌晨3也得修复，整体流程跟bugfix分支一样 。

命名规范是hotfix/xx_bug。

（7）分支清理

在一个大的版本最终完成上线之后，需要将这个版本对应的一些分支清理掉，比如说feature分支、release分支，需要删除掉。

在修复好一个bug上线之后，需要将bugfix分支、hotfix分支，删除掉 。

2、commit规范

在各个分支上开发的时候，git最基本的就是git commit，git push。

git commit，是可以随便瞎commit的吗？每次commit的规范是什么？

（1）commit的时机：在feature分支上，一般建议，是每天提交一个commit；在release分支上，每次修复好一个bug，提交一个commit；在develop分支上，每次修复好一个bug，提交一个commit；bugfix分支，修复好bug之后，提交一个commit。

（2）commit comment的规范

标题：简短的说明了，你这次commit是干了什么，一般就是几十个字，不超过一行。

本次提交的代码改动列表：

1.完成UserServiceImpl的编写，完成了用户增删改查的功能实现

2.完成UserMapper的编写，完成了用户增删改查的数据库操作逻辑的实现

## 编码开发规范

### 1.编码开发规范

一、编程规约

(一) 命名风格

1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。

   反例：_ name / __name / $Object / name _ / name$ / Object$

2. 【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。

   说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。

   正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。

   反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3。

3. 【强制】类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO

   正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 。

   反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion。

4. 【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。

   正例： localValue / getHttpMessage() / inputUserId。

5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

   正例：MAX_STOCK_COUNT 。

   反例：MAX_COUNT。

6. 【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。

7. 【强制】中括号是数组类型的一部分，数组定义如下：String[] args;

   反例：使用String args[]的方式来定义。

8. 【强制】POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。

   反例：定义为基本数据类型Boolean isDeleted；的属性，它的方法也是isDeleted()，RPC框架在反向解析的时候，“以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。

9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为com.alibaba.open.util、类名为MessageUtils（此规则参考spring的框架结构）。

10. 【强制】杜绝完全不规范的缩写，避免望文不知义。

    反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。

11. 【推荐】为了达到代码自解释的目标，任何定义编程元素在命名时使用尽量完整单词 组合来表达其意。

    正例： 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository 。

    反例： 变量 int a; 的随意命名 方式。

12. 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 正例：public class OrderFactory;

    public class LoginProxy;

    public class ResourceObserver;

13. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。

    正例：接口方法签名：void f();

    接口基础常量表示：String COMPANY = "alibaba";

    反例：接口方法定义：public abstract void f();

    说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。

14. 接口和实现类的命名有两套规则：

    1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。

    正例：CacheServiceImpl实现CacheService接口。

    2） 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。

    正例：AbstractTranslator实现 Translatable。

15. 【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。

    说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。

    正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKOWN_REASON。

16. 【参考】各层命名规约：

    A) Service/DAO层方法命名规约

    1） 获取单个对象的方法用get做前缀。

    2） 获取多个对象的方法用list做前缀。

    3） 获取统计值的方法用count做前缀。

    4） 插入的方法用save/insert做前缀。

    5） 删除的方法用remove/delete做前缀。

    6） 修改的方法用update做前缀。

    B) 领域模型命名规约

    1） 数据对象：xxxDO，xxx即为数据表名。

    2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。

    3） 展示对象：xxxVO，xxx一般为网页名称。

    4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。

(二) 常量定义

1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。

   反例：String key = "Id#taobao_" + tradeId;

   cache.put(key, value);

2. 【强制】long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。

   说明：Long a = 2l; 写的是数字的21，还是Long型的2?

3. 【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。

   说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。

4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。

   1） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。

   2） 应用内共享常量：放置在一方库中，通常是modules中的constant目录下。

   反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：

   类A中：public static final String YES = "yes"; 类B中：public static final String YES = "y"; A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。 3） 子工程内部共享常量：即在当前子工程的constant目录下。

   4） 包内共享常量：即在当前包下单独的constant目录下。

   5） 类内共享常量：直接在类内部private static final定义。

5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。

   正例：public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}

(三) 代码格式

1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：

   1） 左大括号前不换行。

   2） 左大括号后换行。

   3） 右大括号前换行。

   4） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。

2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第5条下方正例提示。

   反例：if (空格a == b空格)

3. 【强制】if/for/while/switch/do等保留字与括号之间都必须加空格。

4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。

   说明：运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。

5. 【强制】采用4个空格缩进，禁止使用tab字符。

   说明： 如果使用 tab 缩进，必须设置 缩进，必须设置 缩进，必须设置 缩进，必须设置 缩进，必须设置 缩进，必须设置 1个 tab 为 4个空格。 IDEA 设置 tab 为 4个空格时， 请勿勾选 Use tab character ；而在 eclipse 中，必须勾选 insert spaces for tabs 。 正例： （涉及1-5点） public static void main(String[] args) { // 缩进4个空格 String say = "hello"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) { System.out.println("world"); // 右大括号前换行，右大括号后有else，不用换行 } else { System.out.println("ok"); // 在右大括号后直接结束，则必须换行 } }

6. 【强制】注释的双斜线与注释内容之间有且仅有一个空格。

   正例：// 注释内容，注意在//和注释内容之间有一个空格。

7. 【强制】单行字符数限不超过 120 个，超出需要换行时 个，超出需要换行时 遵循如下原则：

   1） 第二行相对一缩进 4个空格，从第三行开始不再继续缩进参考示例。

   2） 运算符与下文一起换行。

   3） 方法调用的点符号与下文一起换行。

   4） 方法调用时，多个参数，需要换行时，在逗号后进行。

   5） 在括号前不要换行，见反例。

   正例： StringBuffer sb = new StringBuffer(); // 超过120个字符的情况下，换行缩进4个空格，点号和方法名称一起换行 sb.append("zi").append("xin")... .append("huang")... .append("huang")... .append("huang"); 反例： StringBuffer sb = new StringBuffer(); // 超过120个字符的情况下，不要在括号前换行 sb.append("zi").append("xin")...append ("huang"); // 参数很多的方法调用可能超过120个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX);

8. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例：下例中实参的"a",后边必须要有一个空格。 method("a", "b", "c");

9. 【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用Windows格式。

10. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 正例： int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。

11. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。

    说明：没有必要插入多个空行进行隔开。

(四) OOP规约

1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。

2. 【强制】所有的覆写方法，必须加@Override注解。

   说明：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。

3. 【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。

   说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）

   正例：public User getUsers(String type, Integer... ids) {...}

4. 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。

5. 【强制】不能使用过时的类或方法。

   说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。

6. 【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。

   正例："test".equals(object);

   反例：object.equals("test");

   说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）

7. 【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。

   说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。

8. 关于基本数据类型与包装数据类型的使用标准如下：

   1） 【强制】所有的POJO类属性必须使用包装数据类型。

   2） 【强制】RPC方法的返回值和参数必须使用包装数据类型。

   3） 【推荐】所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。

   正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。

   反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。

9. 【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。

   反例：POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。

10. 【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。

    说明：注意serialVersionUID不一致会抛出序列化运行时异常。

11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。

12. 【强制】POJO类必须写toString方法。使用IDE的中工具：source> generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。

    说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。

13. 【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。 说明： String str = "a,b,c,,"; String[] ary = str.split(","); // 预期大于3，结果是3 System.out.println(ary.length);

14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第15条规则。

15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter方法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。

16. 【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。

    反例： public Integer getData() { if (true) { return this.data + 100; } else { return this.data - 100; } }

17. 【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。

    说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。 反例： String str = "start"; for (int i = 0; i < 100; i++) { str = str + "hello"; }

18. 【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：

    1） 不允许被继承的类，如：String类。

    2） 不允许修改引用的域对象，如：POJO类的域变量。

    3） 不允许被重写的方法，如：POJO类的setter方法。

    4） 不允许运行过程中重新赋值的局部变量。

    5） 避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。

19. 【推荐】慎用Object的clone方法来拷贝对象。

    说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。

20. 【推荐】类成员与方法访问控制从严：

    1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。

    2） 工具类不允许有public或default构造方法。

    3） 类非static成员变量并且与子类共享，必须是protected。

    4） 类非static成员变量并且仅在本类使用，必须是private。

    5） 类static成员变量如果仅在本类使用，必须是private。 6） 若是static成员变量，必须考虑是否为final。

    7） 类成员方法只供类内部调用，必须是private。

    8） 类成员方法只对继承类公开，那么限制为protected。

    说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。

    思考：如果是一个private的方法，想删除就删除，可是一个public的service方法，或者一个public的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。

(五) 集合处理

1. 【强制】关于hashCode和equals的处理，遵循如下规则：

   1） 只要重写equals，就必须重写hashCode。

   2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。

   3） 如果自定义对象做为Map的键，那么必须重写hashCode和equals。

   说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。

2. 【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.

   说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。

3. 【强制】在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常。

4. 【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。 说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。

   正例： List<String> list = new ArrayList<String>(2); list.add("guan"); list.add("bao"); String[] array = new String[list.size()]; array = list.toArray(array); 反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。

5. 【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。

   说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] { "you", "wu" }; List list = Arrays.asList(str);

   第一种情况：list.add("yangguanbao"); 运行时异常。

   第二种情况：str[0] = "gujin"; 那么list.get(0)也会随之修改。

6. 【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<? super T>不能使用get方法，做为接口调用赋值时易出错。 说明：扩展说一下PECS(Producer Extends Consumer Super)原则：

   第一、频繁往外读取内容的，适合用<? extends T>。

   第二、经常往里插入的，适合用<? super T>。

7. 【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。 正例： Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { String item = iterator.next(); if (删除元素的条件) { iterator.remove(); } }

   反例： List<String> list = new ArrayList<String>(); list.add("1"); list.add("2"); for (String item : list) { if ("1".equals(item)) { list.remove(item); } } 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？

8. 【强制】 在JDK7版本及以上，Comparator要满足如下三个条件，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。

   说明：三个条件如下

   1） x，y的比较结果和y，x的比较结果相反。 2） x>y，y>z，则x>z。

   3） x=y，则x，z比较结果和y，z比较结果相同。

   反例：下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { return o1.getId() > o2.getId() ? 1 : -1; } };

9. 【推荐】集合初始化时，指定集合初始值大小。

   说明：HashMap使用HashMap(int initialCapacity) 初始化，

   正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意 负载因子（即loader factor）默认为 0.75，如果 暂时无法 确定 初始值大小，请设置为 16（即默认值）。

   反例： HashMap需要放置1024个元素， 由于没有设置容量初始大小，随着元素不断增加容 量 7次被迫扩大， resize需要重建 hash表，严重影响性能。 表，严重影响性能。

10. 【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。

    说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。

    正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。

11. 【推荐】高度注意Map类集合K/V能不能存储null值的情况，

    如下表格：

    | 集合类            | Key          | Value        | Super       | 说明                   |
    | ----------------- | ------------ | ------------ | ----------- | ---------------------- |
    | Hashtable         | 不允许为null | 不允许为null | Dictionary  | 线程安全               |
    | ConcurrentHashMap | 不允许为null | 不允许为null | AbstractMap | 锁分段技术（JDK8:CAS） |
    | TreeMap           | 不允许为null | 允许为null   | AbstractMap | 线程不安全             |
    | HashMap           | 允许为null   | 允许为null   | AbstractMap | 线程不安全             |

    反例： 由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储null值时会抛出NPE异常。

12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。

    说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。

13. 【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。

(六) 并发处理

1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。

   说明：资源驱动类、工具类、单例工厂类都需要注意。

2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。

   正例： public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName("TimerTaskThread"); ... }

3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

   说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

4. 【强制】线程池不允许使用 【强制】线程池不允许使用 Executors去创建，而是通过ThreadPoolExecutor的方式，这样的方式，这样的处理方式让写同学更加明确线程池运行规则，避资源耗尽风险。

   说明： Executors返回的线程池对象 返回的线程池对象 的弊端 如下 ：

   1）FixedThreadPool和 SingleThreadPool:

   允许的请求队列长度为 Integer.MAX_VALUE，可 能会堆积大量的请求，从而导致 OOM。

   2）CachedThreadPool和 ScheduledThreadPool :

   允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。

5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。

   正例：注意线程安全，使用DateUtils。亦推荐如下处理： private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() { @Override protected DateFormat initialValue() { return new SimpleDateFormat("yyyy-MM-dd"); } }; 说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。

6. 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。

   说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。

7. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。

   说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。

8. 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。 说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。

9. 【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。

10. 【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。

    说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。

11. 【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。 说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。

    正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例。

12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。

    反例： class Singleton { private Helper helper = null; public Helper getHelper() { if (helper == null) synchronized(this) { if (helper == null) helper = new Helper(); } return helper; } // other methods and fields... }

13. 【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。

14. 【参考】 HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。

15. 【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。

(七) 控制语句

1. 【强制】在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。

2. 【强制】在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements;

3. 【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成： if (condition) { ... return obj; } // 接着写else的业务逻辑代码; 说明：如果非得使用if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。 正例：超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下： public void today() { if (isBusy()) { System.out.println(“change time.”); return; } if (isFree()) { System.out.println(“go to travel.”); return; } System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return; }

4. 【推荐】除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。

   说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 正例： // 伪代码如下 final boolean existed = (file.open(fileName, "w") != null) && (...) || (...); if (existed) { ... } 反例： if ((file.open(fileName, "w") != null) && (...) || (...)) { ... }

5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。

6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。

7. 【参考】下列情形，需要进行参数校验：

   1） 调用频次低的方法。

   2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。

   3） 需要极高稳定性和可用性的方法。

   4） 对外提供的开放接口，不管是RPC/API/HTTP接口。 5） 敏感权限入口。

8. 【参考】下列情形，不需要进行参数校验：

   1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。

   2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。

   3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。

(八) 注释规约

1. 【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用// xxx方式。

   说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。

2. 【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。

   说明：对子类的实现要求，或者调用注意事项，请一并说明。

3. 【强制】所有的类都必须添加创建者和创建日期。

4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。

5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。

6. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。

   反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。

7. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。

   说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。

8. 【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。

   说明：代码被注释掉有两种可能性：

   1）后续会恢复此段代码逻辑。

   2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。

9. 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。

10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。

    反例： // put elephant into fridge put(elephant, fridge); 方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。

11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。

    1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。

    2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。

(九) 其它

1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。

   说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);

2. 【强制】velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法。

   说明：注意如果是Boolean包装类对象，优先调用getXxx()的方法。

3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。

   说明：如果var=null或者不存在，那么${var}会直接显示在页面上。

4. 【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。

5. 【强制】获取当前毫秒数System.currentTimeMillis(); 而不是new Date().getTime();

   说明：如果想获取更加精确的纳秒级时间值，使用System.nanoTime()的方式。在JDK8中，针对统计时间等场景，推荐使用Instant类。

6. 【推荐】不要在视图模板中加入任何复杂的逻辑。 说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。

7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。

8. 【推荐】及时清理不再使用的代码段或配置信息。 说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。 正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。

二、异常日志

(一) 异常处理

1. 【强制】Java 类库中定义的一类RuntimeException可以通过预先检查进行规避，而不应该通过catch 来处理，比如：IndexOutOfBoundsException，NullPointerException等等。 说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过catch NumberFormatException来实现。

   正例：if (obj != null) {...}

   反例：try { obj.method() } catch (NullPointerException e) {...}

2. 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。

3. 【强制】对大段代码进行try-catch，这是不负责任的表现。catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。

4. 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

5. 【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。

6. 【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。

   说明：如果JDK7及以上，可以使用try-with-resources方式。

7. 【强制】不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。

8. 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。

   说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。

9. 【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。调用方需要进行null判断防止NPE问题。

   说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。

10. 【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：

    1）返回类型为基本数据， 返回类型为基本数据， 返回类型为基本数据， 返回类型为基本数据， returnreturn returnreturn包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 包装数据类型的对象时，自动拆箱有可能产生 NPE 。

    反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。

    3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。

    4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。

    5） 对于Session中获取的数据，建议NPE检查，避免空指针。

    6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。 正例：使用JDK8的Optional类来防止NPE问题。

11. 【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。

12. 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由：

    1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。

13. 【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。

    说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。

    正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto) {...}

(二) 日志规约

1. 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class);

2. 【强制】日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。

3. 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 正例：mppserver应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。

4. 【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。

   说明：logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 正例：（条件） if (logger.isDebugEnabled()) { logger.debug("Processing trade with id: " + id + " and symbol: " + symbol); } 正例：（占位符） logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);

5. 【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。

   正例：<logger name="com.taobao.dubbo.config" additivity="false">

6. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。

   正例：logger.error(各类参数或者对象toString + "_" + e.getMessage(), e);

7. 【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。

   说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？

8. 【参考】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出error级别。

三、单元测试

1. 【强制】好的单元测试必须遵守AIR原则。

   说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。

   A：Automatic AutomaticAutomatic Automatic Automatic （自动化） （自动化） .

   I：Independent IndependentIndependent Independent Independent Independent （独立性） （独立性） .

   R：Repeatable RepeatableRepeatable Repeatable Repeatable Repeatable（可重复） （可重复）

2. 【强制】单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。

3. 【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。

   反例：method2需要依赖method1的执行，将执行结果做为method2的输入。

4. 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。

   说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。

   正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。

5. 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。

   说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。

6. 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。

   说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。

7. 【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。

   说明：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。

8. 【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%

   说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。

9. 【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。

   B：Border，边界值测试，包括循环、特殊取时间点数据顺序等。 ，边界值测试包括循环、特殊取时间点数据顺序等。

   C：Correct，正确的输入，并得到预期结果。 ，正确的输入并得到预期结果。

   D：Design，与设计文档相结合，来编写单元测试。 ，与设计文档相结合来编写单元测试。

   E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。

10. 【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。

    反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。

11. 【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。

    正例：在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。

12. 【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。

13. 【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。

14. 【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。

15. 【参考】为了更方便地进行单元测试，业务代码应避免以下情况：

    构造方法中做的事情过多。

    存在过多的全局 变量 和静态方法。

    存在过多的外部依赖。

    存在过多的条件语句。

    说明： 多层条件语句建议使用卫、策略模式状态等方重构。

16. 【参考】不要对单元测试存在如下误解：

    那是测试同学干的事情。本文开发 手册 ，凡是本文内容都与开发同学强相关的。

    单元测试代码是多余的。 汽车的整体功能 与各单元部件的测试正常否是强 相关的。

    单元测试代码不需要维护。 一年半载后，那么几乎处于废弃状态

    单元测试与线上故障没有辩证关系。好的单元测试能够最大限度的规避线上故障

四、安全规约

1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。

   说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。

2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。

   说明：查看个人手机号码会显示成:1589119，隐藏中间4位，防止隐私泄露。

3. 【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。

4. 【强制】用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致：  page size过大导致内存溢出  恶意order by导致数据库慢查询  任意重定向  SQL注入  反序列化注入  正则输入源串拒绝服务ReDoS

   说明： Java JavaJava代码用 代码用 正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的 结果。

5. 【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。

6. 【强制】表单、AJAX提交必须执行CSRF安全过滤。

   说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。

7. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。

8. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。

五、MySQL数据库

(一) 建表规约

1. 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否）。

   说明：任何字段如果为非负数，必须是unsigned。

   正例： 表达逻辑删除的字段名 is_deleted，1表示删除， 0表示未删除。 表示未删除。

2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

   说明： MySQL 在 Windows下不区分大小写，但在 Linux下默认是区分大小写。因此，数据库名、表字段，都不允许出现任何大写母避免节外生枝。

   正例：aliyun_admin，rdc_config，level3_name

   反例：AliyunAdmin，rdcConfig，level_3_name

3. 【强制】表名不使用复数名词。

   说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。

4. 【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。

5. 【强制】主键索引名为pk*字段名；唯一索引名为uk*字段名；普通索引名则为idx_字段名。 _

   说明：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。

6. 【强制】小数类型为decimal，禁止使用float和double。

   说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。

7. 【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。

8. 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。

9. 【强制】表必备三字段：id, gmt_create, gmt_modified。

   说明： 其中 id必为 主键，类型必为 主键，类型unsigned bigint、单表时自增步长为 、单表时自增步长为 1。gmt_create, gmt_modified的类型均为 的类型均为 date_time类型，前者现在时表示主动创建后过去分词被 类型，前者现在时表示主动创建后过去分词被 类型，前者现在时表示主动创建后过去分词被 动更新。

10. 【推荐】表的命名最好是加上“业务名称_表的作用”。

    正例：alipay_task / force_project / trade_config

11. 【推荐】库名与应用名称尽量一致。

12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。

13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：

    1）不是频繁修改的字段。

    2）不是varchar超长字段，更不能是text字段。

    正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。

14. 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。

    说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。

正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。

| 对象     | 年龄区间  | 类型              | 字节 | 表示范围                  |
| -------- | --------- | ----------------- | ---- | ------------------------- |
| 人       | 150岁之内 | unsigned tinyint  | 1    | 无符号值：0到255          |
| 龟       | 数百岁    | unsigned smallint | 2    | 无符号值：0到65535        |
| 恐龙化石 | 数千万年  | unsigned int      | 4    | 无符号值：0到约42.9亿     |
| 太阳     | 约50亿年  | unsigned bigint   | 8    | 无符号值：0到约10的19次方 |

(二) 索引规约

1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

   说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

2. 【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。

   说明：即使双表join也要注意表索引、SQL性能。

3. 【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。

   说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

   说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

5. 【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。

   正例：where a=? and b=? order by c; 索引：a_b_c

   反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b无法排序。

6. 【推荐】利用覆盖索引来进行查询操作，避免回表。

   说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。

   正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用explain的结果，extra列会出现：using index。

7. 【推荐】利用延迟关联或者子查询优化超多分页场景。

   说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。

   正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

8. 【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。

   说明：

   1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。

   2）ref 指的是使用普通的索引（normal index）。

   3）range 对索引进行范围检索。

   反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。

9. 【推荐】建组合索引的时候，区分度最高的在最左边。

   正例：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。

   说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。

10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。

11. 【参考】创建索引时避免有如下极端误解：

    1）宁滥勿缺。认为一个查询就需要建一个索引。

    2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。

    3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

(三) SQL语句

1. 【强制】不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。

   说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。

2. 【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。

3. 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。

   正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;

4. 【强制】使用ISNULL()来判断是否为NULL值。

   说明：NULL与任何值的直接比较都为NULL。 1） NULL<>NULL的返回结果是NULL，而不是false。 2） NULL=NULL的返回结果是NULL，而不是true。 3） NULL<>1的返回结果是NULL，而不是true。

5. 【强制】 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。

6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

   说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。

7. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

8. 【强制】数据订正时，删除和修改记录时，要先select，避免出现误删除，确认无误才能执行更新语句。

9. 【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。

10. 【参考】如果有全球化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。

    说明： SELECT LENGTH("轻松工作")； 返回为12 SELECT CHARACTER_LENGTH("轻松工作")； 返回为4 如果需要存储表情，那么选择utfmb4来进行存储，注意它与utf-8编码的区别。

11. 【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。

    说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。

(四) ORM映射

1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。

   说明：

   1）增加查询分析器解析成本。

   2）增减字段容易与resultMap配置不一致。

2. 【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。

   说明：参见定义POJO类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。

3. 【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。

   说明：配置映射关系，使字段与DO类解耦，方便维护。

4. 【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。

5. 【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。

   说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。 正例：Map<String, Object> map = new HashMap<String, Object>(); map.put("start", start); map.put("size", size);

6. 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。

   说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。

7. 【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。

8. 【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。

9. 【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。

10. 【参考】<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值时执行。

六、工程结构

(一) 应用分层

1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推： 开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。 终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。 Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 Service层：相对具体的业务逻辑服务层。 Manager层：通用业务处理层，它有如下特征：

   1） 对第三方平台封装的层，预处理返回结果及转化异常信息；

   2） 对Service层通用能力的下沉，如缓存方案、中间件通用处理；

   3） 与DAO层交互，对多个DAO的组合复用。 DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。 外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。

2. 【参考】 （分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。

3. 【参考】分层领域模型规约： DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。 DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。 BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。 AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。 VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。 Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。

(二) 二方库依赖

1. 【强制】定义GAV遵从以下规则：

   1） GroupID格式：com.{公司/BU }.业务线.[子业务线]，最多4级。 说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress等BU一级；子业务线可选。 正例：com.taobao.jstorm 或 com.alibaba.dubbo.register

   2） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。

   正例：dubbo-client / fastjson-api / jstorm-tool

   3） Version：详细规定参考下方。

2. 【强制】二方库版本号命名方式：主版本号.次版本号.修订号

   1） 主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。

   2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。

   3） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。 说明： 注意起始版本号 必须 为： 1.0.0，而不是 ，而不是 ，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0

3. 【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）。

   说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。

4. 【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree命令，找出差异点，进行<excludes>排除jar包。

5. 【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。

6. 【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。

   说明：依赖springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。

7. 【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。

   说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。

8. 【推荐】所有pom文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencyManagement>语句块中。

   说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<dependencies>所有声明在主pom的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。

9. 【推荐】二方库不要有配置项，最低限度不要再增加配置项。

10. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：

    1）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。

    2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。

(三) 服务器

1. 【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。 说明：操作系统默认240秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。

   正例：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30

2. 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。

   说明：主流操作系统的设计是将TCP/UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为1024，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。

3. 【推荐】给JVM设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。

   说明：OOM的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。

4. 【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力。

5. 【参考】服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险。

补充

1、继承自父类或者是实现接口的方法，必须加@Override注解。

2、所有的POJO必须实现toString()方法。

3、如果POJO需要实现equals()方法，在用eclipse自动生成的时候，必须让if后面跟上括号。

4、所有的注释必须写完整、清晰而且详细。

5、所有的@Transactional注解必须加上rollbackFor参数，指定哪些异常发生的时候回滚事务。

6、所有的类命名必须按照驼峰形式来，尤其是DAO单元测试类，必须是类似于XxxDaoTest的格式。

7、所有集合初始化的时候，都必须给一个初始值，可以用常量类定义一个默认的集合初始值是100。

8、所有代码不能出现任何一个magic number，必须对数字、字符串等值进行变量或者是常量的定义。

9、if判断中的表达式不能过于复杂，将复杂的表达式复制给一个boolean变量。

10、获取当前时间不允许用new Date().getTime()，用System.currentMillis()。

## 系统测试规范

### 1.单元测试规范

针对的是代码中的每个类，一个类认为是一个代码组件，对每个代码组件都编写一个单元测试类。这个单元测试类中会有多个方法，通常至少对要测试的类中的每个方法都编写一个对应的测试方法。

单元测试，面向的是代码组件的级别，它是最小最细粒度的测试单元。

通常而言，通过单元测试检查出来的bug是最多的，所以它是位于测试金字塔模型的最底端。

单元测试，需要每个RD对自己编写的代码自己去写单元测试，一般是使用JUnit框架，如果你使用了一些其他的框架，Spring，Spring MVC，都有对应的跟JUnit整合起来进行单元测试的一些框架，逻辑判断的Hamcrest框架，mock对象的Mockito框架。

初步的一些规范：

（1）单元测试类，必须以test来结尾，以要测试的类来打头。

（2）针对每个类，一般都要写一个单元测试类来进行测试。

（3）单元测试中的每个方法，针对的是被测试类中的每个方法，方法以test打头，跟上要测试的方法名称。

重要的原则：单元测试中，你测试一个类，就只能针对这一个类中的代码来进行测试。如果这个类依赖了其他的类，必须用测试替身将依赖的类和要测试的类隔离开来。为什么呢？记住，单元测试是什么，单元测试其实是最小的测试单位，一个单元测试类就负责测试一个代码组件（一个类），如果这个类依赖了其他的类。那么你就自己模拟一些测试替身，注入到要测试的类中去，将要测试的类和依赖的类隔离开来。

避免说，要测试的类和依赖的类耦合在一起测试，互相如果有bug会互相影响。

重要原则：单元测试绝对不能依赖任何的外部基础设施，比如说mysql、redis、rabbitmq，绝对不能依赖这些东西来写单元测试。如果要依赖的话，直接注入测试替身，用模拟的行为来替代掉。

重要规范：单元测试覆盖率，要保证你写的单元测试覆盖了足够多的代码，保证覆盖的代码至少达到70%，对核心模块的代码要覆盖100%。

一个好的单元测试要符合的一个规范和规则。

- 什么是单元测试？
  - 直接裸奔不写单元测试的弊端
    - 如果裸奔不写单元测试的话，就直接意味着，这个RD根本就没有对自己编写的代码负责
    - 最基本的单元测试都没有，凭什么让人相信你的代码是经过测试的呢？
  - 写更多的单元测试对代码质量提高的稳定曲线
  - 写更多的单元测试对代码设计质量提高的稳定曲线
- 优秀的单元测试有哪些特质？
  - 可读性
  - 良好的测试代码结构
  - 精准的测试名称
  - 测试代码的可重复性
  - 自动化单元测试的3大工具
    - 测试框架：JUnit来测试，加上其他一些辅助性质的测试框架
    - 运行单元测试的自动化构建：基于maven的插件，mvn test，自动把所有的单元测试都自动化跑一遍
    - 测试替身：主要使用的是Mockito框架，模拟出来各种各样实现某个接口的类，每个方法的模拟的行为是什么

- 测试替身

  - 测试替身的几大作用
    - 隔离要测试的代码组件：将测试替身对象传入要测试的组件
    - 加快测试执行速度：替换复杂耗时的代码执行
      - 有的时候会有这样的一种情况，比如你要测试的是类A，类A依赖了类B，类B中的代码非常复杂，执行了大量的数据库读写操作
      - 导致类B的那个方法跑起来是很慢的
      - 就是用测试替身代替类B，将类B中的方法实现为非常简单的一些打印日志的模拟的实现就可以了，因为我们重点要测试的是类A，不是类B
      - 测试替身的一个效果，就是可以加速类A中的方法的执行速度，也就可以加快我们的单元测试运行的速度
    - 让代码行为变得足够稳定：将随机行为改为固定行为
      - 类A依赖了类B，类B中会随机生成一个随机数，根据随机数来执行一些行为
      - 这就会导致类A每次调用类B，执行的结果是随机的，不够稳定
      - 用测试替身替代掉类B，每次调用就是返回一个固定的值，就可以了，让代码行为变得足够稳定
      - 就能保证我们的单元测试每次都是稳定运行的
    - 模拟特殊的异常情况：主动抛出网络调用异常
      - 类A依赖了类B，现在需要测试的是，如果类B的方法抛出了异常，类A捕捉到异常之后，能否正常执行类A中的catch中的代码逻辑
      - 此时可以用测试替身替代掉类B，让类B中的方法就固定抛出一个异常
    - 访问私有数据：测试后获取依赖组件的内部私有数据来断言
      - 类A依赖了类B，现在测试是要看那一下，类A调用了类B之后，类B中的部分变量是否改变为了我们期望的一个值
      - 此时就可以用测试替身来替代掉这个类B，在里面增加捕获变量改变历史的一些数据
      - 最后测试完了以后，我们就可以看一下是否符合期望
  - 测试替身的几种类型
    - 测试桩：stub
      - 最简单的测试替身
      - 一般就是用一两行代码模拟行为
      - 比如日志记录组件，可以用测试桩来替代
    - 伪造对象：fake
      - 相对复杂一些的情况，需要使用伪造对象来模拟真实场景
      - 比如DAO组件可以用fake对象
      - 使用内存数据库来实现数据的增删改查
    - 测试间谍：spy
      - 要检查依赖组件的行为，是无法直接断言的，需要使用spy
      - 将依赖组件做成spy，对方法调用可以保存数据
      - 对测试组件执行完之后，对spy保存的数据进行断言
    - 模拟对象：mock
      - mock对象，指定某个参数传入时返回什么结果
      - 使用mock对象可以模拟任意复杂度的依赖代码组件
  - 测试替身的使用规则
    - 如何选择测试替身
      - 操作行为用mock对象
      - 查询行为用stub对象
      - 复杂的一套业务逻辑用fake对象
      - 无法断言返回结果用spy对象
    - 单元测试编写范式：准备、执行、断言
    - 测试框架：JUnit+Mockito+Hamcrest
      - 单元测试主要用JUnit
      - 用Mockito来模拟4种测试替身
      - 用Hamcrest来配合assertThat断言

- 单元测试的反面教材

  - 可读性较差

    - 基本断言：断言时用了算数运算符，让人看不懂
      - assertTrue(a > 100)
      - assertThat(a, greaterThan(100))，Hamcrest框架
    - 过度断言：对大量的代码逻辑的执行结果进行一次断言，出问题不好排查
      - 一次性对多个方法进行了测试和断言
      - 要将对多个方法的测试拆分到不同的测试方法中，尽量降低测试的粒度
    - 位断言：断言时使用了按位与等特殊操作符号，让人看不懂
      - 在写单元测试的时候，不要使用位运算符，比如说<<，>>
    - 人格分裂：将较为复杂的多个不同类别的逻辑放在一个测试类里
      - 在一个测试类中，对多个不同的类，或者一个类中多种不同的负责逻辑进行测试
      - 可以尝试将过于复杂的测试逻辑拆分到不同的测试类中去
    - 逻辑分割：测试代码依赖了外部文件中的内容，很难查看
      - 测试代码里面，使用了外部的一个文件，比如说a.txt，或者b.csv
      - 尽量用内嵌在代码中的文本去替代外部的文件
      - 保证说所有的内容都在单元测试中
    - 魔法数字：断言时用了magic number，让人看不懂
      - assertTrue(a > 100)，100，magic number
      - assertThat(productPrice, greaterThan(price(100)))
    - 冗长安装：setup方法中代码过于冗长，不拆分一下让人不好看懂
      - @Before的setup方法中，将过于复杂的逻辑拆分到不同的私有方法中去执行
    - 过分保护：一个测试方法中有多个断言，有过分保护之嫌
      - 太过于谨慎了，一个测试方法中，多个断言，对同一个结果，不同角度反复断言

  - 可维护性较差

    - 重复：数字、字符串和类似代码逻辑多次重复，需要抽取
      - 对于测试代码中一些重复性的数字、字符串，抽取出来，抽取成一个独立的变量，不要有太多重复的东西
    - 条件逻辑：不要在测试代码中加多个if else逻辑判断

    - 脆弱的测试：随机性的逻辑导致测试经常运行失败，不够稳定
    - 文件路径：使用绝对路径导致在别人那里测试运行失败
    - 沉睡的蜗牛：使用Thread.sleep来控制多线程，导致运行缓慢和随机性
    - 像素完美：对图像类测试代码，使用了过多像素数字
    - 参数化混乱：过多使用参数化测试技术，导致测试代码不易于调试
    - 方法见缺乏内聚：一个类中混杂太多的测试方法和测试类实例

  - 可信赖程度较差

    - 注释掉的测试：不要注释测试，而是直接删除掉
    - 歧义注释：有些注释有歧义，误导人理解，需要重写注释
    - 永不失败的测试：检查抛出异常的测试，却永远接收不到异常
    - 轻率承诺：测试代码被注释，没有写断言，都是无意义的测试代码
    - 降低期望：对代码执行的结果要求很低，轻易就通过测试
    - 平台偏见：不同平台的测试需要划分到不同的类中，对windows平台的测试用一个类，对unix平台的测试用一个类
    - 有条件的测试：如果依赖条件来进行测试，那么可能会有问题，不要出现if else

- 可测试的设计

  - 什么是可测试的设计？
    - 模块化设计
    - SOLID原则
    - 上下文中的模块化设计
    - 以测试驱动出模块化设计
  - 无法测试的问题
    - 无法实例化某个类
    - 无法调用某个方法
    - 无法观察到输出
    - 无法替换某个协作者
    - 无法覆盖某个方法
  - 可测试设计的指南
    - 避免复杂的私有方法
    - 避免final方法
    - 避免static方法
    - 谨慎使用new创建对象：如果你这里用了new来创建对象，会导致我们没法注入测试替身
    - 避免在构造函数中包含复杂逻辑
    - 避免使用单例模式
    - 使用组合优先于使用继承
    - 将外部组件封装在自己的组件中
    - 避免远程服务查找和调用

你开发好你所有的功能代码之后，运行完所有的单元测试之后，跑出来一份单元测试覆盖率的报告，这份报告的话呢，需要保留好，因为在后面，会有一个审查的环节。

### 2.冒烟测试规范

冒烟测试，大概的意思是这样子的，名字是从哪儿来的呢？以前国外有程序员，传闻说是从微软那边程序员传出来的。

以前如果就是光写单元测试的话，其实可能还是会有不少的bug。

然后程序员就会很懒，他们会觉得说，我们就不用化很多的时间去测试代码了，直接甩给QA去测，他们测出来了，我们再修改就可以了。

后来QA很火冒三丈，BAT都有这样的情况，QA觉得你提测的时候，怎么bug这么多啊，很多都是初级的bug，你当时如果自己好好测一下不就得了，到我这里来就没那么多的bug了。更加重要的一点是什么呢？之前有人做过统计，每一个测试环节，如果你的一个bug越往后发现和修复，耗费的成本可能是上一个环节发现和修复的成本的10倍。比如在单元测试环节，就发现有一个bug，就修复了，这算是美金是10美金；如果到集成测试环节，再发现一个bug，可能要话费的是100美金的成本；如果到系统测试的环节，再发现一个bug，可能要花费的成本是1000美金的成本。。

那么现在比较流行的是说，在提交给QA的集成测试之前，RD必须在自己本地，跑起来，基础设施全部连通开发环境中的mysql、redis、mq，自己负责的代码跑起来，对各个接口，自己测一测，如果觉得都能跑通，逻辑正确，那么测试通过。

这个，其实就是花不了多少时间，这个就不是说一个类一个类的测试了，可能你总共就20个接口，对应了200个类。对200个类，要写200个单元测试。对20个接口，一行代码不用写，系统跑起来，自己模拟一下http或者rpc的请求，构造一些参数，看一下返回结果，就可以了。

这可能就花费抽一根烟的时间，所以有人传闻，冒烟测试，可能就是从这儿来的。

冒烟测试，就是负责开发的RD，自己简单的去进行一下测试，确保自己写的代码大问题没有。

在进行详细设计的时候，就需要设计好自己要执行的冒烟测试的测试用例。

（1）测试名称

（2）测试接口

（3）输入

（4）输出

你执行了冒烟测试过后，要记录下来一份冒烟测试报告，这里面就写清楚，你执行了哪些冒烟测试用例，输入是什么，输出是什么，每个冒烟测试的结果是否通过。

### 3.静态代码扫描

静态代码扫描，主要是看一下代码写的是否足够规范，如果靠人肉去看代码写的是否足够规范的话，耗费时间太多，不太靠谱，可能会有遗漏。

针对我们的编码规范，用了阿里的java开发规范，用阿里配套的代码扫描的插件，去扫描一下代码，看一下，是否都是符合规范的，如果扫描结果提醒，有不符合规范的地方，需要你将对应的不规范的代码重构一下，直到代码全部符合规范。

然后最终通过扫描的扫描报告，需要留存一份，后面会有人来审查。

要求必须在自己的IDE（Eclipse或者是Intellij IDEA）安装阿里编码规范的插件，然后必须是用这个插件来扫描你的代码。扫描之后有3个级别的问题：

1、Blocker：这个是最严重的问题，要求是必须修复，不允许带着Blocker问题的代码上线，否则就是直接跟绩效挂钩

2、Critical：是比较严重的问题，要求是必须修复，不允许带着Critical问题的代码上线，跟绩效挂钩

3、Major：问题，可以不修复，也可以修复。主要是看项目的排期和进度，如果说进度不是特别紧张的话，建议全部修复。如果说项目进度很紧张的话，Major问题可以先放着，下次有时间了再修复。

### 4.代码审查规范

code review，代码审查，代码走读。

到这里为止，你的team里的一个同学，就已经把他要干的活儿全部都干完了。

此时，他就应该push自己本地的代码到gitlab上去，然后在gitlab上对他自己的feature分支，提交一个Pull Request到develop分支上去。

Pull Request的reviewer就是你，架构师本人，也可以是团队内其他的高工，如果你作为一个架构师，带了十几个人，二十人的团队，你手下有三四个高工，每个高工带了一个小团队，那么其实一般就是让高工负责去审查他们的代码就可以了，你负责审查高工的代码。

Pull Request里面，是可以写备注的 ，这个备注的规范如下：

（1）标题：用一行文字，简短的概括说明，你本次开发好了哪些东西

（2）列表

1.完成了订单系统的开发

（1）包括XX模块

（2）包括XX模块

2.完成了调度系统的开发

（1）包括XX模块

（2）包括XX模块

单元测试报告：可以通过邮件去发送，然后在这里可以备注好，通过哪份邮件，已经发送过去了，对方可以查看。

冒烟测试报告：邮件。

静态代码扫描报告：邮件 。

接收到这个Pull Request的同学，就需要对他的代码去进行审查了。

code review，要看哪些东西，众说纷纭，可以写的很详细，也可以写的很粗糙。

这一块，基本上要定一个特别细的规范，很难的，负责review的那个人，自己时间很紧张，可能一般都没有太多的时间去给你看代码。

所以你务必要确保说，在短时间内，这个负责审查代码的人，可以确保说，这个代码是ok的。

我根据经验梳理出来一些，看别人的代码，重点要看什么：

（1）看懂别人的代码：基本上都按照编码规范，命名都很清晰，面向对象的划分都很清晰，注释很清晰，逻辑交互很清晰。如果说你觉得能看懂这个人的代码，而且代码设计的很优雅，未来的可扩展性很高，那么就可以。但是如果你发现有些地方的命名，或者是代码注释，不够清晰，导致你不好理解，看不懂，而已给建议。这块是在把控代码的质量。第一点，就是让人能看懂。 => 代码质量

（2）仔细审查一下业务逻辑是否准确，对照着详细设计文档来看，你作为一个小leader，你要负责确保说，你手下写出来的代码，是按照详细设计文档里的设计在写的，整个业务流程和业务逻辑都是准确的。看一下这个逻辑，是否有可能会在某些特殊情况下出现bug，也是根据你的经验和能力来的，你的经验和能力越强，这一步能看出来的问题就越多。 => bug

（3）看一看代码编写的细节有没有什么问题：这个，就根据你的经验来判断，比如说，你发现某一段代码，在for循环内部出现了每次循环都创建一个对象的，备注一下，建议将循环内创建对象的逻辑抽到循环外面来执行。我可以给出来很多很多的建议和细则，大家很难去执行的，还有很多，根据你自己的技术能力和技术经验来了，你的技术越强，经验越丰富，往往在这个环节，你可以提出很多的问题。io读取文件，你会建议说，是否可以重构为nio的方式。 => 对代码设计和技术实现的质量

（4）单元测试，初步浏览一遍，看看单元测试代码写的是否ok，如果出现一些不太规范不太好的地方，给一些建议，让单元测试代码重构一下。看一下单元测试覆盖率的报告，确保说，70%的覆盖率，核心包下的代码覆盖率是100%。。

（5）冒烟测试，仔细看一遍，确保说，他设计的那些冒烟测试用例都执行了，这个就代表着说他做了这个事情。

（6）静态代码扫描的报告，这个就是确保说，都是符合编码规范的，代码是规范的

有了规范，必须确保可以落地，可以执行，唯一能够依靠的就是check。

在code review这个环节，就可以去check之前的所有流程，单元测试覆盖率是否达标，冒烟测试是否全部通过，静态代码扫描是否全部通过。

每个人提交Pull Request给其他同事，或者是leader，来review这个代码，leader review代码的时候，主要看4样东西：

1、他会去看每个人的每一行代码，3个目的

作为一个leader，或者是团队里其他的高工，你有责任和义务去仔细看其他人的代码，如果出问题，你作为leader或者高工有责任去帮低级别的人解决问题。

code review，就是一个完美的时机，你作为一个leader或者高工，去仔细看手下写好的代码，你这样才可以把控全局，控制所有的东西。别让自己掉队。万一你手下小弟刚写好代码，外面拿到个offer，薪资暴涨50%，人跑了。

code review，你或者其他高工看懂别人的代码，就代表你成为了那个人的一个backup。如果那个人跑了，你可以直接顶上去。

1）帮低级别的人解决问题

2）backup

3）掌控系统的全局，每一块代码大概是怎么写的，心里有数

2、你作为一个检查机制，检查在code review之前的规范，有没有执行

别人给你给你提交PR的时候，你必须得让他同步提交三样东西：

1）静态代码扫描的结果：blocker和critical级别的问题是否都解决了，major问题遗留了多少个

2）单元测试覆盖率的报告：你去检查他负责的那几个模块，单元测试的覆盖率是否达标

3）冒烟测试报告：他对他负责的模块的核心流程都进行了冒烟测试，确保他负责的模块的核心流程都可以跑通

你要作为一个leader，去检查他都做了这几件事情

3、以你的技术能力和经验，去发别人代码中的不合理之处，指导低级别的工程师去修缮和完善自己的代码。

以你的角度，和你当前的技术经验，技术的能力，对技术的掌握和把控，站在你的角度来审视别人的代码，如果你发现这哥儿们代码有些的烂的地方，你就给他提出code review的一些建议。

代码一旦修改，同步的单元测试和冒烟测试，自己全部对应的做一下调整

静态代码扫描、单元测试覆盖率报告，全部重新做一遍

Pull Request再次提交到高工的手中，你再看一下当时让他修改的那些代码，发现，很好

### 5.集成测试规范

集成测试。

互联网行业里，集成测试，都是RD自己做的，不是QA介入的。联调测试，每个人的部分要集成到一起，联通外部的所有基础设施，让整套系统跑起来，对系统的核心流程，以及核心的功能，都去进行测试，验证。确保整套系统是可以跑通的。我们一般会称之为，小黑屋阶段。因为涉及到多个人的联调，集成，测试。所以一般在这个环节，我们一般都会提前订好几个的会议室，每天上班第一件事情，就是大家一起去小黑屋里去测试，有一个人负责去执行系统的所有核心流程，QA，PM。发现有问题，大家就根据日志去排查问题，现场排查，现场直接修复。

跟传统IT行业，不一定完全一样。

集成测试通过之后，就是要确保系统的所有核心主流程全部跑通。

集成测试的测试用例，是QA去设计的，QA在这里去执行集成测试的用例，我们RD主要负责配合排查bug和修复bug。

每次集成测试过程中，需要有一个人记录下来，本次集成测试的报告，里面记录好，对哪些集成测试用例进行了执行，测试的结果是什么

### 6.系统测试规范

系统测试

这一步不用说了，一定是QA去做的。

QA提前设计好对应的所有的系统测试的用例，这个用例一般都是很详细，很复杂的，涵盖了各种细节，各种异常和特殊的情况。

就是直接将整套系统部署到test环境，联通test环境整套基础设施，然后由QA去测试。

引入一个东西，叫做缺陷管理。

就不是走小黑屋的模式了，RD自己在那儿瞎测，大家都通过了集成测试了，都对自己的系统和代码比较有信心了，直接部署好在test环境，我们就坐等QA反馈bug。

QA，如果在比较原始的其情况下，基于word文档来记录缺陷bug，来反馈。

现在其实有一些很好的产品，项目全生命周期的管理，包括了bug缺陷的反馈。但是我们在第一个阶段，尽量用比较原始的方式来做，因为让你了解原始的方式，怎么把整套东西给跑通了。到了阶段二，我们就会去用一些专门项目管理软件，缺陷管理软件。

QA，发现一个bug，就会记录下来，这个bug的发生时间，bug标题，具体描述，截图。

一轮一轮的来测试。

第一轮测试之后，就统一一个word文档，发给各个RD，每个RD去排查和修复自己负责的那个bug。大家全部都修复好之后，再次提测。

QA再次进行第二轮测试，word文档。以此类推，三轮，四轮，三轮左右，就可以搞定了。QA觉得一个bug都没有了。

负责测试的QA有责任产出一份测试报告，就是说明他做了哪些测试用例，每个测试用例的执行结果是什么，一共是几轮，第一轮测出了多少个bug，第二轮是多少个bug。

### 7.验收测试规范

验收测试

QA全部测试完之后，理想情况下，那么此时bug数为0，系统就完全达到可以上线的状态了。

但是此时还是需要将系统在验收环境，staging环境去部署一下，然后让PM来验收，PM会自己设计很多的验收测试用例，执行自己设计的那些验收测试用例。确保说系统的所有核心功能全部可以跑通。

此时系统就完全达到了可以上线的状态。

负责验收系统的人，比如这个PM，有责任记录一份验收测试的报告，记录下来自己做了哪些测试，执行了哪些测试用例，每个测试用例的执行结果是什么。

## 系统上线规范

### 1.系统上线规范 一、上线checklist

每个在本次要上线的版本中负责开发的同学，都需要提交自己的上线checklist，最终合并到同一份上线checklist文档中去。上线checklist文档，就是在里面要写清楚每个人负责的那个部分，那个子系统的整个软件工程流程过程中，沉淀下来的所有文档，都需要附加在这份checklist文档中，一般比如说可以用一个word文档，在这个word文档中，附加上你每个过程对应的一个截图和报告。

1、各系统的测试报告

1.1 XX子系统的测试报告

（1）单元测试报告：确认你的单元测试覆盖率是否达标

（2）冒烟测试报告：确认你的冒烟测试全部通过

（3）静态代码扫描报告：确认你的代码完全符合开发规范

（4）代码审查结果：就是在Gitlab中，你提交的PR最终会被人通过和merge，负责审核你的代码的人，他需要在审核之后，给出你一份总评，就是说，审核了你哪些哪些地方，然后最终判定通过，给一个截图。确认你的代码是经过审查的

1.2 XX子系统的测试报告

2、系统整体的测试报告

2.1 集成测试报告

2.2 系统测试报告

2.3 验收测试报告

这份文档，可以由架构师指派一个人去收集所有人沉淀下来的过程文档。一个大的需求版本上线，必须由这个系统的总架构师，亲自在上线前去审核这份文档，确保说，这个文档里反映出来的每个子系统都经过了良好和充足的测试，每个环节都做了，每个环节都按照标准、要求和规范去做了。

二、上线文档

架构师也可以指派一个人去做，有些公司，比如说一些较为传统的IT公司，一般对权限收的特别紧张，要求说只有经理才有级别去做什么代码合并，只有经理才有级别去操作线上系统，只有经理才有权限去执行上线。见过很多公司是这样子收缩权限的。

我的风格不是这样的。一般来说，我的理念，是说，尽量提升团队里每个人的能力。如果要提升每个人的能力，那么最好的办法，就是把他扔到线上的血与火的环境中去锤炼。有的人可能就工作个两三年那样子，甚至是一两年。但是如果他足够有潜力，你想要培养他的话，那就尽可能让他去做更多的事情。

尽量让年轻人做更多的事情

（1）详细设计：让组员自己去做，锻炼他的系统设计能力，而不是只会写代码

（2）工程初始化：让组员去做，锻炼他们从0开始迅速搭建出来一个系统的能力，而不是只会在现有的框架基础之上去填充代码

（3）集成测试、系统测试、验收测试：尽量让各个组员自己去做，配合QA、PM、其他团队的RD，让他们去协调，去沟通，锻炼他们的跨团队的沟通协作能力

（4）系统上线：让年轻的成员去进行线上操作，这样可以真正锻炼他们的能力，让他们有线上操作和运维的能力

如果高工走了，可能就没人能接活儿，没人去做设计，没有人会从0开始搭建一个工程出来，没人能协作组织跨团队的测试协作，没人能执行系统上线，和线上运维的一些操作

可能就导致说，你作为一个架构师，很累，什么事情，都要事必躬亲

1、初始化线上数据库

（1）从哪儿导出来一份SQL文件

（2）在哪个线上数据库中执行这份SQL文件

（3）执行过后，需要检查一下，需要的128张表是否全部完成初始化

2、部署系统到线上机器

（1）将完整的代码，打成war包

（2）到线上的哪台机器上去，将tomcat停止

（3）然后用scp将war包上传到机器上去，然后放入tomcat的webapp目录下

（4）然后重新启动tomcat服务器

（5）观察系统启动日志，各个环节的初始化是否正常，比如说数据库连接池的初始化

3、线上验证

（1）系统成功部署之后

（2）对几个核心流程和功能，手动执行一些操作

（3）确认所有功能正常运行

（4）确认所有的日志都正常打印

（5）确认所有的数据库中的数据记录都正常

三、执行上线

执行上线，一般会有一个规范，就是在什么时间点，可以执行上线

一般来说，是选择系统的低峰期

分开来说，不同的系统上线的情况，可以允许的时间是不一样的

（1）大版本，上线，v1.0，v1.2，一般是建议在晚上9点以后，就是在低峰期，甚至是建议在凌晨2点，凌晨5点

（2）小版本，修复一个bug，做了一些改动，一般是建议在非高峰期的一些相对低峰的时间段，可以执行上线，上午的10点以前，下午2点~4点

执行上线的规范

（1）需要超过2个以上的人在场

（2）一般是负责执行上线的同学，按照之前审核过的上线文档来一步一步执行操作

（3）级别较高的同学，高工，会去在旁边仔细看着他上线的每个步骤

（4）如果一旦出现任何问题，需要进行回滚，比如说，用之前版本的代码，再次重新上线

## 线上运维规范

### 1.线上运维规范

线上运维，最基本的一个事情，其实就是说线上系统，如果没有其他的什么技术挑战的话，主要就是出bug。如果出了bug，你怎么来解决，按照什么流程，谁来解决，解决之后，需要记录什么东西下来。

线上bug处理的SOP

Standard Operation Procedure：标准的操作步骤

1、线上故障反馈群

每个公司自己内部的IM，社交沟通的工具，钉钉，QQ，百度hi，咚咚。

但是很多小公司，也可能是微信群，QQ群。

得有一个专门的群是一个大群，这个群是专门给人反馈线上的bug的。

如果说，接收到了一个bug的反馈，用户提交的，产品经理发现，运营发现的，需要在线上bug反馈群中去抛出这个问题，同时打电话通知今天负责值班的人。

2、线上bug的分级标准

（1）S级：直接影响了系统的核心主流程，比如电商里，不能查看商品，不能使用购物车，不能下订单，不能支付了。要求1小时内解决。

（2）A级：没有阻塞系统的核心主流程，但是在核心流程里发生了一些影响用户体验的bug，查看商品的时候，css样式乱了，商品无法排序。4小时内解决。

（3）B级：阻塞系统的非核心流程，无法发表评论了，无法对别人的评论点赞了。1天内解决。

（4）C级：没有阻塞系统的非核心流程，评论列表没法分页。3天内解决。

3、线上bug反馈的模板

（1）bug名称

（2）bug发生的时间

（3）bug提交人

（4）bug的详细描述

（5）bug的相关截图

（6）bug的分级

（7）相关系统

（8）相关负责人

4、团队里的值班机制

团队里，有5个人，那么就需要按照一定的顺序排好，每周谁怎么值日，7天，可以这样子，有些级别高的人，可以承担更多的责任，可以去值班两天，有些年轻的同学，而已值班一天就可以了。

（1）周一，小A

（2）周二，小B

（3）周三，老C

（4）周四，老C

（5）周五，老D

（6）周六，老D

（7）周日，小E

当天负责值班的同学，需要保持全天24小时，手机电话畅通，持续关注公司里的交流群。

5、定位bug原因

根据bug反馈报告，到线上系统打印的日志中去，看一些那个时间点，相关的日志，根据日志的情况，定位出是什么bug。

日志很重要的，如果日志打印的不好，那么根本没法排查线上的bug。

定位到bug的原因之后，立即在线上事故反馈群里，反馈一下，这个bug，它的问题找到了，原因是什么。

6、解决bug

值班人，将bug转移给对应的bug负责人。

bug负责人此时需要从master分支拉一个bugfix分支出来，在自己本地跑起来整个系统，复现出来这个bug。

在本地修复这个bug和确认修复。

将bug合并到develop分支上去，由QA介入，在集成测试环境，确认说这个bug已经修复了。

将bug合并到master分支上去，在staging环境发布一下，由QA再次回归测试和验收，确保bug修复。

将master分支打一个tag，发布修复了bug的代码到线上去上线。给出上线checklist（bug反馈报告，原因，如何解决，bug修复测试的报告），给出一份上线文档（本次上线的步骤），执行具体的上线。

7、将bug的完整过程记录到一个bug文档中去

bug1

（1）bug的反馈报告

（2）bug的定位原因

（3）bug的解决思路

（4）bug的上线文档

（5）bug的反思：为什么会出现这个bug？少了测试用例，在测试的时候，没有伪造一些异常的请求和数据去测试？或者少了一些校验和验证的系统设计？

（6）bug的后续改进步骤：在设计测试用例的时候，需要构造更多的异常的请求和数据；在系统设计的时候，需要考虑更多的校验逻辑

8、将bug文档同步给团队里的leader和其他同学

每个人都要仔细看这个bug的具体的步骤和情况，去学习bug，共同进步。

# 项目管理规范

## 项目计划规范

### 1.项目计划规范

1、活动清单

活动清单，一般是每个人对自己负责的那个部分，需要自己在这个表格里填充对应的排期，因为只有自己负责的这个部分，自己是最熟悉的，大概是知道自己要做多长时间的。最终会汇总到一个完整的活动清单中去。

活动清单汇总完成之后，需要由架构师仔细审查每个人定的活动清单的人/日排期。最主要的是，根据架构师的丰富项目经验，要判断一下，每个人的每个工作，有没有多排期（职场里有很多老油条，是不好好干活的，比如说只要1天可以做完，2天，自己就可以多一天的时间出来自己玩儿，清闲一些），就需要架构师去判断，必要的时候需要对排期做调整，尽量保证排期是比较紧凑以及合理的。我个人的建议，架构师站在丰富的经验上，比如说我，如果我来带一个项目，在前期完全我来主导设计，然后评审每个人的详细设计之后，做了很多年的开发的人，对每个事情，每个工作任务，以那个人的能力和智商，大概要花费多少时间，其实大家心里都有数的。。

只可意会不可言传，没什么特别大的技巧，就是你如果工作了至少5~8年，以8年以上为最佳状态。那你对各种事情需要多少时间，门儿清。

有些同学，很积极主动的同学，可能希望自己是尽量少的时间里做更多的事情，他们跟上一种同学，相反。一件事情可能要2天，结果他们硬是给自己排了1天。需要大量的加班，排期很不健康的，很可能会导致项目会delay。架构师看到这种情况之后，要及时识别出来，有些同学排期太过于紧张，让他们增加一些排期。

我个人建议，28法则。工作的排期，留出来20%的buffer，用80%的精力给做了。这种情况是最合适的。

比如说一个工作大概是需要4天，那么你可以给排个5天。留20%的buffer。如果说正好是4天干完，多了一天出来，可以让手下的同学轻松一点，可以自己看看书，学习一下技术。如果说5天之内，出现了一些意外，导致4天内没有干完，20%的buffer顶上去，可以留有余地，不至于delay。根据我之前的一些实践，20%的buffer合理的。我常见到有些老油条，2倍，3倍，4倍，5倍的时间，去做一件事情。

（1）架构师定好类似这样的一个表格。

（2）通知组内每个同学，根据自己的详细设计的文档，在表格中填充自己的排期。

（3）然后架构师组织一个排期评审会议，这个会议上，每个排期一条一条的过。

（4）架构师重点关注，老油条和过度积极的同学，20%的buffer。

| 一级任务 | 二级任务 | 三级任务                   | 工作描述                                               | 负责人 | 所需人/日 | 备注                                                         |
| -------- | -------- | -------------------------- | ------------------------------------------------------ | ------ | --------- | ------------------------------------------------------------ |
| 系统设计 |          |                            |                                                        |        |           |                                                              |
|          | 概要设计 |                            |                                                        |        |           |                                                              |
|          |          | 编写概要设计文档           | 根据之前的需求分析文档，完成系统的概要设计文档         | 老D    | 5人/日    | 老D一个人花费5天时间去做                                     |
|          |          | 第一轮概要设计评审         | 找部门B和部门C中的三个架构师过来，帮忙评审概要设计文档 | 老D    | 5人/日    | 老D，小A，小B，老C，小E，团队中的5个人都要花费1天的时间来出席设计评审 |
|          |          | 第一轮修改概要设计文档     | 根据第一轮评审的意见完成的概要设计文档的修改           | 老D    | 2人/日    |                                                              |
|          | 详细设计 |                            |                                                        |        |           |                                                              |
|          |          | 编写XX子系统的详细设计文档 |                                                        | 小A    | 5人/日    |                                                              |
|          |          | 编写XX子系统的详细设计文档 |                                                        | 小B    | 5人/日    |                                                              |
| 系统开发 |          |                            |                                                        |        |           |                                                              |
|          | XX子系统 |                            |                                                        |        |           |                                                              |
|          |          | XX模块                     |                                                        | 小C    | 4人/日    | 包含编码、单元测试、冒烟测试                                 |
|          |          | XX模块                     |                                                        | 小C    | 3人/日    | 包含编码、单元测试、冒烟测试                                 |
|          | XX子系统 |                            |                                                        |        |           |                                                              |
|          |          | XX模块                     |                                                        | 小E    | 5人/日    | 包含编码、单元测试、冒烟测试                                 |
|          |          | XX模块                     |                                                        | 小E    | 3人/日    | 包含编码、单元测试、冒烟测试                                 |
| 系统测试 |          |                            |                                                        |        |           |                                                              |
|          | 集成测试 |                            |                                                        |        |           |                                                              |
|          |          | 设计集成测试用例           |                                                        | 小M    | 10人/日   | 测试组的QA同学，负责设计用例                                 |
|          |          | XX主流程集成测试           |                                                        | 老D    | 20人/日   | 需要4人参与，每人投入5个工作日的时间，总人/日是20人/日       |
|          |          | XX主流程集成测试           |                                                        | 老D    | 20人/日   | 需要4人参与，每人投入5个工作日的时间，总人/日是20人/日       |

2、网络图

画出来三级任务之间的执行流程和串联关系

每个节点包含任务名称、负责人、所需人/日

3、进度计划（甘特图）

制定一个指导项目完整的进度计划的一张图，甘特图

每个任务如何穿行，如何并行，将每个任务就不是以几人/日来表示，具体到某一个任务是从几号到几号

使用甘特图绘制出来完整的进度计划

4、资源配置表

在甘特图的基础之上，绘制出来每个任务的人员配置

## 项目执行规范

### 1.项目执行规范

1、执行计划

项目管理的一大重要实践准则：从多年项目的血与火的锤炼中，总结出来的真理和真谛。项目的执行计划，绝对是要在执行的时候，定到非常非常详细的一个颗粒度。务必细化到每个人每天要干什么，每天要干的事情，要写的非常的详细。接下来，做项目执行监控的时候，是完全按照每天的一个粒度，去检查每个人这一天干活儿干的怎么样，事儿干完了没有，有没有什么问题。

为下一周执行详细的执行计划，务必非常仔细，细化到每一天

每个人做的第一件事情，要求团队中的每个同学，都必须按照自己在项目管理计划中的排期，将每个任务拆解，拆解到非常详细，细粒度，细化到每天要做1234哪些事情，形成自己的一份下周每天要工作的执行计划

| 人员     | 本周主要任务                                                 | 周一                                                         | 周二                                                         | 周三                                                         | 周四                                                         | 周五                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 小A      | 1、完成订单系统的X1模块（3人/日） 2、完成订单系统的X2模块（2人/日） | 1、完成订单系统的X1模块的X1功能的开发【100%】 2、对订单系统的X1模块的X1功能，完成单元测试的编写【50%】 3、对订单系统的X1模块的X1功能，完成冒烟测试的执行【delay，60%】 | 1、完成订单系统的X1模块的X2功能的开发【100%】 2、对订单系统的X1模块的X2功能，完成单元测试的编写【100%】 3、对订单系统的X2模块的X1功能，完成冒烟测试的执行【100%】 4、晚上加班2小时，对订单系统的X1模块的X1功能，执行冒烟测试，进度预期达到80%【80%】 | 1、完成订单系统的X1模块的X3功能的开发 2、对订单系统的X1模块的X3功能，完成单元测试的编写 3、对订单系统的X1模块的X3功能，完成冒烟测试的执行 4、晚上加班2小时，对订单系统的X1模块的X1功能，完成冒烟测试的执行【100%】 | 1、完成订单系统的X2模块的X1功能的开发 2、对订单系统的X2模块的X1功能，完成单元测试的编写 3、对订单系统的X2模块的X1功能，完成冒烟测试的执行 | 1、完成订单系统的X2模块的X2功能的开发 2、对订单系统的X2模块的X2功能，完成单元测试的编写 3、对订单系统的X2模块的X2功能，完成冒烟测试的执行 |
| 小B      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 小C      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 老D      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 老E      |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 问题汇总 |                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| 编号     | 问题                                                         | 问题发生原因                                                 | 解决对策                                                     | 需要的帮助                                                   | 反馈人                                                       |                                                              |
| 1        | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库 或者 在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无 （有可能会是什么呢？如果是跨团队协作的时候，是需要帮助。让运维给你干个什么事儿，调整一个linux的内核参数，你没有权限。那哥儿们特别不靠谱，为人懒散） 需要某某leader，出面协调，java后端组的老大，去找运维组的老大去协调，让那个不靠谱的运维把linux内核参数给调了 | 小A                                                          |                                                              |

2、类百度的站立会制度

B里面，有非常好的一个传统，每天早上10分钟站立会制度。

每天早上一上班，第一件事情，就是开站立会，不要找会议室，很麻烦。直接定一个公司里的某个角落。项目组相关的人全部聚齐在这个地方。每个人1分钟以内，整体控制在20分钟以内，尽量在10分钟以内。

通过这个东西，一个架构师，或者说一个项目的leader和负责人，可以通过face to face，面对面的方式，去把控说，按照那个细粒度的每个人的执行计划，每个人每天的活儿有没有干完，就是有了这样的一个到天粒度的项目进度的监控机制，就可以确保说，人的懒癌就没法犯了。你要是懒癌犯了，昨天跑了，任务没干完，第二天站立会制度直接就被戳穿了，频繁几次的话，你就可以等着被开除了。价值观，在瞎干。

（1）每个人说自己昨天完成了什么工作，今天计划完成什么工作，目前是否发现了什么问题，打算如何解决

（2）项目负责人将每个人的进度更新到执行计划中去，对完成的任务标志一个状态，状态包括了【已完成】【进度60%】【进度50%，delay】【取消】

（3）项目负责人将每个人反馈的问题更新到问题汇总中去，包括了问题是什么？为题发生的原因是什么？如何解决问题？执行计划是否需要调整？

根据经验来看，一般如果你push每个同学将项目的进度定的粒度很细，到每天的一个粒度，每天按照站立会的制度去check昨天的进展，出现问题立即解决，给出补救的措施，一般来说，补救措施，都是加班，或者采取某些方案+加班，晚上加班，周末加班。

99%的情况下，每天的站立会都很快，一般都是完成完成完成。

在这样的一个制度下，每个人每天早上都在一个集体中去说自己活儿干的怎么样，人要脸树要皮，每个人都是有一定的自尊心，要面子的，懒癌，犯懒，为了自己最基本的在团队里继续待下去的一个尊严，其实每个人都会尽力将每天的每个事情做完。

3、个人周报

每周五的下午，每个人准备好自己的个人周报，组织周会。

| 姓名：       | 小A                                                          | 部门：                                                       | Java后端组                                                   | 项目：     | 电商系统v1.0 | 2017.05.26~2017.05.30 |      |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- | ------------ | --------------------- | ---- |
| 本周主要工作 |                                                              |                                                              |                                                              |            |              |                       |      |
| 编号         | 工作内容                                                     | 工作细节以及完成情况                                         |                                                              |            |              |                       |      |
| 1            | 订单系统的X1模块                                             | 1、订单系统的X1模块的X1功能，完成开发、单元测试、冒烟测试【100%】 2、订单系统的X1模块的X2功能，完成开发、单元测试、冒烟测试【100%】 3、订单系统的X1模块的X3功能，完成开发、单元测试、冒烟测试【100%】 |                                                              |            |              |                       |      |
| 2            | 订单系统的X2模块                                             | 1、订单系统的X2模块的X1功能，完成开发、单元测试、冒烟测试【100%】 2、订单系统的X2模块的X2功能，完成开发、单元测试、冒烟测试【100%】 |                                                              |            |              |                       |      |
| 问题汇总     |                                                              |                                                              |                                                              |            |              |                       |      |
| 编号         | 问题                                                         | 问题发生原因                                                 | 对策                                                         | 需要的帮助 |              |                       |      |
| 1            | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库 或者 在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无         |              |                       |      |
|              |                                                              |                                                              |                                                              |            |              |                       |      |

4、每个人的下周执行计划

| 人员     | 本周主要任务                                                 | 周一                                        | 周二                                       | 周三                                  | 周四                                  | 周五                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------ | ------------------------------------- | ------------------------------------- | ---------------------------------------- |
| 小A      | 1、配合QA完成用户下单购物主流程的集成测试（2人/日） 2、配合QA完成用户退货主流程的集成测试（3人/日） | 1、配合QA去执行用户下单购物主流程的集成测试 | 1、对集成测试中发现的bug完成相关的修复工作 | 1、配合QA执行第一轮退货流程的集成测试 | 1、配合QA执行第二轮退货流程的集成测试 | 1、完成退货流程集成测试中发现的bug的修复 |
| 小B      |                                                              |                                             |                                            |                                       |                                       |                                          |
| 小C      |                                                              |                                             |                                            |                                       |                                       |                                          |
| 问题汇总 |                                                              |                                             |                                            |                                       |                                       |                                          |
| 编号     | 问题                                                         | 问题发生原因                                | 解决对策                                   | 需要的帮助                            | 反馈人                                |                                          |
|          |                                                              |                                             |                                            |                                       |                                       |                                          |

5、项目周报

| 项目名称：           | 订单系统v1.0                                                 |                                                              |                                                              |            |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| 部门：               | Java后端团队                                                 | 起止日期：                                                   | 2017.06.01~2017.06.05                                        |            |
| 本周主要任务         |                                                              |                                                              |                                                              |            |
| 编号                 | 任务                                                         | 完成状态                                                     | 持续时间                                                     |            |
| 1                    | 订单系统的X1模块                                             | 100%                                                         | 2017.05.26~2017.05.28                                        |            |
| 2                    | 订单系统的X2模块                                             | 100%                                                         | 2017.05.29~2017.05.30                                        |            |
| 本周遇到的问题和对策 |                                                              |                                                              |                                                              |            |
| 编号                 | 问题                                                         | 问题发生原因                                                 | 对策                                                         | 需要的帮助 |
| 1                    | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库 或者 在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无         |
| 下周主要任务         |                                                              |                                                              |                                                              |            |
| 编号                 | 任务                                                         | 持续时间                                                     |                                                              |            |
| 1                    | 完成用户下单购物主流程的集成测试（2人/日）                   | 2017.06.01~2017.06.02                                        |                                                              |            |
| 2                    | 完成用户退货主流程的集成测试（3人/日）                       | 2017.06.03~2017.06.05                                        |                                                              |            |
|                      |                                                              |                                                              |                                                              |            |

## 风险管理规范

### 1.风险管理规范

风险管理

讲过，项目管理的过程中，一定是会遇到一些风险的。那么有些风险是比较小的，或者没有提前预料。如果没有提前预料到的一些风险，发生了，其实就是在我们每天的站立会里，就会问每个人，执行每项工作，是否遇到了一些问题，那么那些问题就是发生的一些风险。但是对于这种风险的话，一般会通过问题的处理方案和补救措施来解决，那么这样的话呢，我们之前就已经讲解过了这样的一种情况。

但是如果每次都是光靠风险发生了，问题都发生了，然后事后我们第二天才知道，才开始想办法去如何解决，采取什么样的对策，那可能有的时候就晚了。因为你光是考虑出来具体的对策，可能就需要耗费一些时间，而且为了解决这个风险或者是问题，你可能还需要耗费更多的时间去做一些事情。风险但是如果我们事前就可以识别出来项目进展的过程中，可能会发生什么样的问题和风险，然后提前就识别出来了，然后提前就准备好了预案，那么等到风险真正发生的时候，我们就可以立即拿出来这套预案来执行和解决问题。

给大家举一些例子，就是在提交每周的一个项目周报的时候，都需要在这个项目周报中，写清楚这个项目未来可能会有什么样的风险，然后我们准备好的风险预案是什么，风险是否发生了，如果发生之后，采取了什么方案来解决，风险解决的结果是什么。都需要在每周的项目周报中要写清楚的。风险管理，是项目管理中非常重要的一个环节。其实风险管理，也是比较复杂的，在很多公司里，尤其是一些传统的IT公司，会积累下来一份常见风险的模板，对每个新启动的项目，你做项目管理的时候，可以对照着风险的模板，去看一下说，我们这个项目中，是否有可能会发生这个模板里列出来的一些风险。

这个东西，我觉得还是不同的公司是不一样的，传统IT公司，互联网公司，遇到的一些风险都是不一样的。

还是只能我们定义好一套处理风险的流程和规范，大家在真正做项目的时候，首先第一件事情，建立起来这个风险管理的意识，就是说， 你要有这个意识，我们需要去做风险管理。然后最怕的是说，你根本就没有这个风险管理的意识，在项目启动的时候，压根儿脑子就没去考虑过项目执行的过程中，可能会发生哪些风险。如果你压根儿就没去考虑，那是肯定不行的。你一定要去考虑说，我要有这个风险管理的意识。每次做项目的时候，就按照我们这一套流程和规范去走，尝试去识别出来有什么风险，尝试去制定一些风险的预案。

最主要这块，还是说在你多年做项目的过程中，真正按照这个流程去积累经验，可能你的每个项目都会遇到一些问题，那些问题，实际上就是我说的你没有预料到的一些风险。如果你之前预料到了，那么就不是问题了，其实就是之前准备好的风险发生了，采用你的预案。如果你没有准备好会遇到这些问题，那么实际上遇到这些问题的时候，你就可以积累一下经验，可能会出现的风险是什么？

所以这块，也是属于只可意会不可言传，不同的项目，差异实在是太大了。传统IT行业，电信项目，业务，一做就是很多年。那么在这种情况下，你的技术，过程，都是类似的，你说还可以去使用之前积累下来的一些风险模板，去尝试规避。在我的经验而言，互联网行业 里做项目，不同的公司，不同的团队，不同的情况，不同的项目，其实风险的识别出来，提前能够预料到一些风险，主要靠架构师的经验，就是建立起来了一种对风险的第六感。识别出来这样那样的一些问题，这个都是多年积累而来的一个经验。

小A同学遇到了一个问题，就是说在冒烟测试的时候，或者是集成测试的时候，突然发现说测试环境的redis集群挂掉了，需要运维人员去进行运维，比如说采用更高的机器配置来给你搭建redis集群。测试环境，突然发现测试环境的mysql挂了，测试用的mysql是一台服务器，上面建了不同的数据库，不同的系统和项目都在走，并行的在跑，然后就会发现说，有一个项目在集成测试环境里，或者是在系统测试环境里，在做压力测试。压力测试导致测试环境的mysql突然性能变得巨差，甚至直接就挂掉了。

我后面，尽量会在做这个电商项目v1.0的时候，完全按照纯真实的项目过程，去给大家演示，我的第六感和判断，我们的这个项目在执行的过程中，可能会遇到一些什么样的风险，带着大家尽量在模拟真实的环境中去体验风险如何管理。

风险识别、风险分析（发生概率、影响范围）、风险预案、风险监控。

| 项目名称：           | 订单系统v1.0                                                 |                                                              |                                                              |                                                              |          |                                                              |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 部门：               | Java后端团队                                                 | 起止日期：                                                   | 2017.06.01~2017.06.05                                        |                                                              |          |                                                              |
| 本周主要任务         |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 任务                                                         | 完成状态                                                     | 持续时间                                                     |                                                              |          |                                                              |
| 1                    | 订单系统的X1模块                                             | 100%                                                         | 2017.05.26~2017.05.28                                        |                                                              |          |                                                              |
| 2                    | 订单系统的X2模块                                             | 100%                                                         | 2017.05.29~2017.05.30                                        |                                                              |          |                                                              |
| 本周遇到的问题和对策 |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 问题                                                         | 问题发生原因                                                 | 对策                                                         | 需要的帮助                                                   |          |                                                              |
| 1                    | 订单系统的X1模块的X1功能的冒烟测试delay，原定1天完成，现在需要2天 | 主要是因为在冒烟测试的时候，发现dba没有按照预定的规定，为我们搭建好开发环境的mysql数据库 或者 在测试的时候，当天正好碰到开发环境的redis集群挂掉了，redis运维同学花费了1天时间再解决，导致我们无法进行冒烟测试 | 采用未来2天，每天晚上加班2个小时的方式，一共加班4个小时，完成这个事情 | 无                                                           |          |                                                              |
| 下周主要任务         |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 任务                                                         | 持续时间                                                     |                                                              |                                                              |          |                                                              |
| 1                    | 完成用户下单购物主流程的集成测试（2人/日）                   | 2017.06.01~2017.06.02                                        |                                                              |                                                              |          |                                                              |
| 2                    | 完成用户退货主流程的集成测试（3人/日）                       | 2017.06.03~2017.06.05                                        |                                                              |                                                              |          |                                                              |
|                      |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 项目的主要风险       |                                                              |                                                              |                                                              |                                                              |          |                                                              |
| 编号                 | 风险                                                         | 发生概率                                                     | 影响范围                                                     | 应对预案                                                     | 是否发生 | 应对情况                                                     |
| 1                    | 系统测试预定是两轮测完所有bug，但是可能会出现两轮没有测完所有bug的情况 | 20%                                                          | 导致项目延期一到两周                                         | 接下来晚上和周末所有人过来加班，通过加班快速完成最后的几轮测试，以及所有bug的修复，尽量通过晚上和周末的加班来解决 | 是       | 通过连续3个晚上每晚加班4小时，包括周末加班两天，每天加班10小时，完成了额外的第三轮测试，项目没有延期 |

## 变更管理规范

### 1.变更管理规范

需求变更

0、案例式的讲解

比如说我们项目干到一半儿了，突然有一天，PM过来找你，这个项目的负责人，他说，有一个XX功能，能不能改一下实现方式，或者修改一下这个功能的运作流程，或者是对这个功能加强一下，比如说有一个查询的功能，商品查询。本来预定的商品查询的条件是4个，商品名称，商品编号，品牌，类别。整个咱们的这个系统和代码，都是按照这个预定义的需求去做的，包括这个功能的代码实现，包括这个功能内部的一些运转流程，包括之前设计好的设计模式，都是针对这个需求来的。

结果这个PM跑过来找你说，诶，我发现这个需求好像不太对啊，好像这个功能需要改一改，再做一些加强，商品查询的功能，不能只是按照4个条件来查询，需要支持8个条件，比如商品状态、商品创建人、商品库存、商品好评率，他可能脑洞大开，又要让你加好多的查询条件。

然后这个时候，你一听，如果要改动这个功能的话，可能要增加很多的工作量。那么此时一般来说，RD，思维，一定不是站在产品设计的角度去走的，我们一般都是站在技术实现的角度去考虑的。跟PM是完全不一样的，PM会觉得说增加4个查询条件对运营人员的工作效率可以起到大幅度的提升。但是对于你来说，如果要增加4个查询条件，可能导致多了几天的工期，甚至导致整个项目可能会delay。此时一般你会拒绝他，你会说，不好意思，我不想修改。

但是此时，PM通常会这么说，不就是加几个查询条件吗，很简单的。有什么难的。甚至更有甚者，他提出的需求变更是加4个查询条件以及2个排序条件，支持按照什么什么规则去排序。然后他说很简单的，你就随便改一下，找一个人，花一个小时可能就搞定了。

但是，你作为架构师，你考虑一下，是这么简单吗？首先，加的那4个查询条件，商品状态、商品创建人、商品库存、商品好评率。商品状态、商品创建人，还好说，因为你想一下，这两个字段可能是涵盖在商品的主信息表里，那么直接修改查询商品的条件就可以了。但是问题在于后面两个查询条件，商品库存、商品好评率，这个就不简单了，因为可能是需要将商品跟库存表去关联，然后查询，商品好评率，可能也是一样的额，需要将商品数据跟评论表去关联，然后去查询。而且这里有一些问题，如果仅仅只是修改SQL也就算了，但是这里可能是挺复杂的，如果要做这些关联，你要去评估，索引有没有设计，SQL如果这么做的话，SQL的性能会不会大幅度下降。

甚至，可能评论是放在别的数据库中，微服务里，你还不好直接去查询，可能还要请求别的服务的接口，从别的服务里获取这个数据到自己服务里来拼接，那么此时可能还要涉及到你要跟其他team的人去交流，可能还要让其他team的同学配合着加一个接口。

评估，加4个查询条件：调研和评估（索引的情况，性能的情况，其他服务提供的接口情况）、设计实现方案（详细设计文档）、开发、单元测试、冒烟测试、静态代码扫描、集成测试、系统测试 -> 耗费多少人力，首先负责开发的RD要耗费几天的时间 -> 此时代码修改了，要重新进行集成测试，耗费1个QA+4个RD，5个人重新再小黑屋里回归一遍 -> 耗费QA的时间，将这个功能重新进行功能测试 -> 不是说你就修改了部分代码，就重新测试部分代码就可以了，你只要修改了代码，那么原则上来说，我们又不知道你只是修改了部分代码，我们也不好确认说，你修改的这点代码有没有影响别的代码 -> 各个测试环节，全部进行全量的回归测试

评估完了这个成本之后，你再来告诉PM，你还要不要随便这样子修改需求了？

案例式的方式，带着大家去走了一遍，修改需求的时候，会出现什么样的一个坑爹的情况

1、需求变更的常见原因

（1）不靠谱的原因

PM不靠谱，99%的需求变更的情况，就是PM不靠谱，就是PM在进行产品设计的时候，思考这个产品需求的时候，没有考虑清楚，没有细化所有的需求，没有考虑到各种各样的情况。导致在系统开发到一半的时候，PM来搞这个事后马后炮。一开始的时候，是按照4个条件来查询，8个条件，10个条件，支持所有列双击界面上的列头，都可以按照那个列来排序。PM自己上手，1个小时就可以搞定这个事情。

大家按照PM没有考虑清楚的需求文档就开始做了，结果开发到一半儿，PM反悔了。

（2）靠谱的原因

常见于市场竞争态势的变化

比如我们以前开发一个产品，市面上是有几个竞争对手的，BAT现在也开始在做很多产品，对外也都是竞争的。我们有一个大版本，是持续两个月的。结果在做到一半的时候，市场竞争态势出现了变化，就是竞争对手率先推出了新的功能，抢占了一些用户和市场。此时我们的高管就着急了，副总裁级别的人，副总就直接下命令说，必须在这个版本中加入某某某功能，要跟我们的竞对要持平。

我们作为技术人员的价值在哪儿？就是我们开发出来的东西，他一定是要为公司产生直接的经济效益的。节省成本，增加市场占有率，增加用户流量。

对于这种靠谱的原因，那么作为我们RD来说，义不容辞的，有价值观。我印象里有一句话，我之前就是做项目的时候，碰到过几次类似这样的情况，有同事就特别棒，他说的是，上刀山下油锅，都必须把这个东西给做出来。

如果一个RD胡乱按照自己的思维去做事情，完全不考虑公司的利益，那你作为一个RD就没有存在的价值了，可以被公司开除。

靠谱原因仅仅占比1%。

2、对待需求变更的思路

（1）对不靠谱的需求变更

第一点

要加强需求评审的意识，就是说作为RD，你在评审产品经理编写的产品设计文档，产品需求文档的时候，你一定一定要仔细看每个环节，仔细的去思考这个产品的每个需求的细节，力求脑子里基本上就知道为了做这个需求，大概技术设计该怎么做。如果在评审需求文档的时候，你感觉可能会有坑，赶紧提出来，给PM提前提意见，让他提前调研和思考清楚，有些功能要不要做。

比如说商品查询的功能，作为一个RD，你要有一定的产品意识，当你工作了很多年之后，做了很多的项目之后，建立起来了比较丰富的工作经验，对待产品的设计，你虽然没设计过，但是你做过很多产品，你培养起来了自己的一种第六感。站在这个第六感的角度，你可以去考虑一下，每个产品需求功能，是否靠谱。比如对于商品查询的功能，你就可以站在产品设计的角度，去考量以下，诶，这个商品查询就4个条件，是不是太少了？这个时候这句话，可能就是你的第六感告诉你的。然后你就要反馈给产品经理，让它重新在考虑一下，说这个商品查询，你再想想，要不要加入更多的查询条件。

也许通过你的很牛的第六感的提议，可以让产品经理提前把一些坑给填了，不至于后面给你挖坑。

倒逼产品经理去完善需求文档，你的脑子里，在看完需求文档之后，脑子里基本要建立起来一个流程、概念和意识，就是大体上你都知道系统层面，需要怎么做系统开发，来实现这样的一些需求和功能。那么如果你在脑子里思考技术和系统实现的时候，感觉有些问题，感觉有些需求模模糊糊的，不清不楚的，那么此时就要在需求评审的时候，提出建议，让PM反过来去完善需求文档，细化，重新思考。

我们之前写好了一份需求文档，但是那份需求文档是一定有不够完善的地方的。那么接下来我们做系统的时候，就站在架构师的较多，从需求评审开始，一点一点去评审整个流程，在脑海中去思考这个系统层面怎么去做这个东西。如果感觉有不靠谱的地方，可以记录下来需求评审意见。我们自己模拟自己是产品经理，去完善这个需求文档。

这个大家不要觉得这个事情很虚，这个都是架构师非常重要的软素质。

第二点

如果是在开发过程中，不靠谱PM提出来不靠谱的需求变更，判断出来是99%的情况，直接打回去，作为一个架构师，你要据理力争，否则如果你不断的妥协的话，你就会导致你手下的弟兄，像一群猴儿一样被PM耍的团团转。如果你接受PM提出的不靠谱的需求变更，你手下的弟兄就会各种反复加班，去修改代码，去满足那些乱七八糟的要求。你是在坑你的弟兄。

直接给他打回去，如果他一定要做，让他找产品总监，直接对接你上面的技术总监，让两个总监去PK。

如果打回去之后，因为产品总监过于强势，强行逼迫你的技术总监答应，要改动这个东西，就走后续的需求变更的流程，技术总监审批，delay。

（2）对靠谱的需求变更

无条件接受了，但是要说清楚，肯定要走一个需求变更的流程，需要有高层领导，技术总监级别的人，要审批。

一旦有需求变更，基本上就意味着，肯定要延期，工期增加了，正常延期，找你的技术总监去审批。

3、需求变更的流程

3.1 PM发起需求变更的申请

一份需求变更的申请模板

（1）商品系统-商品管理模块-商品查询功能

（2）原有的需求是按照4个条件来查询商品，4个条件包括了：商品名称，商品编号，品牌，类别

（3）现在需要将需求改动为

在4个查询条件基础之上，增加4个查询条件，分别是：商品状态、商品创建人、商品库存、商品好评率。

同时，在增加4个查询条件的基础之上，需要支持商品列表中的所有字段，都可以支持前端双击列头的时候，会自动进行排序。

（4）需求改动的原因

需要支持这样的功能，来辅助商品相关的运营人员去更好的管理商品，在需要的时候可以尽快查出想要查看的商品数据，而且支持商品列表按字段来排序。

3.2 需求变更的评估

找具体负责这个需求的同学来评估一下，要为了这个需求做哪些事情，耗费多少人日，从几号到几号，导致项目delay几天

（1）商品系统-商品管理模块-商品查询功能

（2）将这个功能改动为

在4个查询条件基础之上，增加4个查询条件，分别是：商品状态、商品创建人、商品库存、商品好评率。

同时，在增加4个查询条件的基础之上，需要支持商品列表中的所有字段，都可以支持前端双击列头的时候，会自动进行排序。

（3）需要改动的一个步骤是

调研和评估（索引的情况，性能的情况，其他服务提供的接口情况）：1人/日

设计实现方案（详细设计文档）：1人/日

重新开发：1人/日

单元测试：1人/日

冒烟测试：1人/日

静态代码扫描：1人/日

集成测试：2人/日

系统测试：2人/日

（4）改动持续的时间

从6月5号持续到6月15号。

（5）耗费的成本

耗费总人/日是10人/日

（6）对项目进度的影响

导致项目整体delay达到10天

3.3 对需求变更进行审批

架构师负责将这个需求变更的申请和评估报告，提交给技术总监。

项目delay是一个大事，轻则影响绩效，重则影响公司业务发展你要被开除，p2p领域，数一数二的龙头，XX贷。XX贷出来的一个同学，就是做一个项目，delay了一个月。领导直接二话不说，开除。北邮的硕士，XX贷公司背景也很好，但是背上了项目delay被开除的结果，到很多公司面试都碰壁。离职证明上会写明，由于该员工项目delay，所以公司决定与其解除劳动合同。

技术总监负责对这个delay的时间进行考评，考量过后，确认通过审批

4、具体去实施这个需求变更

项目管理计划的4张图都要修改，很多任务都要delay，额外加入了一些任务 。

当前正在进行的本周或者是下周的执行计划里，要修改，加入这个额外的任务 。

接下来，照着修改过后的项目管理计划，和每周的执行计划，去执行就可以了，就开始干这个额外增加的新需求。

# 技术调研规范

## 技术调研规范

### 1.技术调研规范

1、什么时候做技术调研？

一般来说是在做完了需求评审之后，我们已经评审完了需求，知道了要做一个什么样的系统，大概也知道了这个系统的复杂度，功能有多少，对性能的要求是什么样子的，数据量会有多大，并发量会有多大。接着我们就会做需求分析，在需求分析之后，我们从技术角度去定义清楚了这个系统要做成什么样子，包括功能长什么样子，系统运转的流程是什么样子，有哪些特殊的需求（并发性、可用性、数据量、安全性）。

接着就是要做技术了，但是这里有个问题，可能在做技术设计之前，我们会发现说，作为架构师，你可能想要用一些新的技术，来做这个项目。比如说用Spring Boot来作为整个系统的脚手架框架， 让系统的框架整合和启动效率更加高一些；我们还希望使用一些设计模式，来更好的设计我们的系统中的各个代码组件，保证我们的系统的代码的可扩展性是非常高的；因为团队越来越大，需求越来越复杂，多团队并行开发需求，特别频繁，这个时候可能需要微服务的架构来解决这个问题，可能又要去学习Spring Cloud、DevOps等知识来做微服务的架构。

所以严格意义上来说，在需求评审过后、需求分析完成后、技术设计开始前，需要进行一些技术调研，为后续的系统设计，储备需要的技术。

2、如何去做这个技术调研？

一般来说，我的风格，一般做一个新的项目，我们都会尽可能去增加一些最新的技术，最流行的一些东西。互联网行业，好就好在这里，互联网行业是一个比较开放，快速变化，会承担很多的技术挑战的一个行业，传统IT行业是不太一样的。互联网行业，你一半要做的是说，开发一个系统出来，支撑你的这个互联网公司的整个业务的发展，此时你要承载的就是更多的用户，更大的访问量，高并发，高性能，高可用，安全性，快速迭代，你要负责去解决这些技术挑战。

而行业里，不断的每年都涌现出一些新的技术出来，都是为了解决各种各样的问题而产生的，此时对于互联网行业来说，一般就是快速的去吸收这些全新的技术和理念，思想，架构，基于这些最新的东西，来重构自己的架构设计，让自己的架构更好，可以解决更多的技术挑战和问题，更好的服务公司的业务发展。

传统的IT行业，我开发出来一个IT产品，IT系统，去服务于我的客户，为我的客户提供软件系统的功能，去更好的让我的客户的业务实现发展。IT系统，承担的用户都是一个公司内的一些员工。一般技术挑战很少，更加重要的是说，我每次接到一个单子，要做一个系统，如何能够以更低的成本，直接复用之前的代码，稍微改一改，就可以服务于新的客户，快速交付，用更少的人力去交付产品，获取利润。

如果要不断的使用新技术，就意味着传统的IT行业要不断的投入大量的人力物力去研究技术，不断的去重构自己之前已经做好的系统。这个对于传统IT行业来说，是没有意义的。如果10年前开发好的一套系统，10年后还能继续给新的用户来使用。成本很低，但是可以不断获取利润。我是传统IT企业的老板，我也不会干这事儿。对于传统IT企业来说，如果要用新技术，重新做这个系统，一定是有原因的。

之前大数据火了，其实很多传统的数据项目，用oracle搞定，但是人家客户不认，我要做大数据，流行，跟风啊，数据量很少，还得去部署那种几台机器的小集群，与运行hadoop，hbase，spark，一整套技术。oracle集群可能就搞定了。

互联网行业的公司，一般技术更好，用的技术更新，承担的技术挑战更大，出来的人技术能力更强，工资更高。互联网行业工作5年的人，薪资就在30~35k之间了。

传统IT行业的公司，一般技术较为陈旧，技术更新很慢，系统没什么技术挑战，出来的人技术能力较为平庸，工资较为平平。20~25k，少了10k，这都是有可能的。

每次做新的项目，必定会有技术调研的环节，因为在互联网行业中，拥抱新技术，快速使用新技术，尽快的去实践新技术，保证自己的系统架构是最好的。

组织团队内的各个同学，每个人负责一个技术，去调研一下这个技术。

3、技术调研的流程和规范

3.1 技术有哪些功能

看官网，要求我的同学看官网，不行的话就买一些中文的书，或者技术博客

写一个demo快速入门一下，对那个技术看一下初步的介绍，这个技术是干什么的

仔细看一下这个技术官网相关的官方文档，买一本书看看，里面的重点以及核心的技术都实践一下

3.2 技术的热门和流行程度

（1）开源技术的GitHub的更新频率：如果保持较好的更新频率，那是ok的；但是如果这个技术很少更新，那就不要考虑了

（2）这个技术在国内的运用怎么样：是否足够热门，在国内有哪些公司在使用这个技术

（3）这个技术在国内的中文资料是否足够多：如果中文资料足够多，就说明这个技术较为热门，有更多的资料可以参考

3.3 技术跟公司的整体技术环境是否适合整合

比如说你如果用Spring Cloud，假如说你在阿里，那就肯定不合适了，其他一些大公司。因为那些大公司都是自己研发的微服务的整体架构，都是用自己的东西的。如果你冷不丁搞一个跟公司开发好的基础设施架构重复的东西，那肯定是不合适的。

3.4 看一下这个技术的其他的方方面面

（1）易用性：是否足够简单上手使用

（2）稳定性：是否足够稳定可以使用，bug较少

（3）功能性：功能是否足够完善和强大

（4）与其他技术的整合性：能否良好的跟其他相关的技术进行整合

（5）性能：类似Spring Boot框架，就没什么好说的了；redis，memcached，mongodb，elasticsearch。适当自己在测试环境下，做一些简单的性能测试

（6）并发能力（吞吐量）：每秒可以承载多少请求，做一些简单的压力测试

（7）可用性：这个技术是否提供了高可用部署的机制，比如redis就可以基于redis sentinal哨兵机制实现高可用架构，做一些简单的故障演练

（8）伸缩性：这个技术如果需要扩容的话，是否可以扩容

（9）扩展性：是否可以对这个技术进行一定程度上的扩展，比如说Spring Boot，就可以支持我们自己写spring-boot-starter-x的项目，支持我们自己将Spring Boot跟其他技术进行整合

（10）安全性：这个技术是否足够安全，没有过多的安全漏洞，struts2框架，安全漏洞频频爆出

3.5 技术跟同类技术的横向对比调研

Spring Cloud -> Dubbo -> DubboX

Thymeleaf -> freemarker -> velocity

Redis -> Memcached

Elasticsearch -> Solor

对比哪些方面呢？就是上面说的那些方面，产出一份横向对比的表格

3.6 选择这个技术的理由

调研完了，了解清楚了这个技术了，也跟其他技术对比了优势和劣势了

4、编写技术的培训手册

一般是用ppt的形式来变现的，主要是在决定选择使用一个新技术之后，需要将这个技术编写成使用手册，引入团队中，对团队进行培训

（1）介绍清楚这个技术的基本原理

（2）介绍清楚这个技术的核心功能

（3）介绍清楚这个技术的一些调研情况

（4）给出这个技术使用的demo，不是特别简单的demo，而是将这个技术引入我们的公司环境中，如何跟公司现有的技术栈整合，如何在公司的项目里去使用这个技术

5、对团队里的成员进行培训

每个人都要学习清楚这个技术是怎么回事儿，在项目中来使用的时候，每个人都能得心应手

6、就可以将这个新技术用到我们的项目的技术设计中去了

7、课程里，就会对每个技术的学习，都模拟成是，你现在要为你的公司引入这门技术，然后你学习就是在做调研。完全模拟公司里真实的技术调研和引入的环境和流程以及场景。Spring Boot和设计模式。

# 需求评审

### 1.需求评审记录

一、权限中心需求评审建议

1、权限树的每个节点，显示什么东西？

2、添加根节点的时候，怎么添加，点击哪个按钮？

3、同上，添加子节点、编辑节点、删除节点，该怎么操作？

4、不要单纯的在纯前端去操作一颗权限树，操作完了以后，一次性同步这棵树，那样的话会导致我们的后台逻辑，太复杂

5、新增角色的界面中，对于表单显示哪些字段、权限树操作的一些细节，都比较模糊，希望予以补充

6、同上，编辑角色的界面中，很多细节信息，比较模糊

7、启用/停用按钮，我们不清楚，什么时候显示启用，什么时候显示停用

8、角色列表的查询条件，默认值是什么？默认情况下查询出来哪些角色呢？

9、账号信息，是否需要添加更多员工的更加详细的信息？比如说地址之类的一些东西？

10、账号列表的查询条件，需要完善默认值

11、账号列表中，显示哪些字段啊？

12、添加账号的操作，很多信息比较模糊，不够完善，比如说点击按钮过后，是会显示什么东西呢？

13、编辑账号的操作，同上，很多地方比较模糊，希望予以完善

14、启用/停用账号的操作，修改密码操作，同上，很多地方比较模糊，希望予以完善

15、权限控制那块，左侧菜单栏的显示，权限应该一般是三级的，是否会四级五级的情况会出现？

16、既然不能限定四，就查询二级，或者是三级权限，作为菜单，那么如何区分菜单权限和按钮/其他权限呢？

17、架构师，给一个提议，第一个版本，要不先不做这么复杂，操作日志，直接基于tomcat日志来记录不就可以了么？就是说，内测版本，不涉及到什么对外，黑客，没有安全问题，那么是不是操作日志可以暂缓，等到后面的版本再来迭代。一个版本，我有时候一定要根据这个版本对应的背景，来考量，这个功能到底需要不需要。

18、架构师，给出一个建议，既然我们的v1.0版本是内测版，黑名单管理，不对外，可以暂时不做，后面的版本我们再迭代的

19、账号管理中，居然没有写删除的功能，补充一下

二、商品中心需求评审建议

1、属性管理这块，还是太模糊，增删改查，没有说明白具体的功能流程

2、类目管理这块，还是太模糊，没有说明白具体的功能流程

3、品牌管理这块，还是太模糊，没有说明白具体的功能流程

4、商品管理这块，还是太模糊，没有说明白具体的功能流程

5、刚开始第一期，不做库存自动预警相关的功能，可以讲那个字段先删除掉

6、刚开始第一期，是不打算让不同级别的会员享受不同的折扣的，因为这个纵观各个电商网站，现在主流都不是这么玩儿的了，会员的级别是享受，积分是3倍，5倍，一年享受10次免运维，以我的想法，就不要在这里这样做

7、第一期，就得支持到SKU粒度，去设置库存和价格，不能放到以后，SKU是实际的交易的载体

8、没有看到商品删除的功能，建议因为已经有了上架/下架的操作，不需要已删除的状态

9、删除属性的时候，是有类目关联属性的，要做一个限制，就是如果判断有类目还关联着这个属性，就不允许删除属性

10、删除类目和品牌的时候，也是的，如果有商品关联着某个类目和品牌，就不允许删除类目和品牌了

11、对商品粒度（SPU粒度）需要有一个商品编码，对SKU粒度（也需要单独设置一个编码）

12、对商品进行审核的时候，其实是需要点击审核按钮，进入一个审核界面，审核界面中提供商品的所有数据，最后给审核的选项，通过/不通过

13、商品审核，由谁来审核？有谁有这个权限可以去进行审核？建议，第一版做的简单一些，不区分谁能够来审批，但是需要记录下来审核人。假设的是电商公司刚开始，团队很小，可能商品的运营就两三个人，负责采购的就两三个人。那么可能就是比较简单的，就是某个人需要审核，就告诉工位旁边的领导，跟他说，你来审核一下。

三、采购流程需求评审建议

1、刚开始，电商公司刚开始经营，就不做自营供应商，第三方供应商，需求设计里可以取消掉自营供应商的环节

2、供应商CRUD的操作，没有给出具体的功能流程

3、对供应商的删除功能，提出异议，就是说供应商关联的数据实在是太多了，包括了采购单，财务结算单，如果允许物理删除，导致各个系统之间耦合太严重了。建议目前不要做删除的功能，仅仅能对供应商增加和修改，启用/停用的状态。

4、将供应商绩效的评级，添加到供应商列表中

5、供应商，看到了他是B级，A级，点击评级，可以进入一个页面，这个页面里可以查看到这个供应商他每一次交货的一个记录

6、对采购单管理的各种细节，还是很模糊，需要进行完善

7、采购单谁能进行审核，假设的是刚开始都是小团队作战，沟通成本很低，谁都能来审核，提交审核的人，告诉领导来审核即可。

8、就是在采购单发给供应商之后，没有一个财务打预付款的这么一个过程，连点定金都没有。一开始公司成立，用的供应商，都是老板以前的老人脉，老资源，不需要付预付款项，直接都是走商品入库以后，按照结算周期，按照周/月/季度，统一结算一次即可。

9、调度采购入库这块，实在是太简单了，都没法按照这么简单的需求去做系统设计。大家千万别觉得PM都很专业，我就见过太多的欠缺经验，不靠谱，刚毕业的，菜PM，设计出来的产品需求文档，第一个版本就跟我设计的差不多。很多细节他都没没有考虑到，很多地方都很模糊，甚至是一笔带过。开发人员就没办法根据他的产品设计文档，去进行技术的设计。

10、作为技术人员，猛烈的来抨击PM，作为我们的第一版系统，不应该做的这么复杂。其实行业里，这块，如果做的比较简单的一些的话，他是在采购入库单中，是可以由人工手动添加，将某个商品多少多少件，放到了哪个货位上去。然后呢，仓库里的工作人员，接到了采购入库单，指导每个商品要过来多少件，然后呢，实际商品到货之后，仓库工作人员，负责将商品，自己人工选择，将哪些商品放到哪个货架上去，通过肉眼去判断，每个货架还有多少剩余空间，商品应该怎么来放置。工作人员，可以从最近的货位开始，去寻找还有空余空间的货位，依次将商品上到货位里面去。每次上一批商品到货位中去以后，会在采购入库单中，更新一下，将哪个商品，多少件，给放到了哪个货位中去。

11、WMS中，没有定义创建采购入库单新建的逻辑

12、WMS中，采购入库单列表、编辑、审核，还是较为简单，比较模糊

13、WMS中，对采购入库单审核后的一些流程，定义的非常模糊，不太清晰

14、财务中心，采购结算单的这个管理，定义的非常模糊，不太清晰

15、财务中心，没有定义清楚如何在财务结算单审核通过之后，如何对供应商进行打款

四、购物流程需求评审建议

1、站在架构师的角度，第一版是内测版，还是建议不要太过于复杂。首页建议跟前端直接约定好，由前端直接做死。我们在后台初始化好一堆类目树以后，我们会告诉他，我们希望他在前台展示的左侧类目树是什么样子的，点击一个类目才会访问我们的后台接口。搜索框，也是，搜索的时候，访问我们的后台接口。中间的轮播广告，建议直接就是纯前端做死，点击可能是进入某个活动页面，也可能是直接访问我们后台接口，进入某个商品的详情页。下面的每个类目的热门商品，直接做死，点击之后访问后台接口，进入咱们的商品详情页。

2、站在技术的角度来分析一下，我们不要看京东做的多么好，多庞大的技术团队在做。如果要搜索一个词，然后可以出来一个商品列表页，同时上面还要有筛选条件。大家考虑一下，这个筛选条件是怎么出来的？必须是你搜索的关键词，他要智能的识别出来是属于哪个类目的？因为知道了是要搜索哪个类目的，才能将那个类目的所有导购属性的值提取出来，动态做成筛选条件？这块第一版，是不太好做的，建议不做。建议是什么呢？一旦搜索某个商品之后，直接就出来一个商品列表页，在商品列表页中，可以分页浏览，暂时不支持进一步的条件筛选。

3、在我真实的工作场景里，我给大家展现的都是我在进行需求评审的时候这个思考的一个这么过程，你要站在技术的角度，去各种权衡利弊，考虑当前这个版本的产品背景下，我们是不是可以做一些取舍。因为正经的产品，一定不是一口吃个大胖子的，一定是一步一步来的，刚开始第一个版本一定是粗糙的，很多功能还没有，但是核心功能可以跑出来，但是因为一些功能的不完善，只能内测，不能对外。

4、一开始是不支持全文检索的，我们仅仅支持like的搜索，like %keyword%，左右模糊匹配。我们不想引入全文检索框架，内测，要求的就是流程跑通即可，一些使用的用户体验可以降低要求，降低技术的复杂性，加快第一个版本开发出来的一个速度。

5、滚动广告那块，基于之前对首页的一个建议，那块建议就是要么是放一个广告，点击之后进入一个静态的广告页面，广告页面里可以有一些热门商品，点击热门商品进入我们的商品详情页即可；要么滚动广告里就是静态页面里做死一个商品，点击后直接进入商品详情页即可。

6、基于首页的分析，建议每个类目的热门商品，直接静态页面里做死一些商品，点击之后进入商品详情页。

7、这个配送至的功能，其实相对来说，我们不需要在一开始就做。为了优化快递物流的一个效率，其实在全国各地部署多个仓库，每个仓库支持一个区域。让你看一下， 你所在的那个区域对应的仓库有没有货，如果没有货，就不给你发货了。避免快递耗费的时间或者资金不大，可能你一个商品才50块钱，结果快递费要30块钱，这就尴尬了，从福建仓库一直运到西藏的仓库去。我们这里，一开始就是小电商，我们假设成，我们一开始就一个仓库，然后我们这个仓库是支持发全国各地的，基于第三方物流去发货的，下订单的时候，会根据商品选择好的一个物流运费的一个模板，根据那个模板会算出来我们的仓库发到你的地址，要多少运费，你自己去判断。建议说这个配送至就不做了。

7、将商品加入购物车的过程，实在是太简单了，需要完善一下具体的流程

8、我们已经假设了一个前提，刚开始做一个小型电商，很有可能就是面向一个区域的电商，刚开始主要做营销和宣传的可能就是公司和仓库所在地周围的一两个省份，或者是两三个省份，只需要一个仓库就可以了。就不需要所谓的区域内仓库是否有货，这边需要显示一下当前的商品总库存，当前要购买的这个数量在仓库中是否有货。比如说你总共库存就100件，你要购买200件，此时显示库存不足。

9、运费不在购物车商品列表上方单独去计算了，直接就是在购物车下方，计算出一个总价：商品总价 - 优惠金额 + 商品运费

10、活动库存和预售库存，先不用做，是配合以后的秒杀活动，拼团活动

11、提交订单确认页的细节大量的完善

12、正式提交订单之后，库存如何扣减和锁定的逻辑，需要完善

13、支付订单之后，库存扣减和锁定的逻辑，需要完善

14、调度中心，调度销售出库这块，没有看到比较清晰的一个将商品调度到对应货位的一个算法，而且我们这里第一个版本采取一个简化的一个策略，就是指定就将商品调度到一个仓库里去，因为一开始我们假设自己就一个仓库。电商系统开在南京，小电商平台，针对的就是南京市的一些大学生，在南京有一个仓库就可以了。

15、取消订单的时候，我们居然没有做这个提交订单的一个反向逻辑，需要将各个层次的库存重新改变一下，这里没有考虑到

16、运费模板，是在创建商品的时候，就会跟商品进行绑定的，但是我们没有定义清楚这个运费模板管理的一些细节

17、调度中心调度销售出库的细节没有完善

18、无论是采购入库单、采购结算单、销售入库单，这些单子，我们都没有记录创建时间、操作人、最近一次操作时间、审核人、审核时间。

19、整个销售出库流程中，很多细节都没有完善，所以这里都建议进行完善和细化

五、退货流程需求评审建议

1、申请退货操作这块还是太简单了，不够详细。同时申请退货的时候，除了选择一个下拉里列表中的原因以外，还得有用户自己填写的备注。

2、客服中心对退货工单的管理的流程，太模糊了，不够详细

3、所以说我这里讲解的时候的确是一边讲解，一边我自己其实也是在飞速的运转大脑，在考虑

4、调度退货入库那个环节，实际上是不做商品退货跟货位的关联的，入库的时候，由入库的工作人员自己根据最近货位的原则，去考虑如何将商品放到某一个货位中去

5、采购入库的时候，没有细化仓库和调度中心的库存

六、促销中心需求评审建议

1、站在架构角度提第一点建议，内测，建议是先促销活动不要针对会员级别，默认就是针对所有的人进行促销。而且实际上很多电商网站，大部分的促销活动，都是针对所有会员级别的

2、通过促销中心，发现了商品得多出来一个字段，上架时间。一开始简化一下，不加上架时间字段了。

3、促销中心的一些细节比较模糊，需要完善一下

4、建议将价格计算模块，放到订单中心里，不是商品中心

5、针对单个商品的优惠券，我们建议在这里暂时给砍掉，先不做，就做针对整个订单的优惠券。建议会员等级暂时别跟优惠券关联起来。建议，会员积分跟优惠券先不做绑定，建议就是免费发放的优惠券，删除推广范围这个字段。

6、我们先不做优惠券的删除

7、满减促销，其实还是要针对单个商品，范围可以是全部商品，还是要按照单个商品来计算，满赠促销，建议统一都是针对单个商品去算，这样比较简单一些

8、购物车那块，可以给每个商品下拉框选择某个促销活动，但是购物车页面不会现场计算，统一走进入订单确认页面的时候，统一来计算价格，附加赠品

七、会员中心需求评审建议

1、会员等级我们是属于暂缓型：我们会去计算会员的成长分数，也会去增加会员的等级，但是一开始不给什么特权，以后考虑清楚了再说。这个很符合很多小网站刚起步的一个策略。京东、猫眼，刚开始你都感受不到会员，系统在默默的给你累加这个会员的分数和等级。

2、建议评价送成长值，不设限最低金额

3、会员积分目前仅仅是做，但是不提供积分兑换礼品的服务和功能

八、评论中心需求评审建议

1、评论暂时不做追评估

2、WMS的库存调拨、库存盘点，我们这次不做，以后一定会做

3、支付对账，刚开始不做

# 需求分析

### 1.需求分析文档

1、引言

1.1 编写目的

需求分析文档用于对电商系统v1.0的需求文档进行分析，然后站在架构师的角度，去梳理清楚整个系统的功能组成以及业务流程。主要关注的点还是在业务层面，暂时不会考虑过多的技术。但是也还是会从技术层面去进行一些考量。

1.2 面向对象

该文档编写出来以后，面向的主要是技术团队的同学，包括架构师、高级工程师、初中级工程师。

1.3 参考文档

1、《电商系统v1.0产品需求文档》，具体参加项目附件

2、概述

2.1 开发意图

该电商系统完成开发之后主要针对下面的3个场景：

1、可以对商品的采购和仓储进行管理，让公司可以采购商品到对应的仓库中去

2、可以对有的商品、会员、订单、支付、评论、促销等各种电商网站的核心功能进行管理

3、可以让电商网站的用户来网站中浏览和购买商品

2.2 功能结构图

2.3 功能简介

2.3.1 权限中心

主要是对电商系统的使用权限进行控制的，可以给每个电商公司的工作人员分配一个账号，接着给每个账号分配一个角色，每个角色可以分配一些权限。每个权限就代表了一个菜单、一个按钮、一个URL，控制公司里不同部门不同岗位的工作人员只能使用电商系统中一部分的功能，跟他的岗位相关的这些功能。

2.3.1.1 权限管理

对电商系统里的权限数据进行维护和管理

2.3.1.2 角色管理

对电商系统里的角色数据进行维护和管理

2.3.1.3 账号管理

对电商系统里的账号数据进行维护和管理

2.3.1.4 权限控制

对电商系统里的左侧菜单栏的展示，以及每个后台界面中的按钮的显示，URL请求访问，进行权限的控制

2.3.2 商品中心

主要就是负责对电商网站中的商品数据进行相关的维护和管理，有了商品数据之后，我们才可以执行后台仓库的商品采购，包括将商品数据提供出去给前台的页面展示，让用户来浏览商品和查看。

2.3.2.1 属性管理

可以管理商品的属性数据

2.3.2.2 类目管理

可以管理商品的类目数据

2.3.2.3 品牌管理

可以管理商品的品牌数据

2.3.2.4 商品管理

可以管理商品的商品本身的数据

2.3.3 采购中心

负责维护供应商的数据，还有就是负责维护采购单的数据，可以创建采购单将我们需要的商品采购入库

2.3.3.1 供应商管理

主要就是维护和管理供应商的数据和绩效

2.3.3.2 采购单管理

主要是可以进行采购开单，开单之后就可以发送采购单给供应商来采购商品到我们的仓库中去

2.3.4 WMS

负责仓库管理，包括了仓库的基础数据的管理（仓库信息和货位信息），采购入库、销售出库、退货入库、仓库库存的管理

2.3.4.1 仓库信息管理

负责管理仓库的相关数据

2.3.4.2 货位信息管理

负责管理仓库中的货位相关的数据

2.3.4.3 采购入库单管理

采购开单之后，会同步采购入库单到这里来，在接收到供应商的发货之后，需要去维护采购入库单

2.3.4.4 销售出库单管理

用户下订单支付之后，就会同步一个销售出库单过来，在接收到这个单子之后，需要去将订单中的商品进行出库发货

2.3.4.5 退货入库单管理

用户申请退货，并且寄还商品到客服中心之后，会启动退货入库的流程

2.3.4.6 仓库库存管理

对仓库中的每个商品的库存，以及每个货位中每个商品的库存，进行管理

2.3.5 会员中心

2.3.5.1 会员注册

支持用户基于手机号直接进行注册

2.3.5.2 会员登录

支持基于之前注册的账号来登录，或者是基于微信等第三方方式来登录

2.3.5.3 会员个人信息

可以查看和设置会员的个人信息

2.3.5.4 会员等级管理

可以根据会员在网站中的不同操作，完成会员成长值的增减，同时完成维护会员的等级，完成维护会员成长值变更的明细

2.3.5.5 会员积分管理

可以根据会员在网站中的不同操作，完成会员积分的增减，同时完成维护会员的积分增加明细

2.3.6 商品展示

2.3.6.1 商品搜索

可以在网站的首页对商品执行搜索操作

2.3.6.2 品类导航

可以在网站的首页对品类进行导航

2.3.6.3 商品列表页

搜索商品，或者是品类导航，都会进入商品列表页

2.3.6.4 商品详情页

对商品列表页中的每个商品，都可以进入一个商品详情页

2.3.7 购物车

2.3.7.1 加入购物车

在商品详情页，可以点击加入购物车的按钮，将商品加入购物车中

2.3.7.2 查看购物车

查看购物车中的商品情况，可以选择一些商品去下订单

2.3.7.3 购物车结算

在购物车中选择了一些商品之后，就可以点击购物车结算按钮，进入订单确认页面

2.3.8 订单中心

2.3.8.1 生成订单

在订单确认页中完成订单确认之后，可以提交订单

2.3.8.2 订单列表

用户可以在订单列表页中查看自己的订单

2.3.8.3 订单详情

用户在订单列表页中选择某个订单，可以查看订单的详细信息

2.3.8.4 取消订单

用户可以选择手动取消某个未付款的订单，同时也可以由系统在24小时之后启动取消这个未付款的订单

2.3.8.5 订单支付

用户可以选择为这个订单支付对应的金额

2.3.8.6 更新订单状态

在对应的一些操作发生的时候，会来更新订单的状态

2.3.8.7 查看物流进度

用户在付款之后，可以查看物流的进度

2.3.8.8 确认收货

用户在收到货品之后，可以手动点击确认收货，也可以等待7天之后由系统自动确认收货

2.3.8.9 申请退货

用户在收到商品之后，如果不满意可以申请退货

2.3.8.10 价格计算

在订单的确认页面中，会根据订单的总金额，每个商品使用的促销活动，对订单使用的优惠券，运费，去计算出来订单最后的一个总金额

2.3.9 支付中心

2.3.9.1 对接第三方支付

在用户支付订单的时候，可以对接微信/支付宝来支付

2.3.9.2 支付交易流水管理

每次用户支付的时候，都需要去插入一笔交易流水，可以让后台管理人员查看交易的流水

2.3.10 物流中心

2.3.10.1 运费模板管理

每个商品都会关联一个运费模板

2.3.10.2 运费计算

在用户购买商品的时候，会根据这个运费模板去计算运费

2.3.10.3 获取物流单

在用户支付之后，调度中心调度发货的时候，会对这个订单跟物流中心通信，要求跟第三方物流商系统通信，申请一个物流单号

2.3.10.4 物流追踪

用户支付之后，可以查看物流的进度

2.3.11 评论中心

2.3.11.1 发表评论

用户购买商品之后，可以手动发表评论，也可以由系统在30天之后自动发表评论

2.3.11.2 评论管理

管理员可以在后台对评论进行一个审核和管理

2.3.11.3 评论前台展示

在商品详情页中，会展示所有的评论

2.3.12 促销中心

2.3.12.1 促销活动管理

可以管理电商网站中的促销活动的数据

2.3.12.2 优惠券管理

可以管理电商网站中的优惠券的数据

2.3.13 客服中心

2.3.13.1 退货工单管理

在用户申请退货的时候，由客服去管理对应的退货工单

2.3.14 财务中心

2.3.14.1 采购结算单管理

在采购入库完成之后，会有一个采购结算单，可以管理这块东西

2.3.14.2 供应商结算管理

在采购结算单完成审核之后，会周期性的给供应商打款结算

2.3.14.3 物流公司打款管理

在销售的时候，完成销售出库了，需要给物流公司打款

2.3.14.4 退货打款管理

在用户申请退货之后，并且将商品寄送到客服中心之后，会进行退货打款

2.3.15 调度中心

负责将采购入库、销售出库、退货入库，调度到仓库中去执行

2.3.16 库存中心

负责管理商品的库存

3、用例图

3.1 权限中心

3.1.1 用例图

3.1.2 用例描述

所有的用例在需求文档中，都已经将用例对应功能说的较为明确，而且功能运行流程也比较清晰，所以不再这里赘述多余的描述了，避免跟需求文档重复

3.2 商品中心

3.2.1 用例图

3.2.2 用例描述

参考需求文档即可

3.3 采购中心

3.3.1 用例图

3.3.2 用例描述

参考需求文档即可

3.4 WMS

3.4.1 用例图

3.4.2 用例描述

参考需求文档即可

3.5 会员中心

3.5.1 用例图

3.5.2 用例描述

参考需求文档即可

3.6 商品展示

3.6.1 用例图

3.6.2 用例描述

参考需求文档即可

3.7 购物车

3.7.1 用例图

3.7.2 用例描述

参考需求文档即可

3.8 支付中心

3.8.1 用例图

3.8.2 用例描述

参考需求文档即可

3.9 订单中心

3.9.1 用例图

3.9.2 用例描述

参考需求文档即可

3.10 物流中心

3.10.1 用例图

3.10.2 用例描述

参考需求文档即可

3.11 评论中心

3.11.1 用例图

3.11.2 用例描述

参考需求文档即可

3.12 促销中心

3.12.1 用例图

3.12.2 用例描述

参考需求文档即可

3.13 客服中心

3.13.1 用例图

3.13.2 用例描述

参考需求文档即可

3.14 财务中心

3.14.1 用例图

3.14.2 用例描述

参考需求文档即可

3.15 调度中心

3.15.1 用例图

3.15.2 用例描述

3.15.2.1 调度销售出库

1、简单描述

在用户下了订单之后，并且对订单完成支付之后，订单中心就会通知调度中心，来调度这个订单中的商品从仓库里面发货

2、事件流描述

（1）创建销售出库单

（2）创建发货单

（3）跟物流中心通信，让物流中心去跟第三方物流厂商通信，获取到一个物流单

（4）同步销售出库单、发货单、物流单到WMS

3、泳道图

3.16 库存中心

3.16.1 用例图

3.16.2 用例描述

4、领域类图

领域类图，一般就是从系统间的调用和流转，使用的核心数据类

订单类，就是一个典型的领域类

一般来说，领域类如何抽象，其实就是将需求文档中比较核心的那些数据抽象成领域类，比如订单，库存调拨单，出库单，入库单

这边是可以将一个较为复杂的领域类图拆分为多个领域类，比如说订单主信息，订单项信息，订单优惠信息

4.1 权限中心

4.2 商品中心

4.3 采购中心

4.4 WMS中心

4.5 会员中心

4.6 购物车

4.7 支付中心

4.8 订单中心

4.9 物流中心

4.10 评论中心

4.11 促销中心

4.12 客服中心

4.13 财务中心

4.14 调度中心

4.15 库存中心

# 系统设计

### 1.概要设计文档

1、引言

1.1 编写目的

编写概要设计文档，是为了指导后续的详细设计

1.2 面向对象

架构师、高级工程师、初中级工程师

1.3 参考文档

1、《电商系统v1.0版本产品需求文档》

2、《电商系统v1.0版本需求分析文档》

2、逻辑架构

2.1 逻辑架构图

2.2 设计细节

2.2.1 Web服务器

采用tomcat作为web服务器，不引入apache或者是nginx这种服务器，因为第一个版本，预计的用户数量也就是100个内测用户，并发量基本低于1/s。系统主要是为了跑通咱们的系统逻辑，进行内测。所以说为了开发和部署的方便以及效率起见，直接采用tomcat作为web服务器。

2.2.2 业务系统

直接将16个中心（权限中心、商品中心、采购中心、WMS中心、会员中心、商品查询、购物车、支付中心、订单中心、物流中心、评论中心、促销中心、客服中心、财务中心、调度中心、库存中心）全部放在一个单块应用中。

不做任何的系统拆分，全部采取B/S架构，接口对外提供服务。因为刚开始我们开发人员很少，不需要做太多的服务拆分，全部耦合在一个服务中，开发所有的代码，效率反而是最高的。

2.2.3 脚手架框架

采用目前业界最新最热门最流行的spring boot技术，作为脚手架框架，利用spring boot与其他的框架技术快速的整合。同时spring boot的可扩展性非常好，未来如果要用到缓存、mq等其他的技术，都可以快速的跟spring boot脚手架进行整合。

而且，团队已经初步对spring boot完成了技术调研，spring boot 20%的核心功能都已经掌握的很扎实了。

2.2.4 MVC框架

采取业界最流行的spring web mvc框架即可

2.2.5 IOC/AOP框架

采取业界最流行的spring core框架即可

2.2.6 ORM框架

采取业界最流行的mybatis3框架，不采用纯粹的ORM框架，hibernate，是因为类似hinernate那样的框架太重了，黑盒，自动生成的那个SQL性能较差。所以不建议采用hibernate。反而是mybatis框架基本可以自己手写sql语句，灵活，通用，很方便。

2.2.7 数据库

采用MySQL作为数据库，因为oracle数据库到了后期使用要付费，费用高昂，而且扩展性不是很好。目前互联网行业最通用的都是采用mysql数据库，哪怕是后面数据量大了，要分库分表，也有很多成熟的方案可以用。

2.2.8 基础设施

机器，网络，基础设施，采用阿里云，因为目前行业里国内，基本上就是这个阿里云的产品最好，稳定性，技术支持能力最好。我们作为一个初创型团队，不应该直接自己花很多的钱去采购和运维管理自己的服务器，那样的话成本太高了，而且很麻烦。

2.2.9 日志框架

采用spring boot默认支持的logback作为日志框架即可

2.2.10 系统监控

第一个版本主要是内测，不需要复杂的系统监控，只需要使用spring boot actuator提供的简单的健康检查监控即可。

3、运行架构

3.1 系统核心流程

3.1.1 采购流程时序图

3.1.2 购物流程时序图

3.1.3 退货流程时序图

3.2 功能时序图

功能的运行流程与需求文档中几乎保持一致，所以在这里就不画了

4、物理架构

4.1 软件架构

4.2 硬件架构

4.2.1 开发环境

4.2.2 集成测试环境

4.2.3 系统测试环境

4.2.4 验收测试环境

4.2.5 线上环境

### 2.概要设计文档技术评审

1、并发层面的问题

如果未来并发量持续增长，tomcat服务器可以部署集群+前面的负载均衡设备。

但是mysql是单库单表，会有并发的瓶颈，一般来说，mysql单服务器承载的并发不能超过2k。如果mysql单库的写并发到1.5k的时候，建议就要分库了；如果mysql单库的读并发到1.5k的时候，建议就要挂主从架构，读写分离，挂多个从库。

所以目前架构设计中的mysql单库单表可能未来会是一个风险点。但是现在系统刚起步，可以先这么做，但是以后要去考量这个事情。

2、伸缩性

tomcat是没有问题的，只要加机器就可以了。

但是你的业务系统，是否具备伸缩性，要仔细去考量一下。就是说，如果你的设计里面，你的业务系统必须用单个服务实例承接所有的请求才能正常工作，一旦你业务系统部署多个实例，请求落到不同的服务实例上，会导致请求处理出错，那么就意味着你的业务系统只能部署单个实例。

如果是这样子的话，那你的业务系统就不具备可伸缩的能力，因为他是没有办法去扩容的。

但是这里主要是提醒一下，在后面做详细设计的时候，务必要考量到这一点。

举个例子吧，假设，某个订单，被你的某个服务实例在内存中维护了一个什么状态。此时就导致，如果这个订单相关的请求落到其他的服务实例上去，会导致你的整个程序出错。那么此时，你的系统就是不可伸缩的。你只能要求所有的请求都要落到一个服务实例上，才能完成正确的操作，那你不能扩容了。

mysql，单库单表，是典型的不可伸缩。你即使加更多的mysql服务器，也是搞不定的。所以以后要让mysql可伸缩，必须结合业务去设计对应的分库分表的mysql架构。

3、可用性

（1）tomcat+业务系统的部署，都是单机部署的，那么意味着，只要这个机器，或者是这个机器上的tomcat，或者是这个tomcat里部署的业务系统，挂掉了，那么整个系统就挂掉了，可用性很差

（2）mysql，只要一个mysql宕机了，那么数据库就挂了，一旦数据库挂了，那么整个系统就挂掉了，可用性很差

所以在现在初期，先不用考虑，但是以后架构必须得去考量这个可用性的问题

4、扩展性

扩展性很差，因为你如果要大团队协作，多人开发，会发现说，这里的模块耦合太严重了。都耦合在了一个单块应用中，到了后期，几十个人修改一个工程，大量的代码冲突，不同的项目不同的版本之间的测试、开发的排期大量的冲突，互相之间占用测试环境，你等我，我等你。然后的话，上线，也是的。

假设，我们现在有3个项目并行在做，分别是3个小team在做，一起修改一个单块应用。然后其中一个项目的上线时间定在了07.01，那么这就意味着什么呢？项目二的上线时间就不能定在07.01，如果项目二和项目一同一天上线，就意味着大家要耦合在一起做测试啊什么的，是不可能的。这样的话，就导致项目二只能定在07.02，然后同理，项目三只能定在07.03.

这个还只是3个项目，如果是30个项目呢？上百人开发。

比如你临时修复了一个bug，要上线，这个时候怎么办？可能有其他团队正要上线呢，你还得等他们先上线，然后你再上线呢？

暂时不用解决，1+4的一个小team，单块应用。10个人以上，那就不太合适了。

5、安全性

目前没有考虑任何的安全性的措施，裸奔。内测，仅仅面向部分少量的用户，用一些测试数据来内测，所以还好。

6、高性能

性能肯定的是有问题的，大量的全部基于数据库来操作，没有任何的缓存，或者是MQ介入，那么性能肯定是会差很多的

7、稳定性

系统会不会频繁的出一些bug和未知的一些问题，排查问题的效率和解决问题的效率怎么样？日志，通过日志可以排查和解决问题。

但是监控这一块，做的比较low，只能通过spring boot提供的接口，人肉时不时上去看看，调用一下接口看一眼。没有那种自动化的监控系统，可以看到问题，然后直接发短信、邮箱通知RD。

### 3.权限中心详细设计文档

1、数据架构 1.1 数据库ER模型 1.2 数据库逻辑模型 1.2 数据库物理模型 2、接口 2.1 权限管理 2.1.1 根权限列表查询 （1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/priority/roots/

（3）接口描述

查询所有的根权限

（4）输入

无

（5）输出

2.1.2 子权限列表查询 （1）接口所属的类

（3）接口定义

GET /api/v1.0/auth/priority/children/{id}

（3）接口描述

查询某个权限的子权限

（4）输入

权限id

（5）输出 2.1.3 添加权限 （1）接口所属的类

（4）接口定义

POST /api/v1.0/auth/priority/

（3）接口描述

添加权限

（4）输入

（5）输出 2.1.4 查询权限 （1）接口所属的类

（5）接口定义

GET /api/v1.0/auth/priority/{id}

（3）接口描述

查询某个权限

（4）输入

权限id

（5）输出 2.1.5 更新权限 （1）接口所属的类

（6）接口定义

PUT /api/v1.0/auth/priority/{id}

（3）接口描述

更新权限

（4）输入

权限id

（5）输出 2.1.6 删除权限 （1）接口所属的类

（7）接口定义

DELETE /api/v1.0/auth/priority/{id}

（3）接口描述

删除权限

（4）输入

权限id

（5）输出 2.2 角色管理 2.2.1 查询角色列表 （1）接口所属的类

（8）接口定义

GET /api/v1.0/auth/role/

（3）接口描述

查询角色列表

（4）输入

（5）输出 2.2.2 添加角色 （1）接口所属的类

（9）接口定义

POST /api/v1.0/auth/role/

（3）接口描述

添加角色

（4）输入

（5）输出 2.2.3 查询角色 （1）接口所属的类

（10）接口定义

GET /api/v1.0/auth/role/{id}

（3）接口描述

添加角色

（4）输入

角色id

（5）输出 2.2.4 更新角色 （1）接口所属的类

（11）接口定义

PUT /api/v1.0/auth/role/{id}

（3）接口描述

更新角色

（4）输入

（5）输出 2.2.5 删除角色 （1）接口所属的类

（12）接口定义

DELETE /api/v1.0/auth/role/{id}

（3）接口描述

删除角色

（4）输入

角色ID

（5）输出 2.2.6 启用/停用角色 （1）接口所属的类

（13）接口定义

PUT /api/v1.0/auth/role/enabled/{id}

（3）接口描述

更新角色的启用状态

（4）输入

（5）输出 2.3 账号管理 2.3.1 查询账号列表 （1）接口所属的类

（14）接口定义

GET /api/v1.0/auth/account/

（3）接口描述

查询账号列表

（4）输入

（5）输出 2.2.2 添加账号 （1）接口所属的类

（15）接口定义

POST /api/v1.0/auth/account/

（3）接口描述

添加账号

（4）输入

（5）输出 2.2.3 查询账号 （1）接口所属的类

（16）接口定义

GET /api/v1.0/auth/account/{id}

（3）接口描述

查询账号

（4）输入

账号id

（5）输出

2.2.4 更新账号 （1）接口所属的类

（17）接口定义

PUT /api/v1.0/auth/account/{id}

（3）接口描述

更新账号

（4）输入

（5）输出 2.2.5 删除账号 （1）接口所属的类

（18）接口定义

DELETE /api/v1.0/auth/account/{id}

（3）接口描述

删除账号

（4）输入

账号ID

（5）输出 2.2.6 启用/停用账号 （1）接口所属的类

（19）接口定义

PUT /api/v1.0/auth/account/enabled/{id}

（3）接口描述

更新账号的启用状态

（4）输入

（5）输出 2.2.7 修改密码 （1）接口所属的类

（20）接口定义

PUT /api/v1.0/auth/account/password/{id}

（3）接口描述

更新账号的密码

（4）输入

（5）输出 2.4 权限控制 2.4.1 查询账号有权限的菜单树 上来先查询账号有权限的根菜单权限，显示在页面左侧的菜单栏里，如果用户点击某个菜单，异步加载那个菜单下面的子菜单即可

（1）接口所属的类

（21）接口定义

GET /api/v1.0/auth/priority/tree/authorized/?accountId=1

（3）接口描述

查询某个账号被授权的菜单树

（4）输入

账号ID

（5）输出 2.4.2 查询账号对某个权限是否授权 在页面上，显示了某个按钮的时候，对那个按钮是否显示需要使用特殊的标签，在标签里给一个按钮对应的权限的编号，然后后台会去查询账号对这个编号的权限，是否有授权

（1）接口所属的类

（22）接口定义

GET /api/v1.0/auth/priority/authorized/{id}?accountId=1

（3）接口描述

查询某个账号对某个权限是否授权

（4）输入

权限ID、账号ID

（5）输出

{ "authorized": true // true是授权，false是未授权 } 2.4.3 请求URL权限控制 这一块接口，不是对外提供的web http接口，不是给其前端调用的，是给我们后面要写一个全局的过滤器，对所有的请求都要过滤，然后在过滤器中调用这里的接口，查看当前登录的这个用户是否有权限执行某个请求

（1）接口类

PriorityService

（2）接口定义

Boolean checkPriorityAuthorized(Long accountId, String url)

（3）接口描述

查询某个账号对某个权限是否授权

（4）输入

权限ID、账号ID

（5）输出

是否授权，true是授权，false是未授权 3、开发架构 3.1 实现类图 权限中心实现类图

将账号、角色、权限，相关的数据，通过享元模式，在内存里维护一份 3.2 包设计 com.zhss.eshop.auth.web com.zhss.eshop.auth.service com.zhss.eshop.auth.service.impl com.zhss.eshop.auth.dao com.zhss.eshop.auth.dao.impls com.zhss.eshop.auth.mapper com.zhss.eshop.auth.vo com.zhss.eshop.auth.dto com.zhss.eshop.auth.do com.zhss.eshop.auth.query 4、运行流程设计 4.1 权限管理 4.1.1 根权限列表查询 直接查询出来所有的根权限即可，就是没有parentId就是根权限。 4.1.2 子权限列表查询 根据parentId去查询某个权限的子权限即可 4.1.3 添加权限 将权限信息保存到数据库即可 4.1.4 查询权限 根据权限ID来查询即可 4.1.5 更新权限 根据权限ID来跟新即可 4.1.6 删除权限 这块必须要进行递归删除，也就是说，你要删除一个权限的话：

第一，你必须先删除最底层的子权限，然后一级一级往上删除，删除到当前的权限

第二，你除了删除权限之外，你还得care一下角色、账号跟权限之间的关联关系，我们要做一个check，也就是说，如果这个权限还跟有一些角色和账号跟之进行关联，就不能直接删除

第三，此处采用设计模式，组合模式+访问者模式，采用组合模式，在这里将权限组装成一颗树，或者是不用提前组装，就是不断的去递归动态组装出来一颗树也可以。然后对这颗树注入一个删除的visistor访问者，这样，以后我们还可以动态注入别的visitor来实现对这颗权限树的不同的操作。

第四，在对这棵树递归删除的过程中，如果发现某个权限还被别人给引用，此时要返回一个特殊的状态码，这个状态码要标明某一级权限还被某个角色或者是账号在引用，就不能直接这样删除，需要回滚整个事务。

我们在这里因为要采取设计模式，所以需要为了这块东西，单独设计一套类出来

这个场景，应该是完美的可以让我们后面去实践组合模式和访问者模式的一个场景，就是我们需要开发两个visitor，第一个visitor需要遍历所有子权限，判断是否有某个权限还被账号或者角色在关联着；第二个visitor，是如果全包所有的子权限都没有被别人在关联，那么就递归删除 4.2 角色管理 4.2.1 查询角色列表 根据筛选条件+分页查询角色即可 2.2.2 添加角色 （1）先添加角色 （2）添加角色和权限之间的关系 2.2.3 查询角色 （1）根据ID查询角色 （2）查询角色被授予的权限ID列表 2.2.4 更新角色 （1）更新角色 （2）将角色与权限的关联关系都删除 （3）重新插入角色与权限的关联关系 2.2.5 删除角色 （1）是否有账号关联了这个角色，如果有是不允许删除角色的 （1）删除角色跟权限的关联关系 （2）删除角色本身 2.2.6 启用/停用角色 （1）是否有账号关联了这个角色，如果有是不允许停用角色的 （2）更新角色的启用状态即可 4.3 账号管理 4.3.1 查询账号列表 根据筛选条件分页查询账号列表即可 4.3.2 添加账号 （1）添加账号 （2）添加账号和角色的关联关系 （3）添加账号和权限的关联关系 4.3.3 查询账号 （1）查询账号 （2）查询账号关联的角色id （3）查询账号关联的权限id 4.3.4 更新账号 （1）更新账号 （2）删除账号与角色的关联关系，再插入新的账号与角色的关联关系 （3）删除账号与权限的关联关系，再插入新的账号与权限的关联关系 4.3.5 删除账号 （1）删除账号与角色的关联关系 （2）删除账号与权限的关联关系 （3）删除账号本身 4.3.6 启用/停用账号 直接更新账号的状态即可 4.3.7 修改密码 直接更新账号的密码即可 4.4 权限控制 4.4.1 查询账号有权限的菜单树 我们这个是个后台系统，然后我们其实是会通过前面做好的权限管理模块，去录入我们系统的权限树，每个权限对应着一个菜单或者是一个按钮。因为一个菜单对应着一个模块，比如说品牌管理 - > 菜单，模块，但是点击品牌管理之后，进入了一个页面，页面里，可能会包含多个功能，比如说新增品牌，编辑品牌，删除品牌，每个功能都是一个按钮。

然后这个按钮，也是一个权限，如果你有这个权限就可以去看到和点击这个按钮。

菜单，也是一个权限，如果你对菜单有权限，你就可以看到这个菜单。

左侧，都有一个菜单树，菜单树的权限控制，根据当前登录的这个用户，查询到这个用户有权限的这个菜单树。

基于我们之前做好的那个组合模式+访问者模式的思路，在里面加入一个visitor就可以了，访问者就可以了。

（1）查询这个账号有权限的根菜单 （2）然后对每个根菜单，使用visitor去递归每个根菜单，对每个根菜单都去查询这个账号有权限的子菜单，填充为根菜单的子菜单 （3）以此类推，就可通过visitor得到一颗账号有权限的菜单树 4.4.2 查询账号对某个权限是否授权 在页面上，对每个按钮，都有一个标签，对这个按钮对应的权限的编号，去查询这个用户对这个编号的权限，有没有授权。

显示每个按钮之前，都发送一个请求到后端，来判断一下，用户对这个按钮是否有权限，如果没有权限的话，直接就不要显示这个按钮了。前端应该是知道每个按钮对应的这个权限的编号的

新建品牌 -> SAVE_BRAND -> 我们要看一下用户对这个编号的权限是否有授权，显示这个按钮，如果没有授权，这个按钮就不要显示了

（1）查询这个编号对应的权限 （2）查询这个账号对这个权限是否有授权，然后一条SQL，关联账号表、角色表、权限表，去查询 4.4.3 请求URL权限控制 如果有个坏蛋，不管什么菜单或者是按钮，直接自己在浏览器里构造访问某个功能的URL请求，直接就请求过来了

这一块接口，不是对外提供的web http接口，不是给其前端调用的，是给我们后面要写一个全局的过滤器，对所有的请求都要过滤，然后在过滤器中调用这里的接口，查看当前登录的这个用户是否有权限执行某个请求

（3）查询这个URL对应的权限 （4）查询这个账号对这个权限是否有授权，然后一条SQL，关联账号表、角色表、权限表，去查询 4.4.4 对权限进行缓存 基于享元模式，在纯jvm中进行缓存，权限数据，几乎是很少变化的。99%的情况下，直接访问缓存就可以了。数据量一般很小。权限数据访问频率很高的，因为用户随意出入系统，每次进来都要查询菜单，查询按钮，还要对请求进行认证。但是修改频率很低，一年也不会修改几次。

5、测试用例设计 5.1 单元测试用例设计 要求，就是对每个controller、service、dao组件的每个方法，都进行单元测试 5.2 冒烟测试用例设计 要求，是系统在本地运行起来，直接依赖了数据库之后，对controller层所有的接口访问都可以正常工作 6、日志设计 要求的是每一层，每一个类都捕获自己的异常，然后对异常要求必须打印详细的日志

### 4.商品中心详细设计文档

### 5.采购中心详细设计文档

### 6.WMS中心详细设计文档

### 7.会员中心详细设计文档

### 8.购物车详细设计文档

### 9.支付中心详细设计文档

### 10.订单中心详细设计文档

### 11.物流中心详细设计文档

### 12.评论中心详细设计文档

### 13.促销中心详细设计文档

### 14.客服中心详细设计文档

### 15.财务中心详细设计文档

### 16.库存中心详细设计文档

### 17.调度中心详细设计文档

### 18.详细设计文档技术评审

# 项目管理

## 项目进度计划

### 1.活动清单

### 2.网络图

### 3.甘特图

## 每周工作计划

### 1.第一周工作计划

## 个人周报

## 项目周报

# 编码开发

# 单元测试

## 单元测试覆盖率报告

# 冒烟测试

## 冒烟测试文档

# 集成测试

### 第1轮集成测试文档

# 系统测试

### 第1轮系统测试文档

# 验收测试

### 验收测试报告

# 系统上线

### 1.系统上传checklist

1、RD自测报告

1.1 小C的自测报告

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果

2、系统测试报告

2.1 集成测试报告

（1）第一轮集成测试报告

（2）第二轮集成测试报告

（3）第三轮集成测试报告

2.2 系统测试报告

（1）第一轮系统测试报告

（2）第二轮系统测试报告

（3）第三轮系统测试报告

2.3 验收测试报告

（1）验收测试报告

这份文档，需要由项目的架构师/leader，来在上线之前，收拢好，编写好，里面应该包含所有的报告，发给技术总监。技术总监是不负责一线的带项目，一线带项目的一般都是所谓的架构师，或者是技术经理。

### 2.系统上线步骤

1、数据库初始化

（1）小C和小D负责建库建表，建立对应的prod profile

（2）老A和老B负责检查所有的SQL语句是否使用了对应的表的索引

（3）老K负责最后确认

2、部署系统到线上机器

（1）先对master分支打一个tag，标注我们的这个v1.0.0的版本

（2）基于master分支的代码和prod profile将完整的代码，打成jar包

（3）然后用scp将jar包上传到zhss-eshop-prod机器上去

（4）使用java -jar命令启动线上系统

3、线上验证

（1）观察系统是否将日志打印到了我们指定的日志文件中去

（2）观察系统是否打印出了我们指定的系统初始化的日志

（3）PM负责在线上系统，使用测试账号，将核心主流程执行一遍，确认无误，上线成功

git tag -d <tagname> git push origin :refs/tags/<tagname>