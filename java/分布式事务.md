# 分布式事务

### 1.CAP

CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（ Consistency ） 、可用性（ Availability ） 和分区容错性（Partition tolerance）三者不可兼得。

- 一致性：在分布式系统的所有数据备份中，在同一时刻是否有同样的值（等同于所有节点都访问同一份最新的数据副本）。
- 可用性：在集群中一部分节点发生故障后，集群整体能否响应客户端的读写请求（对数据更新具备高可用性）。
- 分区容错性：系统如果不能在时限内达成数据的一致性，就意味着发生了分区，必须就当前操作在C和A 之间做出选择。以实际效果而言，分区相当于对通信的时限要求。

### 2.两阶段提交协议

分布式事务指涉及操作多个数据库的事务，在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。 二阶段提交（Two-Phase Commit）指在计算机网络及数据库领域内，为了使分布式数据库的所有节点在进行事务提交时都保持一致性而设计的一种算法。在分布式系统中，每个节点虽然都可以知道自己的操作是否成功，却无法知道其他节点的操作是否成功。 在一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果，并最终指示这些节点是否真正提交操作结果（比如将更新后的数据写入磁盘等）。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈决定各参与者是提交操作还是中止操作。

1.Prepare（准备阶段）

事务协调者（事务管理器）给每个参与者（源管理器）都发送Prepare消息，每个参与者要么直接返回失败（如权限验证失败），要么在本地执行事务，写本地的redo和undo日志但不提交，是一种“万事俱备，只欠东风”的状态。

2.Commit（提交阶段）

如果事务协调者收到了某个事务参与者的事务操作失败回复或等待事务参与者反馈超时，则事务协调者为每个事务参与者发送回滚（ Rollback ）消息，事务参与者再执行回滚本地事务操作；如果事务协调者在规定时间内收到了所有事务参与者的成功回复， 则发送提交（ Commit）消息，事务参与者在本地执行事务提交操作并执行事务。

两阶段提交的目的是尽可能晚地提交事务，在提交事务前尽可能确保每个数据库都正常运行，并确保该事务对应的SQL 语句能够在每个数据库上都正常执行，同时将数据的写日志操作提前完成，防止事务执行过程中发生意外。事务的执行和释放是在JPA 中基于锁来实现控制的。

### 3.两阶段提交的缺点

两阶段提交的缺点如下。

- 同步阻塞问题：在执行过程中，所有参与者的任务都是阻塞执行的。
- 单点故障：所有请求都需要经过协调者，在协调者发生故障时，所有参与者都会被阻塞。
- 数据不一致：在二阶段提交的第2 阶段，在协调者向参与者发送Commit（提交）请求后发生了局部网络异常，或者在发送Commit请求过程中协调者发生了故障，导致只有一部分参与者接收到Commit请求，于是整个分布式系统出现了数据不一致的现象，这也被称为脑裂。
- 协调者宕机后事务状态丢失：协调者在发出Commit消息之后宕机，唯一接收到这条消息的参与者也宕机，即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没有人知道事务是否已被提交。

### 4.三阶段提交协议

三阶段提交（Three-Phase Commit），也叫作三阶段提交协议（Three-Phase Commit Protocol），是二阶段提交（2PC）的改进版本。具体改进如下。

- 引入超时机制：在协调者和参与者中引入超时机制，如果协调者长时间接收不到参与者的反馈，则认为参与者执行失败。
- 在第1 阶段和第2 阶段都加入一个预准备阶段，以保证在最后的任务提交之前各参与节点的状态是一致的。也就是说，除了引入超时机制，三阶段提交协议（3PC）把两阶段提交协议（2PC）的准备阶段再次一分为二， 这样三阶段提交就有CanCommit 、PreCommit 、DoCommit三个阶段。

1.CanCommit阶段

协调者向参与者发送Commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

2.PreCommit阶段

协调者根据参与者的反应来决定是否继续进行，有以下两种可能。

- 假如协调者从所有参与者那里获得的反馈都是Yes响应，就预执行事务。
- 假如有任意参与者向协调者发送了No响应，或者在等待超时之后协调者都没有接收到参与者的响应，则执行事务的中断。

3.DoCommit阶段

该阶段进行真正的事务提交，主要包括：协调者发送提交请求，参与者提交事务，参与者响应反馈（在事务提交完之后向协调者发送Ack响应），协调者确定完成事务。

### 5.柔性事务

在分布式数据库领域，基于CAP理论及BASE理论，阿里巴巴提出了柔性事务的概念。BASE 理论是CAP 理论的延伸， 包括基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）三个原则，并基于这三个原则设计出了柔性事务。 我们通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型。

两阶段型事务

指分布式事务的两阶段提交，对应技术上的XA和JTA/JTS，是分布式环境下事务处理的典型模式。

TCC型事务（Try、Confirm、Cancel）

为补偿型事务，是一种基于补偿的事务处理模型。服务器A发起事务，服务器B参与事务，如果服务器A的事务和服务器B的事务都顺利执行完成并提交，则整个事务执行完成。但是，如果事务B执行失败，事务B本身就回滚，这时事务A已被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作进行反操作，恢复到未执行前事务A的状态。需要注意的是，发起提交的一般是主业务服务，而状态补偿的一般是业务活动管理者，因为活动日志被存储在业务活动管理中，补偿需要依靠日志进行恢复。TCC事务模型牺牲了一定的隔离性和一致性，但是提高了事务的可用性。

异步确保型事务

指将一系列同步的事务操作修改为基于消息队列异步执行的操作，来避免分布式事务中同步阻塞带来的数据操作性能下降。例如在写业务数据A触发后将执行以下流程。 （1）业务A的模块在数据库A上执行数据更新操作。 （2）业务A调用写消息数据模块。 （3）写消息日志模块将数据库的写操作状态写入数据库A中。 （4）写消息日志模块将写操作日志发送给消息服务器。 （5）读消息日志模块接收操作日志。 （6）读消息数据调用写业务B的模块。 （7）写业务B更新数据到数据库B。 （8）写业务数据B的模块发送异步消息更新数据库A中的写消息日志状态，说明自己已经完成了异步数据更新操作。

最大努力通知型事务

也是通过消息中间件实现的，与前面异步确保型操作不同的是：在消息由MQ服务器发送到消费者之后，允许在达到最大重试次数之后正常结束事务，因此无法保障数据的最终一致性。写业务数据A在更新数据库后调用写消息日志将数据操作以异步消息的形式发送给读消息日志模块；读消息日志模块在接收到数据操作后调用写业务B写数据库。和异步确保型不同的是，数据库B在写完之后将不再通知写状态到数据库A，如果因为网络或其他原因，在第4步没有接收到消息，则消息服务器将不断重试发送消息到读消息日志，如果经过 N次重试后读消息日志还是没有接收到日志，则消息不再发送，这时会出现数据库A和数据库B数据不一致的情况。最大努力型通知事务通过消息服务使分布式事务异步解耦，并且模块简单、高效，但是牺牲了数据的一致性，在金融等对事务要求高的业务中不建议使用，但在日志记录类等对数据一致性要求不是很高的应用上执行效率很高。

### 6.事务

事务是Web应用中不可缺少的组件模型，它保证了用户操作的原子性（Atomicity)、一 致性（Consistency ）、隔离性（Isolation ）和持久性（Durability)。事务分本地事务和分布式事务两种。

本地事务

本地事务基于数据库资源实现，事务串行地在JDBC连接上执行，本地事务将事务处理局限在当前事务资源内。其特点是使用灵活但无法支持多数源事务操作。在数据库连接中使用本地事务的代码示例如下：

```html
try{
    conn=getDataSource().getConnection();
    //将自动提交设置为false
    //若设置为true，则数据库将会把每一次数据更新认定为一个事务并自动提交
    conn.setAutoCommit(false); 
    //提交事务
    conn.commit();
} catch(SQLException sqle) { 
    //异常回滚：发生异常，回滚在本事务中的操作  
    conn.rollback(); 
```

在上述代码中，首先通conn.seAutoCommit(false）设置数据库连接为非自动提交，然后分别提交了两条更新语句，最后通过conn.commit（）提交事务。如果数据库操作成功，则事务完成；如果操作失败，则通过conn.rollback（）回滚事务。

分布式事务

分布式事务（Distributed Transaction ）提供了跨数据库的分布式事务操作的数据一致性，跨数据库的一致性包含同一类型数据库的多个数据库实例服务的一致性（例如多个MySQL的事务一致性）和多个不同类型数据库的数据一致性（例如MySQL和Oracle之间的事务一致性）两种情况。

Java事务编程接口（Java Transaction API, JTA ）和Java事务服务(Java Transaction Service, JTS)为 J2EE平台提供了分布式事务服务。分布式事务包括一个事务管理器( Transaction Manager)和一个或多个支恃XA协议（XA协议是由X/Open组织提出的分布式事务的规范，XA规范主要定义了事务管理器和资源管理器之间的接口）的资源管理器（Resource Manager）。 其中，事务管理器负责所有事务参与单元的协调与控制，资源管理器负责不同的数据库具体的事务执行操作。具体使用代码如下：

```html
public void transferAccount() {     
    UserTransacton userTx = null; 
    //step1 ：定义a.b数据库连接
    Connection connA = null; 
    Statement stmtA = null; 
    Connection connB = null; 
    Statement stmtB = null; 
    try{
        //step2 ：获得Transaction管理对象
        userTx = (UserTransaction)getCoηtext ().lookup (”java:comp/UserTransaction"); 
        connA = getDataSourceA() .getConnection() ;//step 3.1：从数据库中取得数据库连接
        connB = getDataSourceB() .getConnection();//step 3.2：从数据库中取得数据库连接
        userTx.begin (); //step 4：启动事务
        stmtA = connA.createStatement();//step 5.1：操作库数据：将A账户中的金额减少500
        stmtA.execute (”update t_account set amount = amount -500 where account_id =’A’”); 
        //step 5.2：操作B库数据：将B账户中的金额增加500
        stmtB = connB.createStatement();    
        stmtB.execute (”update t_account set amount = amount + 500 where account_id =’B’”) ; 
        userTx.commit();//step6： 提交事务
        //提交事务：转账的两步操作同时执行（数据库A和数据库B中的数据被同时更新）
    } catch(SQLException sqle) { 
        //step 7：回滚事务，发生异常，回滚在本事务中的操作
        userTx.rollback(); //数据库A和数据库B中的数据更新被同时撤销
```

在上述代码中，首先定义了一个分布式事务管理器UserTransacton，然后定义了2个连接池connA和connB，接着通过userTx.begin（）启动事务并向两个数据库连接提交2个更新请求，最后通过userTx.commit（）统一提交事务。如果执行成功，则事务完成；如果失败，则通过userTx.rollback（）回滚事务。