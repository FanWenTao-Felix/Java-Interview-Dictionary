# 数据结构

## 1.常用数据结构

数据结构指数据的存储、组织方式。

### 栈

顶部元素插入和取出快。

除顶部元素外，存储其他元素都很慢。

### 队列

顶部元素插入和尾部元素取出快。

存储其他元素很慢。

### 链表

插入和删除都快。

查找慢。

### 二叉树

插入、删除、查找都快。

删除算法复杂

### 红黑树

插入、删除、查找都快。

算法复杂

### 散列表

插入、删除、查找都快。

数据散列，对存储空间有浪费

### 位图

节省存储空间

不方便描述复杂的数据关系

## 2.栈

栈（Stack）又名堆栈，是允许在同一端进行插入和删除操作的特殊线性表。其中，允许进行插入和删除操作的一端叫作栈顶（Top），另一端叫作栈底（Bottom），栈底固定，栈顶浮动。栈中的元素个数为零时，该栈叫作空栈。插入一般叫作进栈（Push），删除叫作退栈（Pop）。栈也叫作后进先出（FILO-First In Last Out）的线性表。

要实现一个栈，需要先实现以下核心方法。

- push()：向栈中压入一个数据，先入栈的数据在最下边。
- pop()：弹出栈顶数据，即移除栈顶数据。
- peek()：返回当前的栈顶数据。

![](D:\workspace\Java-Interview-Offer\images\数据结构001.png)

## 3.栈的实现

（1）定义栈的数据结构：

```
public class Statck<E>{
	private Object[] data=null;
	private int maxSize=0;//栈的容量
	priavte int top=-1;//栈顶的指针
	//构造函数，根据指定的size初始化栈
	Statck(){
		this(10);//默认的栈大小为10
	}
	Statck(int initialSize){
		if(initialSize>=0){
			this.maxSize=initialSize;
			data=new Object[initialSize];
			top=-1;
		}else{
			throw new RuntimeException("初始化大小不能小于0:"+initialSize);
		}
	}
}
```

以上代码定义了一个Stack的类，用来存储栈的数据结构；定义了一个数组data，用来存储栈中的数据；定义了maxSize，表示栈的最大容量；定义了top，表示栈顶数据的指针；

（2）数据入栈，向栈顶压入一个数据：

```
//进栈，第一个元素top=0；
public boolean push(E e){
	if(top==maxSize-1){
		throw new RuntimeException("栈已满，无法将元素入栈");
	}else{
		data[++top]=e;
		return true;
	}
}
```

以上代码定义了方法push()来向栈中压入数据，在数据入栈前首先判断栈是否满了，具体的判断依据为栈顶元素的指针位置等于栈的最大容量。注意，这里使用maxSize -1是因为栈顶元素的指针是从0开始计算的。在栈有可用空间时，使用data[++top]=e在栈顶（top位置）上方新压入一个元素并为top加1。

（3）数据出栈，从栈顶移除一个数据：

```
//弹出栈顶的元素
public E pop(){
	if(top==-1){
		throw new RuntimeException("栈为空");
	}else{
		return (E)data[top--];
	}
}
```

以上代码定义了方法pop()来从栈顶移除一个数据，移除前先判断栈顶是否有数据，如果有，则通过data[top--]将栈顶数据移出并给top减1。

（4）数据查询：

```
//查看栈顶元素但不溢出
public E peek(){
	if(top==-1){
		throw new RuntimeException("栈为空");
	}else{
		return (E)data[top];
	}
}
```

以上代码定义了方法peek()来取出栈顶的数据，在取出栈顶的数据前先判断栈顶的元素是否存在，如果存在，则直接返回栈顶元素（注意：这里没有对栈顶的元素进行删除），否则抛出异常。

## 4.队列

队列是一种只允许在表的前端进行删除操作且在表的后端进行插入操作的线性表。其中，执行插入操作的端叫作队尾，执行删除操作的端叫作队头。没有元素的队列叫作空队列，在队列中插入一个队列元素叫作入队，从队列中删除一个队列元素叫作出队。因为队列只允许在队头插入，在队尾删除，所以最早进入队列的元素将最先从队列中删除，所以队列又叫作先进先出（FIFO-first in first out）线性表。

要实现一个队列，需要先实现以下核心方法。

- add()：向队列的尾部加入一个元素（入队），先入队列的元素在最前边。
- poll()：删除队列头部的元素（出队）。
- peek()：取出队列头部的元素。

![](D:\workspace\Java-Interview-Offer\images\数据结构002.png)

## 5.队列的实现

（1）定义队列的数据结构：

```
public class Queue<E>{
	private Object[] data=null;
	private int maxSize=0;//队列的容量
	priavte int front;//队列头，允许删除
	priavte int rear;//队列尾，允许插入
	//构造函数，根据指定的size初始化栈
	public Queue(){
		this(10);//默认的队列大小为10
	}
	public Queue(int initialSize){
		if(initialSize>=0){
			this.maxSize=initialSize;
			data=new Object[initialSize];
			front=rear=0;
		}else{
			throw new RuntimeException("初始化大小不能小于0:"+initialSize);
		}
	}
}
```

以上代码定义了一个名为Queue的队列数据结构，并定义了用于存储队列数据的data数组、队列头位置标记front、队列尾位置标记rear、队列的容量maxSize。队列的默认长度为 10，在初始化时，front的位置等于rear的位置，都为 0；在有新的数据加入队列时，front的值加1。

（2）向队列插入数据：

```
//在队列的尾部插入数据
public boolean add(E e){
	if(rear==maxSize){
		throw new RuntimeException("栈已满，无法插入新的元素");
	}else{
		data[rear++]=e;
		return true;
	}
}
```

以上代码定义了方法add()来向队列中插入数据，在插入前先判断队列是否满了，如果队列有空间，则通过data[rear++]=e向队列的尾部加入数据并将队尾的指针位置加1。

（3）取走队列中的数据：

```
//删除队列头部的元素，出队
public E poll(){
	if(empty()){
		throw new RuntimeException("空队列异常");
	}else{
		E value=(E)data[front];//临时保存队列front端的元素的值
		data[front++]=null;//释放队列front端的元素
		return value;
	}
}
```

以上代码定义了方法poll()来取出队列头部的数据，并将队列头部的数据设置为null以释放队列头部的位置，最后返回队列头部的数据。

（4）队列数据查询：

```
//取出队列头部的元素，但不删除
public E peek(){
	if(empty()){
		throw new RuntimeException("空队列异常");
	}else{
		return (E)data[front];
	}
}
```

以上代码定义了方法peek()来访问并返回队列头部的数据。

## 6.链表

链表是由一系列节点（链表中的每一个元素都叫作一个节点）组成的数据结构，节点可以在运行过程中动态生成。每个节点都包括两部分内容：存储数据的数据域；存储下一个节点地址的指针域。

由于链表是随机存储数据的，因此在链表中插入数据的时间复杂度为O(1)，比在线性表和顺序表中插入的效率要高；但在链表中查找一个节点时需要遍历链表中所有元素，因此时间复杂度为O(n)，而在线性表和顺序表中查找一个节点的时间复杂度分别为O(logn)和O(1)。

链表有3种不同的类型：单向链表、双向链表及循环链表。

## 7.链表的特点

链表通过一组存储单元存储线性表中的数据元素，这组存储单元可以是连续的，也可以是不连续的。因此，为了表示每个数据元素与其直接后继数据元素之间的逻辑关系，对数据元素来说，除了存储其本身的信息，还需要存储直接后继数据元素的信息（即直接后继数据元素的存储位置）。由这两部分信息组成一个“节点”。链表数据结构的优点是插入快，缺点是数据查询需要遍历整个链表，效率慢。

链表根据具体的实现又分为单向链表、双向链表和循环链表。

![](D:\workspace\Java-Interview-Offer\images\数据结构003.png)

## 8.单向链表

单向链表（又称单链表）是链表的一种，其特点是链表的链接方向是单向的，访问链表时要从头部开始顺序读取。单向链表是链表中结构最简单的。一个单向链表的节点（Node）可分为两部分：第1部分为数据区（data），用于保存节点的数据信息；第2部分为指针区，用于存储下一个节点的地址，最后一个节点的指针指向null。

![](D:\workspace\Java-Interview-Offer\images\数据结构004.png)

## 9.单向链表的操作

（1）查找：单向链表只可向一个方向遍历，一般在查找一个节点时需要从单向链表的第1个节点开始依次访问下一个节点，一直访问到需要的位置。

（2）插入：对于单向链表的插入，只需将当前插入的节点设置为头节点，将Next指针指向原来的头节点即可。

（3）删除：对于单向链表的删除，我们只需将该节点的上一个节点的Next指针指向该节点的下一个节点，然后删除该节点即可。

## 10.单向链表的实现

（1）定义单向链表的数据结构：

```
public class SingleLinkedList{
	private int length;//链表节点的个数
	priavte Node head;//头节点
	//构造函数，根据指定的size初始化栈
	public SingleLinkedList(){
		size=0;
		head=null;
	}
	//链表的每个节点的数据结构描述类
	private class Node{
		private Object data;//每个节点的数据
		priavte Node next;//每个节点指向下一个节点的连接
		public Node(Object data){
			this.data=data;
		}
	}
}
```

以上代码定义了名为SingleLinkedList的单向链表，并定义了length表示链表的大小；head，表示链表的头部；名为Node的内部类，表示链表的节点数据结构，在Node中有data和next两个属性，分别表示该链表节点的数据和下一个节点的连接。这样就完成了对链表数据结构的定义。

（2）插入单向链表数据：

```
//在链表头添加元素
public Object addHead(Object obj){
	Node newHead=new Node(obj);//定义新节点
	if(length==0){//如果链表为空，则将该节点设置为头部节点
		head=newHead;
	}else{//设置当前节点为头部节点，并将当前节点的下一个节点指向原来的头部节点
		head=newHead;
		newHead.next=head;
	}
	length++;//链表长度+1
	return obj;
}
```

以上代码定义了方法addHead()来向链表的头部加入节点。具体操作为：首先定义一个节点；接着判断链表的长度是否为0，如果为0，则表示链表为空链表，直接将该节点设置为链表的头部节点；如果节点的长度不为0，则将当前插入的节点设置为头节点，将当前插入节点的Next指针指向原头节点即可；最后给链表的长度加1。

（3）删除单向链表数据：

```
//删除指定的元素，删除成功则返回true
public boolean delete(Object value){
	if(length==0){
		return false;
	}
	Node current=head;
	Node previous=head;
	while(current.data!=value){
		if(current.next==null){
			return false;
		}else{
			previous=current;
			current=current.next;
		}
	}
	//如果删除的节点是头节点
	if(current==head){
		head=current.next;
		length--;
	}else{//删除的节点不是头节点
		previous.next=current.next;
		length--;
	}
	return true;
}
```

以上代码定义了方法delete()来删除单向链表中的数据，具体的删除操作为：首先判断链表的长度，如果链表长度为0，则说明链表为空，即不包含任何元素，直接返回false；如果链表不为空，则通过while循环找到要删除的元素；如果要删除的节点是头节点，则需要把要删除的节点的下一个节点指定为头节点，删除该节点，把节点长度减1；如果删除的节点不是头节点，则将该节点的上一个节点的Next指针指向该节点的下一个节点，删除该节点，并把节点长度减1。

（4）单向链表数据查询：

```
//查找指定的元素，若找到了则返回节点node，找不到则返回null
public Node find(Object obj){
	Node current=head;
	int tempSize=length;
	while(tempSize>0){
		if(obj.equals(current.data)){
			return current;
		}else{
			current=current.next;
		}
		tempSize--;
	}
	return null;
}
```

以上代码定义了名为find()的单向链表节点查询方法。该方法很简单，定义了一个while循环来查找数据，如果当前数据和要查找的数据相同，则返回该数据；如果不同，则将当前节点的下一个节点设置为当前节点，沿着当前节点向前继续寻找。这里将tempSize减 1的目的是控制while循环的条件，在tempSize为0时表示遍历完了整个链表还没找到该数据，这时返回null。

## 11.双向链表

在双向链表的每个数据节点中都有两个指针，分别指向其直接后继和直接前驱节点。所以，从双向链表中的任意一个节点开始，都可以很方便地访问它的直接前驱节点和直接后继节点。

双向链表和单向链表的不同之处在于，单向链表除数据项外只定义了一个Next指针指向下一个节点，而双向链表定义了Prev和Next两个指针分别指向上一个节点和下一个节点，这样我们便可以从两个方向遍历并处理节点的数据了。

![](D:\workspace\Java-Interview-Offer\images\数据结构005.png)

## 12.双向链表的实现

（1）定义双向链表的数据结构：

```
public class TwoWayLinkedList{
	private int length;//表示链表的长度
	priavte Node head;//表示链表头
	priavte Node tail;//表示链表尾
	private class Node{
		private Object data;
		priavte Node next;
		priavte Node prev;
		public Node(Object data){
			this.data=data;
		}
	}
	public TwoWayLinkedList(){
		size=0;
		head=null;
		tail=null;
	}
}
```

以上代码定义了一个名为TwoWayLinkedList的双向链表的数据结构，其中定义了：head，表示链表头；tail，表示链表尾；length，表示链表长度；Node，表示链表的节点，链表的节点包含data、prev、next，分别表示节点数据、上一个节点和下一个节点。这样双向链表的数据结构就定义好了。

（2）在链表头部增加节点：

```
//在链表头部添加节点
public void addHead(Object value){
	Node newNode=new Node(value);
	if(length==0){
		head=newNode;
		tail=newNode;
		length++;
	}else{
		head.prev=newNode;
		newNode.next=head;
		head=newNode;
		length++;
	}
}
```

以上代码定义了addHead()来向链表的头部加入数据，具体操作为：首先，新建一个节点；然后，判断链表的长度，如果链表的长度为0，则说明链表是空链表，将链表的头部和尾部均设置为当前节点并将链表长度加1即可；如果链表不是空链表，则将原链表头部的上一个节点设置当前节点，将当前节点的下一个节点设置为原链表头的节点，将链表的头部节点设置为当前节点，这样就完成了双向链表的头部节点的插入；最后，需要将链表的长度加1。

（3）在链表尾部增加节点：

```
//在链表尾部添加节点
public void addTail(Object value){
	Node newNode=new Node(value);
	if(length==0){
		head=newNode;
		tail=newNode;
		length++;
	}else{
		newNode.prev=tail;
		tail.next=newNode;
		tail=newNode;
		length++;
	}
}
```

以上代码定义了名为addTail()的方法来给链表尾部加入数据，具体操作为：首先新建一个节点；然后判断链表的长度，如果链表的长度为0，则说明链表是空链表，将链表的头部和尾部均设置为当前节点并将链表长度加1即可；如果链表长度不为空，则将当前节点的上一个节点设置为原尾部节点，将原来的尾部节点的下一个节点设置为当前节点，将尾部节点设置为新的节点，这样就完成了双向链表尾部的插入；最后需要把链表的长度加1。

（4）删除链表的头部节点：

```
//删除链表的头部节点
public Node deleteHead(){
	Node temp=head;
	if(length!=0){
		head=head.next;
        head.prev=null;
        length--；
        return temp;
	}else{
		return null;
	}
}
```

以上代码定义了一个名为deleteHead()的方法来删除链表的头部节点，具体操作为：首先定义一个临时节点来存储当前头部节点；然后判断节点的长度，如果节点的长度为0，则直接返回null；如果节点的长度不为0，则将当前头部节点设置为原头部节点的下一个节点，将头部节点的上一个节点设置为null，然后删除该节点；最后，将节点的长度减 1。（5）删除链表的尾部节点：

```
//删除链表的头部节点
public Node deleteTail(){
	Node temp=tail;
	if(length!=0){
		tail=tail.prev;
        tail.next=null;
        length--；
        return temp;
	}else{
		return null;
	}
}
```

以上代码定义了一个deleteTail()方法来删除链表尾部的节点，具体操作为：首先定义一个临时节点来存储当前尾部节点；然后判断节点的长度，如果节点的长度为0，则直接返回null；如果节点的长度不为0，则将当前尾部节点设置为原尾部节点的上一个节点，将尾部节点的下一个节点设置为null，然后删除该节点；最后，将节点的长度减1。

## 13.循环链表

循环链表的链式存储结构的特点是：表中最后一个节点的指针域指向头节点，整个链表形成一个环。

循环节点的实现和单向链表十分相似，只是在链表中，尾部元素的Next指针不再是null，而是指向头部节点，其他实现和单向链表相同。

![](D:\workspace\Java-Interview-Offer\images\数据结构006.png)

## 14.散列表

散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。

散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素，因而必须要在数据元素的存储位置和它的关键字（可用key表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用h(key)表示)。

用的构造散列函数的方法有：

（1）直接定址法：取关键字或关键字的某个线性函数值为散列地址。即：h(key) = key 或h(key) = a* key + b，其中a和b为常数。

 （2）数字分析法 

（3）平方取值法：取关键字平方后的中间几位为散列地址。 

（4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。 

（5）除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址，即：h(key) = key MOD p p ≤m

（6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，即：h(key) = random(key)

![](D:\workspace\Java-Interview-Offer\images\数据结构007.png)

## 15.常用的构造散列函数

- 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即h(key) = key或h(key)=a×key+b，其中a和b为常数。
- 平方取值法：取关键字平方后的中间几位为散列地址。
- 折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。
- 除留余数法：取关键字被某个不大于散列表长度m的数p除后所得的余数为散列地址，即h(key)=key/p (p≤m)。
- 随机数法：选择一个随机函数，取关键字的随机函数值作为其散列地址，即h(key)=random(key)。
- JavaHashCode实现：在Java中计算HashCode的公式为f(key) =s[0] × 31n-1+s[1] × 31n-2 +...+s[n-1]。

```
public int hashCode(){
	int h=hash;
	if(h==0&&value.length>0){
		char val[]=value;
		for(int i=0;i<value.length;i++){
			h=31*h-val[i];
		}
		hash=h;
	}
	return h;
}
```

## 16.Hash的应用

Hash主要用于用信息安全加密和快速查询的应用场景。

- 信息安全：Hash主要被用于信息安全领域的加密算法中，它把一些不同长度的信息转化成杂乱的 128 位编码，这些编码的值叫作Hash值。也可以说，Hash就是找到一种数据内容和数据存放地址之间的映射关系。
- 快速查找：散列表，又叫作散列，是一种更加快捷的查找技术。基于列表集合查找的一般做法是从集合中拿出一个元素，看它是否与当前数据相等，如果不相等，则缩小范围，继续查找。而散列表是完全另外一种思路，在知道key值以后，就可以直接计算这个元素在集合中的位置，不需要一次又一次的遍历查找。

## 17.二叉排序树

二叉排序树（Binary Sort Tree），又称二叉查找树（Binary SearchTree）或二叉搜索树。二叉排序树为满足以下条件的树：

- 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；
- 左、右子树也分别为二叉排序树。

![](D:\workspace\Java-Interview-Offer\images\数据结构008.png)

### 插入操作

在二叉排序树中进行插入操作时只需找到待插入的父节点，将数据插入即可，具体流程如下。

（1）将待插入的新节点与当前节点进行比较，如果两个节点的值相同，则表示新节点已经存在于二叉排序树中，直接返回false。

（2）将待插入的新节点与当前节点进行比较，如果待插入的新节点的值小于当前节点的值，则在当前节点的左子树中寻找，直到左子树为空，则当前节点为要找的父节点，将新节点插入当前节点的左子树即可。

（3）将待插入的新节点与当前节点进行比较，如果待插入的新节点的值大于当前节点的值，则在当前节点的右子树中寻找，直到右子树为空，则当前节点为要找的父节点，将新节点插入当前节点的右子树即可。

### 删除操作

二叉排序树的删除操作主要分为三种情况：待删除的节点没有子节点；待删除的节点只有一个子节点；待删除的节点有两个子节点。具体情况如下。

（1）在待删除的节点没有子节点时，直接删除该节点，即在其父节点中将其对应的子节点置空即可。如图4-12所示，要删除的节点14没有子节点，则直接将其删除即可。

![](D:\workspace\Java-Interview-Offer\images\数据结构009.png)

（2）在待删除的节点只有一个子节点时，使用子节点替换当前节点，然后删除该节点即可。如图 4-13所示，要删除的节点 5有一个子节点 8，则使用子节点 8替换需要删除的节点5，然后删除节点5的数据即可。

![](D:\workspace\Java-Interview-Offer\images\数据结构010.png)

（3）在待删除的节点有两个子节点时，首先查找该节点的替换节点（替换节点为左子树中的最大节点或者右子树中的最小节点），然后替换待删除的节点为替换节点，最后删除替换节点。如图 4-14所示，要删除的节点4有两个子节点，其左子树最小的节点为2，其右子树最小的节点为5，因此有两种结果。

![](D:\workspace\Java-Interview-Offer\images\数据结构011.png)

### 查找操作

二叉排序树的查找方式和效率接近二分查找法，因此可以很容易获取最大（最右最深子节点）值和最小（最左最深子节点）值，具体的查找流程为：将要查找的数据与根节点的值进行比较，如果相等就返回，如果小于就到左子树中递归查找，如果大于就到右子树中递归查找。

## 18.红黑树

红黑树（Red-Black Tree，R-B Tree）是一种自平衡的二叉查找树。在红黑树的每个节点上都多出一个存储位表示节点的颜色，颜色只能是红（Red）或者黑（Black）。

## 19.红黑树的特性

红黑树的特性如下。

- 每个节点或者是黑色的，或者是红色的。
- 根节点是黑色的。
- 每个叶子节点（NIL）都是黑色的。
- 如果一个节点是红色的，则它的子节点必须是黑色的。
- 从一个节点到该节点的子孙节点的所有路径上都包含相同数量的黑色节点。

![](D:\workspace\Java-Interview-Offer\images\数据结构012.png)

## 20.红黑树的左旋

对a节点进行左旋，指将a节点的右子节点设为a节点的父节点，即将a节点变成一个左节点。因此左旋意味着被旋转的节点将变成一个左节点。

![](D:\workspace\Java-Interview-Offer\images\数据结构013.png)

## 21.红黑树的右旋

对b节点进行右旋，指将b节点的左子节点设为b节点的父节点，即将b节点设为一个右节点。因此右旋意味着被旋转的节点将变成一个右节点。

![]()![数据结构014](D:\workspace\Java-Interview-Offer\images\数据结构014.png)

## 22.红黑树的添加

红黑树的添加分为3步：①将红黑树看作一颗二叉查找树，并以二叉树的插入规则插入新节点；②将插入的节点涂为“红色”或“黑色”；③通过左旋、右旋或着色操作，使之重新成为一颗红黑树。

根据被插入的节点的父节点的情况，可以将具体的插入分为3种情况来处理。

（1）如果被插入的节点是根节点，则直接把此节点涂为黑色的。

（2）如果被插入的节点的父节点是黑色的，则什么也不需要做，在节点插入后，仍然是红黑树。

（3）如果被插入的节点的父节点是红色的，则在被插入节点的父节点是红色的时，被插入节点一定存在非空祖父节点，即被插入节点也一定存在叔叔节点，即使叔叔节点（叔叔节点指当前节点的祖父节点的另一个子节点）为空，我们也视之为存在，空节点本身就是黑色节点。然后根据叔叔节点的颜色，在被插入节点的父节点是红色的时，进一步分为3种情况来处理。

- 如果当前节点的父节点是红色的，当前节点的叔叔节点是红色的，则将父节点设为黑色的，将叔叔节点设为黑色的，将祖父节点设为红色的，将祖父节点设为当前节点。
- 如果当前节点的父节点是红色的，当前节点的叔叔节点是黑色的且当前节点是右节点，则将父节点设为当前节点，以新节点为支点左旋。
- 如果当前节点的父节点是红色的，当前节点的叔叔节点是黑色的且当前节点是左节点，则将父节点设为黑色的，将祖父节点设为红色的，以祖父节点为支点右旋。

## 23.红黑树的删除

红黑树的删除分为两步：①将红黑树看作一颗二叉查找树，根据二叉查找树的删除规则删除节点；②通过左旋、旋转、重新着色操作进行树修正，使之重新成为一棵红黑树，具体操作如下。

（1）将红黑树看作一颗二叉查找树，将节点删除。

- 如果被删除的节点没有子节点，那么直接将该节点删除。
- 如果被删除的节点只有一个子节点，那么直接删除该节点，并用该节点的唯一子节点替换该节点的位置。
- 如果被删除的节点有两个子节点，那么先找出该节点的替换节点，然后把替换节点的数据复制给该节点的数据，之后删除替换节点。

（2）通过左旋、旋转、重新着色操作进行树修正，使之重新成为一棵红黑树，因为红黑树在删除节点后可能会违背红黑树的特性，所以需要通过旋转和重新着色来修正该树，使之重新成为一棵红黑树：①如果当前节点的子节点是“红+黑”节点，则直接把该节点设为黑色的；②如果当前节点的子节点是“黑+黑”节点，且当前节点是根节点，则什么都不做；③如果当前节点的子节点是“黑+黑”节点，且当前节点不是根节点，则又可以分为以下几种情况进行处理。

- 如果当前节点的子节点是“黑+黑”节点，且当前节点的兄弟节点是红色的，则将当前节点的兄弟节点设置为黑色的，将父节点设置为红色的，对父节点进行左旋，重新设置当前节点的兄弟节点。
- 如果当前节点的子节点是“黑+黑”节点，且当前节点的兄弟节点是黑色的，兄弟节点的两个子节点也都是黑色的，则将当前节点的兄弟节点设置为红色的，设置当前节点的父节点为新节点。
- 如果当前节点的子节点是“黑+黑”节点，且当前节点的兄弟节点是黑色的，兄弟节点的左子节点是红色的且右子节点是黑色的，则将当前节点的左子节点设置为黑色的，将兄弟节点设置为红色的，对兄弟节点进行右旋，重新设置当前节点的兄弟节点。
- 如果当前节点的子节点是“黑+黑”节点，且当前节点的兄弟节点是黑色的，兄弟节点的右子节点是红色的且左子节点是任意颜色的，则将当前节点的父节点的颜色赋值给兄弟基点，将父节点设置为黑色的，将兄弟节点的右子节点设置为黑色的，对父节点进行左旋，设置当前节点为根节点。

## 24.图

图是由有穷非空集合的顶点和顶点之间的边组成的集合，通常表示为G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

在线性结构中，每个元素都只有一个直接前驱和直接后继，主要用来表示一对一的数据结构；在树形结构中，数据之间有着明显的父子关系，每个数据和其子节点的多个数据相关，主要用来表示一对多的数据结构；在图形结构中，数据之间具有任意关系，图中任意两个数据元素之间都可能相关，可用来表示多对多的数据结构。图根据边的属性可分为无向图和有向图。

## 25.无向图和有向图

若从顶点Vi到Vj的边没有方向，则称这条边为无向边。顶点和无向边组成的图为无向图，用无序对(Vi,Vj)来表示无向边。如图4-18所示，G=(V1,{E1})，其中顶点集合V1={A,B,C,D}，边集合E1={(A,B),(A,C),(A,D),(B,D),(C,D)}。

若从顶点Vi到Vj的边有方向，则称这条边为有向边，也叫作弧，用有序偶<Vi,Vj>来表示有向边，Vi叫作弧尾，Vj叫作弧头。由顶点和有向边组成的图叫作有向图。如图4-19所示，G=(V2,{E2})，其中顶点集合V2={A,B,C,D}，弧集合E2={<A,D>,<B,A>,<C,A>,<B,C>}。连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，<A,D>表示弧，注意弧是有方向的，不能写成<D,A>。

![](D:\workspace\Java-Interview-Offer\images\数据结构015.png)

## 26.图的存储结构：邻接矩阵

图的邻接矩阵的存储方式是基于两个数组来表示图的数据结构并存储图中的数据。一个一维数组存储图中的顶点信息，一个二维数组（叫作邻接矩阵）存储图中的边或弧的信息。设图G有n个顶点，则邻接矩阵是一个n×n的方阵。

![](D:\workspace\Java-Interview-Offer\images\数据结构016.png)

### 无向图的邻接矩阵

在无向图的邻接矩阵中，如果<Vi,Vj>的交点为1，则表示两个顶点连通，为0则不连通。在无向图的邻接矩阵中，主对角元素都为0，也就是说顶点自身没有连通关系。

![](D:\workspace\Java-Interview-Offer\images\数据结构017.png)

### 有向图的邻接矩阵

在有向图的邻接矩阵中，如果<Vi,Vj>的交点为1，则表示从Vi到Vj存在弧（但从Vj到Vi是否存在弧不确定），为0则表示从Vi到Vj不存在弧；同样，在有向图的邻接矩阵中主对角元素都为0，也就是说从顶点到自身没有弧。需要注意的是，有向图的连接是有方向的，V1的出度为2（从V1出发的边有两条），表示从V1顶点出发的边有两条，V3的出度为0，表示没有从V3出发的边。

![](D:\workspace\Java-Interview-Offer\images\数据结构018.png)

### 带权重图的邻接矩阵

有些图的每条边上都带有权重，如果要将这些权值保存下来，则可以采用权值代替矩阵中的 0、1，在权值不存在的元素之间用∞表示。

![](D:\workspace\Java-Interview-Offer\images\数据结构019.png)

## 27.图的存储结构：邻接表

数组与链表相结合的存储方法叫作邻接表。邻接表是图的一种链式存储结构，主要用于解决邻接矩阵中顶点多边少时空间浪费的问题。具体的处理方法如下。

（1）将图中的顶点信息存储在一个一维数组中，同时在顶点信息中存储用于指向第1个邻接点的指针，以便查找该顶点的边信息。

（2）图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单向链表存储，如果是无向图，则称链表为顶点Vi的边表，如果是有向图，则称链表为以顶点Vi为弧尾的出边表。

### 无向图的邻接表结构

顶点是通过一个头节点类型的一维数组保存的，其中每个头节点的第1个弧都指向第1条依附在该顶点上的边的信息，邻接域表示该边的另一个顶点在顶点数组中的下标，下一个弧指向下一条依附在该顶点上的边的信息。有向图的邻接表和无向图类似。

![](D:\workspace\Java-Interview-Offer\images\数据结构020.png)

### 带权值的网图连接表结构

对于带权值的图，在节点定义中再增加一个权重值weight的数据域，存储权值信息即可。

![]()![数据结构021](D:\workspace\Java-Interview-Offer\images\数据结构021.png)

## 28.图的遍历

图的遍历指从图中某一顶点出发访遍图中的每个顶点，且使每一个顶点仅被访问一次。图的遍历分为广度优先遍历和深度优先遍历，且对无向图和有向图都适用。

### 广度优先遍历

广度优先遍历也叫作广度优先搜索（Breadth First Search），类似于树的分层遍历算法，其定义为：假设从图中某个顶点V出发，在访问了V之后依次访问V的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直到图中所有已被访问的顶点的邻接点都被访问；若此时图中尚有顶点未被访问，则另选图中未曾被访问的一个顶点作为起始点重复上述过程，直至图中所有顶点均被访问。

如图4-26所示的图广度优先遍历顺序为：假设从起始点V1开始遍历，首先访问V1和V1的邻接点V2和V3，然后依次访问V2的邻接点V4和V5，及V3的邻接点V6和V7，最后访问V4的邻接点V8，于是得到节点的线性遍历顺序为：V1→V2→V3→V4→V5→V6→V7→V8。

![](D:\workspace\Java-Interview-Offer\images\数据结构022.png)

### 深度优先遍历

图的深度优先遍历也叫作深度优先搜索（Depth First Search），类似于树的先根遍历（先访问树的根节点）。其定义如下：

假设从图中的某个顶点V出发，在访问V节点后依次从V未被访问的邻接点出发以深度优先的原则遍历图，直到图中所有和V节点路径连通的顶点都被访问；若此时图中尚有顶点未被访问，则另选一个未曾访问的顶点作为起始点重复上述过程，直至图中所有节点都被访问。

如图4-27所示的深度优先遍历顺序为：假设从起始点V1开始遍历，在访问了V1后选择其邻接点V2。因为V2未曾被访问，所以从V2出发进行深度优先遍历。依此类推，接着从V4、V8、V5出发进行遍历。在访问了V5后，由于V5的邻接点都被访问过，则遍历回退到V8。同理，继续回退到V4、V2直至V1，此时V1的另一个邻接点V3未被访问，则遍历操作又从V1到V3继续进行下去，得到节点的线性顺序为：V1→V2→V4→V8→V5→V3→V6→V7。

![](D:\workspace\Java-Interview-Offer\images\数据结构023.png)

## 29.位图

位图（Bitmap）通常基于数组实现，我们可以将数组中的每个元素都看作一系列二进制数，所有元素一起组成更大的二进制集合，这样就可以大大节省空间。位图通常是用来判断某个数据存不存在的，常用于在BloomFilter中判断数据是否存在，还可用于无重复整数的排序等，在大数据行业中使用广泛。

## 30.位图的数据结构

位图在内部维护了一个M×N维的数组char[M][N]，在这个数组里面每个字节占8位，因此可以存储 M×N×8个数据。假如要存储的数据范围为 0～15，则只需使用M=1,N=2的数据进行存储。

在我们要存储的数据为{1,3,6,10,15}时，只需将有数据的位设置为1，表示该位存在数据，将其他位设置为0，具体的数据结构如图4-29所示。

![](D:\workspace\Java-Interview-Offer\images\数据结构024.png)