## 1.并发与并行

并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。

并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

## 2.线程与进程区别

**把进程当做资源分配的基本单元，把线程当做执行的基本单元，同一个进程的多个线程之间共享资源**。

## 3.线程的创建方式

- 继承Thread类
- 实现Runnable接口
- 通过ExecutorService和Callable<Class>实现有返回值的线程
- 基于线程池

### 继承Thread类

Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式创建一个线程。具体实现为创建一个类并继承Thread接口，然后实例化线程对象并调用start方法启动线程。start方法是一个native方法，通过在操作系统上启动一个新线程，并最终执行run方法来启动一个线程。run方法内的代码是线程类的具体实现逻辑。

```
//通过继承Thread类创建NewThread线程
public class NewThread extends Thread{
	public void run(){
	
	}
} 
//实例化一个线程对象
NewThread newThread=new NewThread();
//调用start方法启动线程
newThread.start();
```

以上代码定义了一个名为NewThread的线程类，该类继承了Thread，run方法内的代码为线程的具体执行逻辑，在使用该线程时只需新建一个该线程的对象并调用其start方法即可。

### 实现Runnable接口

基于Java编程语言的规范，如果子类已经继承（extends）了一个类，就无法再直接继承Thread类，此时可以通过实现Runnable接口创建线程。具体的实现过程为：通过实现Runnable接口创建ChildrenClassThread线程，实例化名称为childrenThread的线程实例，创建Thread类的实例并传入childrenThread线程实例，调用线程的start方法启动线程。具体的实现代码如下：

```
//通过继承Thread类创建NewThread线程
public class ChildrenClassThread extends SuperClass implements Runnable{
	public void run(){
	
	}
} 
//实例化一个ChildrenClassThread对象
ChildrenClassThread childrenThread=new ChildrenClassThread();
//创建一个线程对象并将其传入已经实例化好的childrenThread实例
Thread thread=new Thread(childrenThread);
//调用start方法启动线程
thread.start();
```

在传入一个实现了Runnable的线程实例target给Thread后，Thread的run方法在执行时就会调用target.run方法并执行该线程具体的实现逻辑。在JDK源码中，run方法的实现代码如下：

```
@Override
public void run(){
	if(target!=null){
		target.run();
	}
}
```

### 通过ExecutorService和Callable<Class>、Future实现有返回值的线程

有时，我们需要在主线程中开启多个线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。

有返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。

具体的实现方法为：创建一个类并实现Callable接口，在call方法中实现具体的运算逻辑并返回计算结果。具体的调用过程为：创建一个线程池、一个用于接收返回结果的Future List及Callable线程实例，使用线程池提交任务并将线程执行之后的结果保存在Future中，在线程执行结束后遍历Future List中的Future对象，在该对象上调用get方法就可以获取Callable线程任务返回的数据并汇总结果，实现代码如下：

```
//实现Callable接口创建MyCallable线程
public class MyCallable implements Callable<String>{
	private String name;
	public MyCallable(String name){//通过构造函数为线程传递参数，以定义线程名称
		this.name=name;
	}
	@Override
	public String call() throws Exception{//call方法内为线程实现逻辑
		return name;
	}
}
	//创建一个固定大小为5的线程池
	ExecutorService pool=Executors.newFixedThreadPool(5);
	//创建有多个返回值的任务列表List
	List<Future> list=new ArrayList<Future>();
	for(int i=0;i<5;i++){
		//创建一个有返回值的线程实例
		Callable c=new MyCallable(i+"");
		//提交线程，获取Future对象并将其保存到Future List
        Future future=pool.submit(c);
        list.add(future);
	}
	//关闭线程池，等待线程执行结束
	pool.shutdown();
}
```

## 4.线程的生命周期

线程的生命周期分为新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）这5种状态。在系统运行过程中不断有新的线程被创建，旧的线程在执行完毕后被清理，线程在排队获取共享资源或者锁时将被阻塞，因此运行中的线程会在就绪、阻塞、运行状态之间来回切换。

![](D:\workspace\Java-Interview-Offer\images\并发编程001.png)

其流程如下所述。

（1）调用new方法新建一个线程，这时线程处于新建状态。

（2）调用start方法启动一个线程，这时线程处于就绪状态。

（3）处于就绪状态的线程等待线程获取CPU资源，在等待其获取CPU资源后线程会执行run方法进入运行状态。

（4）正在运行的线程在调用了yield方法或失去处理器资源时，会再次进入就绪状态。

（5）正在执行的线程在执行了sleep方法、I/O阻塞、等待同步锁、等待通知、调用suspend方法等操作后，会挂起并进入阻塞状态，进入Blocked池。

（6）阻塞状态的线程由于出现sleep时间已到、I/O方法返回、获得同步锁、收到通知、调用resume方法等情况，会再次进入就绪状态，等待CPU时间片的轮询。该线程在获取CPU资源后，会再次进入运行状态。

（7）处于运行状态的线程，在调用run方法或call方法正常执行完成、调用stop方法停止线程或者程序执行错误导致异常退出时，会进入死亡状态。

### 新建状态：New

在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是为线程分配内存并初始化其成员变量的值。

### 就绪状态：Runnable

新建的线程对象在调用start方法之后将转为就绪状态。此时JVM完成了方法调用栈和程序计数器的创建，等待该线程的调度和运行。

### 运行状态：Running

就绪状态的线程在竞争到CPU的使用权并开始执行run方法的线程执行体时，会转为运行状态，处于运行状态的线程的主要任务就是执行run方法中的逻辑代码。

### 阻塞状态：Blocked

运行中的线程会主动或被动地放弃CPU的使用权并暂停运行，此时该线程将转为阻塞状态，直到再次进入可运行状态，才有机会再次竞争到CPU使用权并转为运行状态。阻塞的状态分为以下三种。

（1）等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（Waitting Queue）中，线程转为阻塞状态。

（2）同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，JVM会把该线程放入锁池（Lock Pool）中，此时线程转为阻塞状态。

（3）其他阻塞：运行状态的线程在执行Thread.sleep(long ms)、Thread.join()或者发出I/O请求时，JVM会把该线程转为阻塞状态。直到sleep()状态超时、Thread.join()等待线程终止或超时，或者I/O处理完毕，线程才重新转为可运行状态。

### 线程死亡：Dead

线程在以下面三种方式结束后转为死亡状态。

- 线程正常结束：run方法或call方法执行完成。
- 线程异常退出：运行中的线程抛出一个Error或未捕获的Exception，线程异常退出。
- 手动结束：调用线程对象的stop方法手动结束运行中的线程（该方式会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用）。

## 5.线程的基本方法

线程相关的基本方法有wait、notify、notifyAll、sleep、join、yield等，这些方法控制线程的运行，并影响线程的状态变化。

### 线程等待：wait方法

调用wait方法的线程会进入WAITING状态，只有等到其他线程的通知或被中断后才会返回。需要注意的是，在调用wait方法后会释放对象的锁，因此wait方法一般被用于同步方法或同步代码块中。

### 线程睡眠：sleep方法

调用sleep方法会导致当前线程休眠。与wait方法不同的是，sleep方法不会释放当前占有的锁，会导致线程进入TIMED-WATING状态，而wait方法会导致当前线程进入WATING状态。

### 线程让步：yield方法

调用yield方法会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。在一般情况下，优先级高的线程更有可能竞争到CPU时间片，但这不是绝对的，有的操作系统对线程的优先级并不敏感。

### 线程中断：interrupt方法

interrupt方法用于向线程发行一个终止通知信号，会影响该线程内部的一个中断标识位，这个线程本身并不会因为调用了interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定。对interrupt方法的理解需要注意以下4个核心点。

- 调用interrupt方法并不会中断一个正在运行的线程，也就是说处于Running状态的线程并不会因为被中断而终止，仅仅改变了内部维护的中断标识位而已。
- 若因为调用sleep方法而使线程处于TIMED-WATING状态，则这时调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WATING状态。
- 许多声明抛出InterruptedException的方法如Thread.sleep(longmills)，在抛出异常前都会清除中断标识位，所以在抛出异常后调用isInterrupted方法将会返回false。
- 中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如，在想终止一个线程时，可以先调用该线程的interrupt方法，然后在线程的run方法中根据该线程isInterrupted方法的返回状态值安全终止线程。

### 线程加入：join方法

join方法用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。

### 为什么要用join()方法？

在很多情况下，主线程生成并启动了子线程，需要等到子线程返回结果并收集和处理再退出，这时就要用到join方法。

### 线程唤醒：notify方法

Object类有个notify方法，用于唤醒在此对象监视器上等待的一个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的。

我们通常调用其中一个对象的wait方法在对象的监视器上等待，直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他线程竞争。类似的方法还有notifyAll，用于唤醒在监视器上等待的所有线程。

### 后台守护线程：setDaemon方法

setDaemon方法用于定义一个守护线程，也叫作“服务线程”，该线程是后台线程，有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。

守护线程的优先级较低，用于为系统中的其他对象和线程提供服务。将一个用户线程设置为守护线程的方法是在线程对象创建之前用线程对象的setDaemon(true)来设置。

在后台守护线程中定义的线程也是后台守护线程。

后台守护线程是JVM级别的，比如垃圾回收线程就是一个经典的守护线程，在我们的程序中不再有任何线程运行时，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以在回收JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态下运行，用于实时监控和管理系统中的可回收资源。

守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。也就是说，守护线程不依赖于终端，但是依赖于JVM，与JVM“同生共死”。在JVM中的所有线程都是守护线程时，JVM就可以退出了，如果还有一个或一个以上的非守护线程，则JVM不会退出。

![](D:\workspace\Java-Interview-Offer\images\并发编程002.png)

### 其他方法

- sleep()：强迫一个线程睡眠Ｎ毫秒。
- isAlive()：判断一个线程是否存活。
- join()：等待线程终止。
- activeCount()：程序中活跃的线程数。
- enumerate()：枚举程序中的线程。
- currentThread()：得到当前线程。
- isDaemon()：一个线程是否为守护线程。
- setDaemon()：设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) 
- setName()：为线程设置一个名称。
- wait()：强迫一个线程等待。
- notify()：通知一个线程继续运行。
- setPriority()：设置一个线程的优先级。
- getPriority():：获得一个线程的优先级。

## 6.sleep方法与wait方法的区别

sleep方法与wait方法的区别如下。

- sleep方法属于Thread类，wait方法则属于Object类。
- sleep方法暂停执行指定的时间，让出CPU 给其他线程，但其监控状态依然保持，在指定的时间过后又会自动恢复运行状态。
- 在调用sleep方法的过程中，线程不会释放对象锁。
- 在调用wait方法时，线程会放弃对象锁，进入等待此对象的等待锁池，只有针对此对象调用notify方法后，该线程才能进入对象锁池准备获取对象锁，并进入运行状态。

## 7.start方法与run方法的区别

start方法与run方法的区别如下。

- start方法用于启动线程，真正实现了多线程运行。在调用了线程的start方法后，线程会在后台执行，无须等待run方法体的代码执行完毕，就可以继续执行下面的代码。
- 在通过调用Thread类的start方法启动一个线程时，此线程处于就绪状态，并没有运行。
- run方法也叫作线程体，包含了要执行的线程的逻辑代码，在调用run方法后，线程就进入运行状态，开始运行run方法中的代码。在run方法运行结束后，该线程终止，CPU再调度其他线程。

## 8.终止线程的4种方式

### 正常运行结束

指线程体执行完成，线程自动结束。

### 使用退出标志退出线程

在一般情况下，在run方法执行完毕时，线程会正常结束。然而，有些线程是后台线程，需要长时间运行，只有在系统满足某些特殊条件后，才能触发关闭这些线程。这时可以使用一个变量来控制循环，比如设置一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出，具体的实现代码如下：

```
public class ThreadSafe extends Thread{
	public volatile boolean exit=false;
    public void run(){
    	while(!exit){
    		//执行业务逻辑代码
    	}
    }
}
```

以上代码在线程中定义了一个退出标志exit，exit的默认值为false。在定义exit时使用了一个Java关键字volatile，这个关键字用于使exit线程同步安全，也就是说在同一时刻只能有一个线程修改exit的值，在exit为true时，while循环退出。

### 使用Interrupt方法终止线程

使用interrupt方法终止线程有以下两种情况。

（1）线程处于阻塞状态。例如，在使用了sleep、调用锁的wait或者调用socket的receiver、accept等方法时，会使线程处于阻塞状态。在调用线程的interrupt方法时，会抛出InterruptException异常。我们通过代码捕获该异常，然后通过break跳出状态检测循环，可以有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法就会结束线程，这实际上理解有误，一定要先捕获InterruptedException异常再通过break跳出循环，才能正常结束run方法。具体的实现代码如下：

```
public class ThreadSafe extends Thread{
    public void run(){
    	while(!isInterrupted()){//在非阻塞过程中通过判断中断标志来推出
    		try{
    			Thread.sleep(5*1000);//在阻塞过程中捕获中断异常来退出
    		}catch(InterruptedException e){
    			e.printStackTrace();
    			break;//在捕获到异常后执行break跳出循环
    		}
    	}
    }
}
```

（2）线程未处于阻塞状态。此时，使用isInterrupted方法判断线程的中断标志来退出循环。在调用interrupt方法时，中断标志会被设置为true，并不能立刻退出线程，而是执行线程终止前的资源释放操作，等待资源释放完毕后退出该线程。

### 使用stop方法终止线程：不安全

在程序中可以直接调用Thread.stop方法强行终止线程，但这是很危险的，就像突然关闭计算机的电源，而不是正常关机一样，可能会产生不可预料的后果。

在程序使用Thread.stop方法终止线程时，该线程的子线程会抛出ThreadDeatherror错误，并且释放子线程持有的所有锁。加锁的代码块一般被用于保护数据的一致性，如果在调用Thread.stop方法后导致该线程所持有的所有锁突然释放而使锁资源不可控制，被保护的数据就可能出现不一致的情况，其他线程在使用这些被破坏的数据时，有可能使程序运行错误。因此，并不推荐采用这种方法终止线程。

## 9.线程上下文切换

CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。任务的状态保存及再加载就叫作线程的上下文切换。时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。

- 进程：指一个运行中的程序的实例。在一个进程内部可以有多个线程在同时运行，并与创建它的进程共享同一地址空间（一段内存区域）和其他资源。
- 上下文：指线程切换时CPU寄存器和程序计数器所保存的当前线程的信息。
- 寄存器：指CPU 内部容量较小但速度很快的内存区域（与之对应的是CPU 外部相对较慢的RAM主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来加快计算机程序运行的速度。
- 程序计数器：是一个专用的寄存器，用于表明指令序列中CPU 正在执行的位置，存储的值为正在执行的指令的位置或者下一个将被执行的指令的位置，这依赖于特定的系统。

在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换帧”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。

## 10.PCB-“切换桢”

上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。上下文切换过程中的信息被保存在进程控制块（PCB-ProcessControl Block）中。PCB又被称作切换桢（SwitchFrame）。上下文切换的信息会一直被保存在CPU的内存中，直到被再次使用。上下文的切换流程如下。

（1）挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB中。

（2）在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复。

（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程。

时间片轮转方式使多个任务在同一CPU上的执行有了可能.

## 11.引起线程上下文切换的原因

- 当前正在执行的任务完成，系统的CPU正常调度下一个任务。
- 当前正在执行的任务遇到I/O 等阻塞操作，调度器挂起此任务，继续调度下一个任务。
- 多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。
- 用户的代码挂起当前任务，比如线程执行sleep方法，让出CPU。
- 硬件中断。

## 12.多线程如何共享数据

在Java中进行多线程通信主要是通过共享内存实现的，共享内存主要有三个关注点：可见性、有序性、原子性。Java内存模型（JVM）解决了可见性和有序性的问题，而锁解决了原子性的问题。在理想情况下，我们希望做到同步和互斥来实现数据在多线程环境下的一致性和安全性。常用的实现多线程数据共享的方式有将数据抽象成一个类，并将对这个数据的操作封装在类的方法中；将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量。

### 将数据抽象成一个类，并将对这个数据的操作封装在类的方法中

这种方式只需要在方法上加synchronized关键字即可做到数据的同步。

在应用时需要注意的是，如果两个线程AddRunnable和DecRunnable需要保证数据操作的原子性和一致性，就必须在传参时使用同一个data对象入参。这样无论启动多少个线程执行对data数据的操作，都能保证数据的一致性。

### 将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量

将Runnable对象作为类的内部类，将共享数据作为这个类的成员变量，每个线程对共享数据的操作方法都被封装在该类的外部类中，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。

## 13.线程调度

### 抢占式调度

抢占式调度指每个线程都以抢占的方式获取CPU资源并快速执行，在执行完毕后立刻释放CPU资源，具体哪些线程能抢占到CPU资源由操作系统控制，在抢占式调度模式下，每个线程对CPU资源的申请地位是相等，从概率上讲每个线程都有机会获得同样的CPU执行时间片并发执行。抢占式调度适用于多线程并发执行的情况，在这种机制下一个线程的堵塞不会导致整个进程性能下降。

### 协同式调度

协同式调度指某一个线程在执行完后主动通知操作系统将CPU资源切换到另一个线程上执行。线程对CPU的持有时间由线程自身控制，线程切换更加透明，更适合多个线程交替执行某些任务的情况。

协同式调度有一个缺点：如果其中一个线程因为外部原因（可能是磁盘I/O阻塞、网络I/O阻塞、请求数据库等待）运行阻塞，那么可能导致整个系统阻塞甚至崩溃。

## 14.Java线程调度的实现：抢占式

Java采用抢占式调度的方式实现内部的线程调度，Java会为每个线程都按照优先级高低分配不同的CPU时间片，且优先级高的线程优先执行。优先级低的线程只是获取CPU时间片的优先级被降低，但不会永久分配不到CPU时间片。Java的线程调度在保障效率的前提下尽可能保障线程调度的公平性。

## 15.线程让出CPU的情况

线程让出CPU的情况如下。

- 当前运行的线程主动放弃CPU，例如运行中的线程调用yield()放弃CPU 的使用权。
- 当前运行的线程进入阻塞状态，例如调用文件读取I/O 操作、锁等待、Socket等待。
- 当前线程运行结束，即运行完run()里面的任务。

## 16.进程调度算法

进程调度算法包括优先调度算法、高优先权优先调度算法和基于时间片的轮转调度算法。其中，优先调度算法分为先来先服务调度算法和短作业优先调度算法；高优先权优先调度算法分为非抢占式优先权算法、抢占式优先权调度算法和高响应比优先调度算法。基于时间片的轮转调度算法分为时间片轮转算法和多级反馈队列调度算法。

### 1.优先调度算法

优先调度算法包含先来先服务调度算法和短作业（进程）优先调度算法。

#### 先来先服务调度算法（FCFS）

先来先服务调度算法指每次调度时都从队列中选择一个或多个最早进入该队列的作业，为其分配资源、创建进程和放入就绪队列。调度算法在获取到可用的CPU资源时会从就绪队列中选择一个最早进入队列的进程，为其分配CPU资源并运行。该算法优先运行最早进入的任务，实现简单且相对公平。

#### 短作业优先调度算法

短作业优先调度算法指每次调度时都从队列中选择一个或若干个预估运行时间最短的作业，为其分配资源、创建进程和放入就绪队列。调度算法在获取到可用的CPU资源时，会从就绪队列中选出一个预估运行时间最短的进程，为其分配CPU资源并运行。该算法优先运行短时间作业，以提高CPU整体的利用率和系统运行效率，某些大任务可能会出现长时间得不到调度的情况。

### 2.高优先权优先调度算法

高优先权优先调度算法在定义任务的时候为每个任务都设置不同的优先权，在进行任务调度时优先权最高的任务首先被调度，这样资源的分配将更加灵活，具体包含非抢占式优先调度算法、抢占式优先调度算法和高响应比优先调度算法。

#### 非抢占式优先调度算法

非抢占式优先调度算法在每次调度时都从队列中选择一个或多个优先权最高的作业，为其分配资源、创建进程和放入就绪队列。调度算法在获取到可用的CPU资源时会从就绪队列中选出一个优先权最高的进程，为其分配CPU资源并运行。进程在运行过程中一直持有该CPU，直到进程执行完毕或发生异常而放弃该CPU。该算法优先运行优先权高的作业，且一旦将CPU分配给某个进程，就不会主动回收CPU资源，直到任务主动放弃。

#### 抢占式优先调度算法

抢占式优先调度算法首先把CPU资源分配给优先权最高的任务并运行，但如果在运行过程中出现比当前运行任务优先权更高的任务，调度算法就会暂停运行该任务并回收CPU资源，为其分配新的优先权更高的任务。该算法真正保障了CPU在整个运行过程中完全按照任务的优先权分配资源，这样如果临时有紧急作业，则也可以保障其第一时间被执行。

#### 高响应比优先调度算法

高响应比优先调度算法使用了动态优先权的概念，即任务的执行时间越短，其优先权越高，任务的等待时间越长，优先权越高，这样既保障了快速、并发地执行短作业，也保障了优先权低但长时间等待的任务也有被调度的可能性。

该优先权的变化规律如下。

- 在作业的等待时间相同时，运行时间越短，优先权越高，在这种情况下遵循的是短作业优先原则。
- 在作业的运行时间相同时，等待时间越长，优先权越高，在这种情况下遵循的是先来先服务原则。
- 作业的优先权随作业等待时间的增加而不断提高，加大了长作业获取CPU 资源的可能性。

高响应比优先调度算法在保障效率（短作业优先能在很大程度上提高CPU的使用率和系统性能）的基础上尽可能提高了调度的公平性（随着任务等待时间的增加，优先权提高，遵循了先来先到原则）。

### 3.时间片的轮转调度算法

时间片的轮转调度算法将CPU资源分成不同的时间片，不同的时间片为不同的任务服务，具体包括时间片轮转法和多级反馈队列调度算法。

#### 时间片轮转法

时间片轮转法指按照先来先服务原则从就绪队列中取出一个任务，并为该任务分配一定的CPU时间片去运行，在进程使用完CPU时间片后由一个时间计时器发出时钟中断请求，调度器在收到时钟中断请求信号后停止该进程的运行并将该进程放入就绪队列的队尾，然后从就绪队列的队首取出一个任务并为其分配CPU时间片去执行。这样，就绪队列中的任务就将轮流获取一定的CPU时间片去运行。

#### 多级反馈队列调度算法

多级反馈队列调度算法在时间片轮询算法的基础上设置多个就绪队列，并为每个就绪队列都设置不同的优先权。队列的优先权越高，队列中的任务被分配的时间片就越大。默认第一个队列优先权最高，其他次之。

多级反馈队列调度算法的调度流程为：在系统收到新的任务后，首先将其放入第一个就绪队列的队尾，按先来先服务调度算法排队等待调度。若该进程在规定的CPU时间片内运行完成或者运行过程中出现错误，则退出进程并从系统中移除该任务；如果该进程在规定的CPU时间片内未运行完成，则将该进程转入第2队列的队尾调度执行；如果该进程在第2队列中运行一个CPU时间片后仍未完成，则将其放入第3队列，以此类推，在一个长作业从第1队列依次降到第n队列后，在第n队列中便以时间片轮转的方式运行。

多级反馈队列调度算法遵循以下原则。

- 仅在第一个队列为空时，调度器才调度第2队列中的任务。
- 仅在第1～(n-1)队列均为空时，调度器才会调度第n队列中的进程。
- 如果处理器正在为第n队列中的某个进程服务，此时有新进程进入优先权较高的队列（第1～(n-1)中的任何一个队列），则此时新进程将抢占正在运行的进程的处理器，即调度器停止正在运行的进程并将其放回第 n 队列的末尾，把处理器分配给新来的高优先权进程。

 队列的末尾，把处理器分配给新来的高优先权进程。多级反馈调度算法相对来说比较复杂，它充分考虑了先来先服务调度算法和时间片轮询算法的优势，使得对进程的调度更加合理。

## 17.线程的实现

实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

### 使用内核线程实现

内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。

由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

### 使用用户线程实现

从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程（User Thread,UT），因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。

而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型。

使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。因而使用用户线程实现的程序一般都比较复杂 ，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。

### 使用用户线程加轻量级进程混合实现

线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系，如图12-5所示，这种就是多对多的线程模型。

许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了N：M的线程模型实现。

### 18.线程优先级

Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。

Java 线程优先级使用 1 ~ 10 的整数表示。默认的优先级是5。

```markup
最低优先级 1：Thread.MIN_PRIORITY
最高优先级 10：Thread.MAX_PRIORITY
普通优先级 5：Thread.NORM_PRIORITY
```

在Java中，可以使用Thread类的`setPriority()`方法为线程设置了新的优先级。`getPriority()`方法返回线程的当前优先级。当创建一个线程时，其默认优先级是创建该线程的线程的优先级。