## 1.HashMap

HashMap的数据结构其内部是一个数组，数组中的每个元素都是一个单向链表，链表中的每个元素都是嵌套类Entry的实例，Entry实例

包含4个属性：key、value、hash值和用于指向单向链表下一个元素的next。

![](D:\workspace\Java-Interview-Offer\images\集合004.png)



HashMap常用的参数如下:

- capacity：当前数组的容量，默认为16，可以扩容，扩容后数组的大小为当前的两倍，因此该值始终为2n。
- loadFactor：负载因子，默认为0.75。
- threshold：扩容的阈值，其值等于capacity×loadFactor。
- transient int size：记录了Map中KV对的个数

HashMap在查找数据时，根据HashMap的Hash值可以快速定位到数组的具体下标，但是在找到数组下标后需要对链表进行顺序遍历直

到找到需要的数据，时间复杂度为O(n)。

为了减少链表遍历的开销，Java 8对HashMap进行了优化，将数据结构修改为数组+链表或红黑树。在链表中的元素超过8个以后，

HashMap会将链表结构转换为红黑树结构以提高查询效率，因此其时间复杂度为O(logN)。

![](D:\workspace\Java-Interview-Offer\images\集合005.png)

## 2.LinkedHashMap：基于HashTable数据结构，使用链表保存插入顺序

LinkedHashMap为HashMap的子类，其内部使用链表保存元素的插入顺序，在通过Iterator遍历LinkedHashMap时，会按照元素的插入

顺序访问元素。也可以在构造时带参数，按照访问次序排序。

## 3.为什么HashMap的默认容量设置成16

HashMap作为一种数据结构，元素在put的过程中需要进行hash运算，目的是计算出该元素存放在hashMap中的具体位置。

hash运算的过程其实就是对目标元素的Key进行hashcode，再对Map的容量进行取模，而JDK 的工程师为了提升取模的效率，使用位运算代替了取模运算，这就要求Map的容量一定得是2的幂。

而作为默认容量，太大和太小都不合适，所以16就作为一个比较合适的经验值被采用了。

为了保证任何情况下Map的容量都是2的幂，HashMap在两个地方都做了限制。

首先是，如果用户制定了初始容量，那么HashMap会计算出比该数大的第一个2的幂作为初始容量。

另外，在扩容的时候，也是进行成倍的扩容，即4变成8，8变成16。

## 4.HashMap容量初始化

在JDK 1.7和JDK 1.8中，HashMap初始化这个容量的时机不同。JDK 1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定。而在JDK 1.7中，要等到第一次put操作时才进行这一操作。

## 5.哈希碰撞

HashMap其实是底层基于哈希函数实现的，但是哈希函数都有如下一个基本特性：根据同一哈希函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。

两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。

为了解决哈希碰撞，有很多办法，其中比较常见的就是链地址法，这也是HashMap采用的方法。

HashMap将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。

我们在向HashMap中put元素的时候，就需要先定位到是数组中的哪条链表，然后把这个元素挂在这个链表的后面。

当我们从HashMap中get元素的时候，也是需要定位到是数组中的哪条链表，然后再逐一遍历链表中的元素，直到查找到需要的元素为止。

可见，HashMap通过链表的数组这种结构，解决了hash冲突的问题。

但是，如果一个HashMap中冲突太高，那么数组的链表就会退化为链表。这时候查询速度会大大降低。

## 6.为什么HashMap的默认负载因子设置成0.75

为了避免哈希碰撞，HashMap需要在合适的时候进行扩容。

临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）

一般来说，默认的负载因子(0.75)在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在HashMap类的大多数操作中，包括get和put)。

loadFactory太大，比如等于1，那么就会有很高的哈希冲突的概率，会大大降低查询速度。

loadFactory太小，比如等于0.5，那么频繁扩容，就会大大浪费空间。

根据HashMap的扩容机制，他会保证capacity的值永远都是2的幂。

那么，为了保证`负载因子（loadFactor） * 容量（capacity）`的结果是一个整数，这个值是0.75(3/4)比较合理，因为这个数和任何2的幂乘积结果都是整数。

## 7.HashMap初始化容量设置多少合适

**当我们明确知道HashMap中元素的个数的时候，把默认容量设置成expectedSize / 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。**

```
Map<String, String> map = Maps.newHashMapWithExpectedSize(7);
```

