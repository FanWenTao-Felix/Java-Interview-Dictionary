# 分布式事务

## 1.事务

事务是Web应用中不可缺少的组件模型，它保证了用户操作的原子性（Atomicity)、一 致性（Consistency ）、隔离性（Isolation ）和持久性（Durability)。事务分本地事务和分布式事务两种。

### 本地事务

本地事务基于数据库资源实现，事务串行地在JDBC连接上执行，本地事务将事务处理局限在当前事务资源内。其特点是使用灵活但无法支持多数源事务操作。在数据库连接中使用本地事务的代码示例如下：

```
try{
	//将自动提交设置为false
	//若设置为true，则数据库将会把每一次数据更新认定为一个事务并自动提交
	conn.setAutoCommit(false); 
	//提交事务
	conn.commit();
} catch(SQLException sqle) { 
	//异常回滚：发生异常，回滚在本事务中的操作	
	conn.rollback(); 
```

在上述代码中，首先通conn.seAutoCommit(false）设置数据库连接为非自动提交，然后分别提交了两条更新语句，最后通过conn.commit（）提交事务。如果数据库操作成功，则事务完成；如果操作失败，则通过conn.rollback（）回滚事务。

### 分布式事务

分布式事务（Distributed Transaction ）提供了跨数据库的分布式事务操作的数据一致性，跨数据库的一致性包含同一类型数据库的多个数据库实例服务的一致性（例如多个MySQL的事务一致性）和多个不同类型数据库的数据一致性（例如MySQL和Oracle之间的事务一致性）两种情况。

Java事务编程接口（Java Transaction API, JTA ）和Java事务服务(Java Transaction Service, JTS)为 J2EE平台提供了分布式事务服务。分布式事务包括一个事务管理器( Transaction Manager)和一个或多个支恃XA协议（XA协议是由X/Open组织提出的分布式事务的规范，XA规范主要定义了事务管理器和资源管理器之间的接口）的资源管理器（Resource Manager）。 其中，事务管理器负责所有事务参与单元的协调与控制，资源管理器负责不同的数据库具体的事务执行操作。具体使用代码如下：

```
public void transferAccount() { 	
	UserTransacton userTx = null; 
	//step1 ：定义a.b数据库连接
	Connection connA = null; 
	Statement stmtA = null; 
	Connection connB = null; 
	Statement stmtB = null; 
	try{}
		//step2 ：获得Transaction管理对象
		userTx = （UserTransaction)getCoηtext () .lookup (”java:comp/UserTransaction"); 
		connA = getDataSourceA() .getConnection() ;//step 3.1：从数据库中取得数据库连接
		connB = getDataSourceB() .getConnection();//step 3.2：从数据库中取得数据库连接
		userTx.begin (); //step 4：启动事务
		stmtA = connA.createStatement();//step 5.1：操作库数据：将A账户中的金额减少500
		stmtA.execute (”update t_account set amount = amount -500 where account_id =’A’”); 
		//step 5.2：操作B库数据：将B账户中的金额增加500
		stmtB = connB.createStatement(); 	
		stmtB.execute (”update t_account set amount = amount + 500 where account_id =’B’”) ; 
		userTx.commit();//step6： 提交事务
		//提交事务：转账的两步操作同时执行（数据库A和数据库B中的数据被同时更新）
	} catch(SQLException sqle) { 
		//step 7：回滚事务，发生异常，回滚在本事务中的操作
		userTx.rollback(); //数据库A和数据库B中的数据更新被同时撤销
```

在上述代码中，首先定义了一个分布式事务管理器UserTransacton，然后定义了2个连接池connA和connB，接着通过userTx.begin（）启动事务并向两个数据库连接提交2个更新请求，最后通过userTx.commit（）统一提交事务。如果执行成功，则事务完成；如果失败，则通过userTx.rollback（）回滚事务。

## 2.分布式事务

### 传统事务

传统事务遵循ACID原则，即原子性、一致性、隔离性和持久性。

- 原子性：事务是包含一系列操作的原子操作，事务的原子性确保这些操作全部完成或者全部失败。
- 一致性：事务执行的结果必须使数据库从不一致性状态转为一致性状态。保证数据库的一致性指在事务完成时，必须使所有数据都有一致的状态。
- 隔离性：因为可能在相同的数据集上同时有许多事务要处理，所以每个事务都应该与其他事务隔离，避免数据被破坏。
- 持久性：一旦事务完成，其结果就应该能够承受任何系统的错误，比如在事务提交过程中服务器的电源被切断等。在通常情况下，事务的结果被写入持续性存储中。

### 柔性事务

在分布式数据库领域，基于CAP理论及BASE理论，阿里巴巴提出了柔性事务的概念。BASE理论是CAP理论的延伸，包括基本可用（BasicallyAvailable）、柔性状态（Soft State）、最终一致性（EventualConsistency）三个原则，并基于这三个原则设计出了柔性事务。

我们通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型。

两阶段型事务指分布式事务的两阶段提交，对应技术上的XA和JTA/JTS，是分布式环境下事务处理的典型模式。

TCC型事务（Try、Confirm、Cancel）为补偿型事务，是一种基于补偿的事务处理模型。如图 7-10所示，服务器A发起事务，服务器B参与事务，如果服务器A的事务和服务器B的事务都顺利执行完成并提交，则整个事务执行完成。但是，如果事务B执行失败，事务B本身就回滚，这时事务A已被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作进行反操作，恢复到未执行前事务A的状态。需要注意的是，发起提交的一般是主业务服务，而状态补偿的一般是业务活动管理者，因为活动日志被存储在业务活动管理中，补偿需要依靠日志进行恢复。TCC事务模型牺牲了一定的隔离性和一致性，但是提高了事务的可用性。

异步确保型事务指将一系列同步的事务操作修改为基于消息队列异步执行的操作，来避免分布式事务中同步阻塞带来的数据操作性能下降。

（1）业务A的模块在数据库A上执行数据更新操作。

（2）业务A调用写消息数据模块。

（3）写消息日志模块将数据库的写操作状态写入数据库A中。

（4）写消息日志模块将写操作日志发送给消息服务器。

（5）读消息日志模块接收操作日志。

（6）读消息数据调用写业务B的模块。

（7）写业务B更新数据到数据库B。

（8）写业务数据B的模块发送异步消息更新数据库A中的写消息日志状态，说明自己已经完成了异步数据更新操作。

最大努力通知型事务也是通过消息中间件实现的，与前面异步确保型操作不同的是：在消息由MQ服务器发送到消费者之后，允许在达到最大重试次数之后正常结束事务，因此无法保障数据的最终一致性。比如，写业务数据A在更新数据库后调用写消息日志将数据操作以异步消息的形式发送给读消息日志模块；读消息日志模块在接收到数据操作后调用写业务B写数据库。和异步确保型不同的是，数据库B在写完之后将不再通知写状态到数据库A，如果因为网络或其他原因，第4步没有接收到消息，则消息服务器将不断重试发送消息到读消息日志，如果经过 N次重试后读消息日志还是没有接收到日志，则消息不再发送，这时会出现数据库A和数据库B数据不一致的情况。最大努力型通知事务通过消息服务使分布式事务异步解耦，并且模块简单、高效，但是牺牲了数据的一致性，在金融等对事务要求高的业务中不建议使用，但在日志记录类等对数据一致性要求不是很高的应用上执行效率很高。

## 3.CAP

CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partitiontolerance）三者不可兼得。

- 一致性：在分布式系统的所有数据备份中，在同一时刻是否有同样的值（等同于所有节点都访问同一份最新的数据副本）。
- 可用性：在集群中一部分节点发生故障后，集群整体能否响应客户端的读写请求（对数据更新具备高可用性）。
- 分区容错性：系统如果不能在时限内达成数据的一致性，就意味着发生了分区，必须就当前操作在C和A 之间做出选择。以实际效果而言，分区相当于对通信的时限要求。

## 4.两阶段提交协议

分布式事务指涉及操作多个数据库的事务，在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。

二阶段提交（Two-Phase Commit）指在计算机网络及数据库领域内，为了使分布式数据库的所有节点在进行事务提交时都保持一致性而设计的一种算法。在分布式系统中，每个节点虽然都可以知道自己的操作是否成功，却无法知道其他节点的操作是否成功。

在一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果，并最终指示这些节点是否真正提交操作结果（比如将更新后的数据写入磁盘等）。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈决定各参与者是提交操作还是中止操作。

![](D:\workspace\java\images\分布式事务001.png)

### Prepare（准备阶段）

事务协调者（事务管理器）给每个参与者（源管理器）都发送Prepare消息，每个参与者要么直接返回失败（如权限验证失败），要么在本地执行事务，写本地的redo和undo日志但不提交，是一种“万事俱备，只欠东风”的状态。

### Commit（提交阶段）

如果协调者接收到了参与者的失败消息或者超时，则直接给每个参与者都发送回滚消息，否则发送提交消息，参与者根据协调者的指令执行提交或者回滚操作，释放在所有事务处理过程中使用的锁资源。

### 两阶段提交的缺点

- 同步阻塞问题：在执行过程中，所有参与者的任务都是阻塞执行的。
- 单点故障：所有请求都需要经过协调者，在协调者发生故障时，所有参与者都会被阻塞。
- 数据不一致：在二阶段提交的第2 阶段，在协调者向参与者发送Commit（提交）请求后发生了局部网络异常，或者在发送Commit请求过程中协调者发生了故障，导致只有一部分参与者接收到Commit请求，于是整个分布式系统出现了数据不一致的现象，这也被称为脑裂。
- 协调者宕机后事务状态丢失：协调者在发出Commit消息之后宕机，唯一接收到这条消息的参与者也宕机，即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没有人知道事务是否已被提交。

## 5.三阶段提交协议

三阶段提交（Three-Phase Commit），也叫作三阶段提交协议（Three-Phase Commit Protocol），是二阶段提交（2PC）的改进版本。具体改进如下。

- 引入超时机制：在协调者和参与者中引入超时机制，如果协调者长时间接收不到参与者的反馈，则认为参与者执行失败。
- 在第1 阶段和第2 阶段都加入一个预准备阶段，以保证在最后的任务提交之前各参与节点的状态是一致的。也就是说，除了引入超时机制，三阶段提交协议（3PC）把两阶段提交协议（2PC）的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。

### CanCommit阶段

协调者向参与者发送Commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

### PreCommit阶段

协调者根据参与者的反应来决定是否继续进行，有以下两种可能。

- 假如协调者从所有参与者那里获得的反馈都是Yes响应，就预执行事务。
- 假如有任意参与者向协调者发送了No响应，或者在等待超时之后协调者都没有接收到参与者的响应，则执行事务的中断。

### DoCommit阶段

该阶段进行真正的事务提交，主要包括：协调者发送提交请求，参与者提交事务，参与者响应反馈（在事务提交完之后向协调者发送Ack响应），协调者确定完成事务。

![](D:\workspace\java\images\分布式事务002.png)

## 6.柔性事务

在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了柔性事务的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下BASE理论，它是在CAP理论的基础之上的延伸。包括基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。

通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种

### 两阶段型

1、就是分布式事务两阶段提交，对应技术上的XA、JTA/JTS。这是分布式环境下事务处理的典型模式。

### 补偿型

2、TCC型事务（Try/Confirm/Cancel）可以归为补偿型。

WS-BusinessActivity提供了一种基于补偿的long-running的事务处理模型。服务器A发起事务，服务器B参与事务，服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的SAGA事务模型，是牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性。

![](D:\workspace\Java\images\分布式事务003.png)

### 异步确保型

3、通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。

![](D:\workspace\Java\images\分布式事务004.png)

### 最大努力通知型（多次尝试）

4、这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由MQ Server投递到消费者之后,允许在达到最大重试次数之后正常结束事务。