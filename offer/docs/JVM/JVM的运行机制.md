## 1.JVM的运行机制

JVM（Java Virtual Machine）是用于运行Java字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。JVM运行在操作系统之上，不与硬件设备直接交互。

Java源文件在通过编译器之后被编译成相应的.Class文件（字节码文件），.Class文件又被JVM中的解释器编译成机器码在不同的操作系统（Windows、Linux、Mac）上运行。每种操作系统的解释器都是不同的，但基于解释器实现的虚拟机是相同的，这也是Java能够跨平台的原因。在一个Java进程开始运行后，虚拟机就开始实例化了，有多个进程启动就会实例化多个虚拟机实例。进程退出或者关闭，则虚拟机实例消亡，在多个虚拟机实例之间不能共享数据。

Java程序的具体运行过程如下。

（1）Java源文件被编译器编译成字节码文件。

（2）JVM将字节码文件编译成相应操作系统的机器码。

（3）机器码调用相应操作系统的本地方法库执行相应的方法。

Java虚拟机包括一个类加载器子系统（Class Loader SubSystem）、运行时数据区（Runtime Data Area）、执行引擎和本地接口库（NativeInterface Library）。本地接口库通过调用本地方法库（Native MethodLibrary）与操作系统交互。

![](D:\workspace\java\images\JVM001.png)

其中：

- 类加载器子系统用于将编译好的.Class文件加载到JVM中；
- 运行时数据区用于存储在JVM运行过程中产生的数据，包括程序计数器、方法区、本地方法区、虚拟机栈和虚拟机堆；
- 执行引擎包括即时编译器和垃圾回收器，即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；
- 本地接口库用于调用操作系统的本地方法库完成具体的指令操作。

## 2.多线程

在多核操作系统上，JVM允许在一个进程内同时并发执行多个线程。JVM中的线程与操作系统中的线程是相互对应的，在JVM线程的本地存储、缓冲区分配、同步对象、栈、程序计数器等准备工作都完成时，JVM会调用操作系统的接口创建一个与之对应的原生线程；在JVM线程运行结束时，原生线程随之被回收。操作系统负责调度所有线程，并为其分配CPU时间片，在原生线程初始化完毕时，就会调用Java线程的run()执行该线程；在线程结束时，会释放原生线程和Java线程所对应的资源。

在JVM后台运行的线程主要有以下几个。

- 虚拟机线程（JVMThread）：这个线程等待JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased locking）解除。
- 周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。
- GC线程：GC线程支持JVM中不同的垃圾回收活动。
- 编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是JVM跨平台的具体实现。
- 信号分发线程：接收发送到JVM的信号并调用JVM方法。

## 3.Java代码到底是如何运行起来的？

1）编译：“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件。

2）采用“java”命令，实际上此时就会启动一个JVM进程。这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

3）JVM用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

4）**JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了**。

## **4.什么时候会初始化一个类？**

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类。

