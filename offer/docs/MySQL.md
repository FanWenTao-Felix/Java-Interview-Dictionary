# MySQL

## 1.存储引擎

数据库的存储引擎是数据库的底层软件组织，数据库管理系统（DBMS）使用存储引擎创建、查询、更新和删除数据。不同的存储引擎提供了不同的存储机制、索引技巧、锁定水平等功能，都有其特定的功能。现在，许多数据库管理系统都支持多种存储引擎，常用的存储引擎主要有MyISAM、InnoDB、Memory、Archive和Federated。

## 2.MyIASM

MyIASM是MySQL默认的存储引擎，不支持数据库事务、行级锁和外键，因此在INSERT（插入）或UPDATE（更新）数据即写操作时需要锁定整个表，效率较低。

MyIASM的特点是执行读取操作的速度快，且占用的内存和存储资源较少。它在设计之初就假设数据被组织成固定长度的记录，并且是按顺序存储的。在查找数据时，MyIASM直接查找文件的OFFSET，定位比InnoDB要快（InnoDB寻址时要先映射到块，再映射到行）。

总体来说，MyIASM的缺点是更新数据慢且不支持事务处理，优点是查询速度快。

## 3.InnoDB（B+树）

InnoDB为MySQL提供了事务（Transaction）支持、回滚（Rollback）、崩溃修复能力（Crash Recovery Capabilities）、多版本并发控制（Multi-versioned Concurrency Control）、事务安全（Transaction-safe）的操作。InnoDB的底层存储结构为B+树，B+树的每个节点都对应InnoDB的一个Page，Page大小是固定的，一般被设为16KB。其中，非叶子节点只有键值，叶子节点包含完整的数据

![](D:\workspace\Java-Interview-Offer\images\数据库001.png)

InnoDB适用于有以下需求的场景。

- 经常有数据更新的表，适合处理多重并发更新请求。
- 支持事务。
- 支持灾难恢复（通过bin-log日志等）。
- 支持外键约束，只有InnoDB支持外键。
- 支持自动增加列属性auto_increment。

## 4.TokuDB（Fractal Tree-节点带数据）

TokuDB的底层存储结构为Fractal Tree。Fractal Tree的结构与B+树有些类似，只是在Fractal Tree中除了每一个指针（key），都需要指向一个child（孩子）节点，child节点带一个Message Buffer，这个MessageBuffer是一个先进先出队列，用来缓存更新操作，这样，每一次插入操作都只需落在某节点的Message Buffer上，就可以马上返回，并不需要搜索到叶子节点。这些缓存的更新操作会在后台异步合并并更新到对应的节点上。

![](D:\workspace\Java-Interview-Offer\images\mysql001.png)

TokuDB在线添加索引，不影响读写操作，有非常高的写入性能，主要适用于要求写入速度快、访问频率不高的数据或历史数据归档。

## 5.Memory

Memory表使用内存空间创建。每个Memory表实际上都对应一个磁盘文件用于持久化。Memory表因为数据是存放在内存中的，因此访问速度非常快，通常使用Hash索引来实现数据索引。Memory表的缺点是一旦服务关闭，表中的数据就会丢失。

Memory还支持散列索引和B树索引。B树索引可以使用部分查询和通配查询，也可以使用不等于和大于等于等操作符方便批量数据访问，散列索引相对于B树索引来说，基于Key的查询效率特别高，但是基于范围的查询效率不是很高。

## 6.索引是什么

mysql的索引说白了就是用一个数据结构组织某一列的数据，然后如果你要根据那一列的数据查询的时候，就可以不用全表扫描，只要根据那个特定的数据结构去找到那一列的值，然后找到对应的行的物理地址即可。

## 6.创建索引的原则

创建索引是我们提高数据库查询数据效率最常用的办法，也是很重要的办法。下面是常见的创建索引的原则。

- 选择唯一性索引：唯一性索引一般基于Hash算法实现，可以快速、唯一地定位某条数据。
- 为经常需要排序、分组和联合操作的字段建立索引。
- 为常作为查询条件的字段建立索引。
- 限制索引的数量：索引越多，数据更新表越慢，因为在数据更新时会不断计算和添加索引。
- 尽量使用数据量少的索引：如果索引的值很长，则占用的磁盘变大，查询速度会受到影响。
- 尽量使用前缀来索引：如果索引字段的值过长，则不但影响索引的大小，而且会降低索引的执行效率，这时需要使用字段的部分前缀来作为索引。
- 删除不再使用或者很少使用的索引。
- 最左前缀匹配原则，非常重要的原则。
- 尽量选择区分度高的列作为索引：区分度表示字段值不重复的比例。
- 索引列不能参与计算：带函数的查询不建议参与索引。
- 尽量扩展现有索引：联合索引的查询效率比多个独立索引高。

## 7.数据库三范式

范式是具有最小冗余的表结构，三范式的概念如下所述。

### 第一范式(1st NF －列都是不可再分)

如果每列都是不可再分的最小数据单元（也叫作最小的原子单元），则满足第一范式，第一范式的目标是确保每列的原子性。比如，表中的Address列违背了第一范式列不可再分的原则，要满足第一范式，就需要将Address列拆分为Country列和City列。

![](D:\workspace\Java-Interview-Offer\images\mysql002.png)

### 第二范式(2nd NF－每个表只描述一件事情)

第二范式在第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖，即第二范式要求每个表只描述一件事情。比如，Orders表既包含订单信息，也包含产品信息，需要将其拆分为两个单独的表。

![](D:\workspace\Java-Interview-Offer\images\mysql003.png)

### 第三范式(3rd NF－不存在对非主键列的传递依赖)

第三范式的定义为：满足第一范式和第二范式，并且表中的列不存在对非主键列的传递依赖。比如，除了主键的订单编号，顾客姓名依赖于非主键的顾客编号，因此需要将该列去除。

![](D:\workspace\Java-Interview-Offer\images\mysql004.png)

## 8.数据库事务

数据库事务执行一系列基本操作，这些基本操作组成一个逻辑工作单元一起向数据库提交，要么都执行，要么都不执行。事务是一个不可分割的工作逻辑单元。

事务必须具备以下4个属性，简称ACID属性。

- 原子性（Atomicity）：事务是一个完整操作，参与事务的逻辑单元要么都执行，要么都不执行。
- 一致性（Consistency）：在事务执行完毕时（无论是正常执行完毕还是异常退出），数据都必须处于一致状态。
- 隔离性（Isolation）：对数据进行修改的所有并发事务都是彼此隔离的，它不应以任何方式依赖或影响其他事务。
- 永久性（Durability）：在事务操作完成后，对数据的修改将被持久化到永久性存储中。

## 9.存储过程(特定功能的SQL 语句集)

存储过程指一组用于完成特定功能的SQL语句集，它被存储在数据库中，经过第一次编译后再次调用时不需要被再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象，我们可以基于存储过程快速完成复杂的计算操作。

以下为常见的存储过程的优化思路，也是我们编写事务时需要遵守的原则。

- 尽量利用一些SQL语句代替一些小循环，例如聚合函数、求平均函数等。
- 中间结果被存放于临时表中，并加索引。
- 少使用游标（Cursors）：SQL 是种集合语言，对于集合运算有较高的性能，而游标是过程运算。比如，对一个50 万行的数据进行查询时，如果使用游标，则需要对表执行50万次读取请求，将占用大量的数据库资源，影响数据库的性能。
- 事务越短越好：SQL Server支持并发操作，如果事务过长或者隔离级别过高，则都会造成并发操作的阻塞、死锁，导致查询速度极慢、CPU占用率高等。
- 使用try-catch处理异常。
- 尽量不要将查找语句放在循环中，防止出现过度消耗系统资源的情况。

## 10.触发器(一段能自动执行的程序)

触发器是一段能自动执行的程序，和普通存储过程的区别是“触发器在对某一个表或者数据进行操作时触发”，例如进行UPDATE、INSERT、DELETE操作时，系统会自动调用和执行该表对应的触发器。触发器一般用于数据变化后需要执行一系列操作的情况，比如对系统核心数据的修改需要通过触发器来存储操作日志的信息等。

## 11.数据库的并发策略

数据库的并发控制一般采用三种方法实现，分别是乐观锁、悲观锁及时间戳。

### 乐观锁

乐观锁在读数据时，认为别人不会去写其所读的数据；悲观锁就刚好相反，觉得自己读数据时，别人可能刚好在写自己刚读的数据，态度比较保守；时间戳在操作数据时不加锁，而是通过时间戳来控制并发出现的问题。

### 悲观锁

悲观锁指在其修改某条数据时，不允许别人读取该数据，直到自己的整个事务都提交并释放锁，其他用户才能访问该数据。悲观锁又可分为排它锁（写锁）和共享锁（读锁）。

### 时间戳

时间戳指在数据库表中额外加一个时间戳列TimeStamp。每次读数据时，都把时间戳也读出来，在更新数据时把时间戳加1，在提交之前跟数据库的该字段比较一次，如果比数据库的值大，就允许保存，否则不允许保存。这种处理方法虽然不使用数据库系统提供的锁机制，但是可以大大提高数据库处理的并发量。

## 12.数据库锁

一般其实就是表锁、行锁和页锁。

### 行级锁

行级锁指对某行数据加锁，是一种排他锁，防止其他事务修改此行。在执行以下数据库操作时，数据库会自动应用行级锁。

- INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OFcolumns][WAIT n|NOWAIT]。
- SELECT … FOR UPDATE语句允许用户一次针对多条记录执行更新。
- 使用COMMIT或ROLLBACK语句释放锁。

innodb的行锁有共享锁（S）和排他锁（X），两种，其实说白了呢，共享锁就是，多个事务都可以加共享锁读同一行数据，但是别的事务不能写这行数据；排他锁，就是就一个事务可以写这行数据，别的事务只能读，不能写。

手动加共享锁：select * from table where id=1 lock in share mode，那你就给那一行加了个共享锁，其他事务就不能来修改这行数据了 。

手动加排他锁：select * from table where id=1 for update，那你就给那一行加了个排他锁，意思就是你准备修改，别的事务就别修改了，别的事务的修改会hang住。这个要慎用，一般我们线上系统不用这个，容易搞出问题来。

### 表级锁

表级锁指对当前操作的整张表加锁，它的实现简单，资源消耗较少，被大部分存储引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

一般myisam会加表锁，就是myisam引擎下，执行查询的时候，会默认加个表共享锁，也就是表读锁，这个时候别人只能来查，不能写数据的；然后myisam写的时候，也会加个表独占锁，也就是表写锁，别人不能读也不能写。

innodb的表锁，分成意向共享锁，就是说加共享行锁的时候，必须先加这个共享表锁；还有一个意向排他锁，就是说，给某行加排他锁的时候，必须先给表加排他锁。这个表锁，是innodb引擎自动加的，不用你自己去加。

### 页级锁

页级锁的锁定粒度介于行级锁和表级锁之间。表级锁的加锁速度快，但冲突多，行级冲突少，但加锁速度慢。页级锁在二者之间做了平衡，一次锁定相邻的一组记录。

## 13.数据库分表

数据库分表有垂直切分和水平切分两种，下面简单介绍二者的区别。

### 垂直切分(按照功能模块)

将表按照功能模块、关系密切程度划分并部署到不同的库中。例如，我们会创建定义数据库workDB、商品数据库payDB、用户数据库userDB、日志数据库logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。

### 水平切分(按照规则划分存储)

在一个表中的数据量过大时，我们可以把该表的数据按照某种规则如userID 散列进行划分，然后将其存储到多个结构相同的表和不同的库上。

## 14.如何实现 MySQL 的读写分离？

基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。

## 15.MySQL 主从复制原理的是啥？

主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。

所以 MySQL 实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。

这个所谓半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。

所谓并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

## 16.MySQL 主从同步延时问题

我们通过 MySQL 命令：

show status

查看 Seconds_Behind_Master，可以看到从库复制主库的数据落后了几 ms。

一般来说，如果主从延迟较为严重，有以下解决方案：

- 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
- 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
- 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。
- 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你要是这么搞，读写分离的意义就丧失了。

## 17.MyISAM和InnoDB存储引擎的区别

（1）myisam

myisam，不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能会更好，适用于那种少量的插入，大量查询的场景。

（2）innodb

主要特点就是支持事务，走聚簇索引，强制要求有主键，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，分库分表、读写分离、主备切换，全部都可以基于innodb存储引擎来玩儿。

## 18.索引的使用规则

**（1）全列匹配**

这个就是说，你的一个sql里，正好where条件里就用了这3个字段，那么就一定可以用到这个联合索引的。

**（2）最左前缀匹配**

这个就是说，如果你的sql里，正好就用到了联合索引最左边的一个或者几个列表，那么也可以用上这个索引，在索引里查找的时候就用最左边的几个列就行了：

**（3）最左前缀匹配了，但是中间某个值没匹配**

这个是说，如果你的sql里，就用了联合索引的第一个列和第三个列，那么会按照第一个列值在索引里找，找完以后对结果集扫描一遍根据第三个列来过滤，第三个列是不走索引去搜索的，就是有一个额外的过滤的工作，但是还能用到索引，所以也还好。

**（4）没有最左前缀匹配**

那就不行了，一定不会用索引

**（5）前缀匹配**

这个就是说，如果你不是等值的，比如=，>=，<=的操作，而是like操作，那么必须要是like ‘XX%’这种才可以用上索引。

**（6）范围列匹配**

如果你是范围查询，比如>=，<=，between操作，你只能是符合最左前缀的规则才可以范围，范围之后的列就不用索引了。

**（7）包含函数**

如果你对某个列用了函数，比如substring之类的东西，那么那一列不用索引。

select * from product where shop_id=1 and 函数(product_id) = 2

## 19.索引的缺点以及使用注意

索引是有缺点的，比如常见的就是会增加磁盘消耗，因为要占用磁盘文件，同时高并发的时候频繁插入和修改索引，会导致性能损耗的。

我们给的建议，尽量创建少的索引，比如说一个表一两个索引，两三个索引，十来个，20个索引，高并发场景下还可以。

## 20.索引

B-Tree/B+Tree：可以将它们看做是一颗优化过的平衡查找树。由于查找树的查找效率极高所以选取它们作为索引结构非常合适，但是为了保证树的高度一定而可以存储大量的数据，因此需要选取高阶的查找树。

### B-Tree/B+Tree区别

B-Tree在非叶子节点中也会存放数据，因此它适合有高频查询的场景，也就是有一个KEY被频繁的查询，走B-Tree的话，可以很快速的查到。但是B-Tree有一个致命的缺点就是没办法高效的进行范围查询，因此慢慢的被B+Tree取代。 B+Tree的数据只存放在叶子结点，并且每个叶子结点都由头尾指针相连，形成了一个循环的双链表，因此B+Tree的范围查询十分高效。

## 21.聚集索引和非聚集索引

聚集索引：innodb下的每张表必须要指定一个索引，而聚集索引就是基于主键去建立的。聚集索引的结构类似于{"id":"1","pointer":"0007"}其中pointer指向对应的叶子结点。

非聚集索引：又叫做辅助索引，相当于是对聚集索引的辅助，我们建立的索引都是这类索引，结构类似于{"name":"zhangsan","id":"1"}其中保存着聚集索引中的id。 以上结构仅仅用于帮助理解和记忆，具体的实现结构是偏移量之类的。

## 22.事务隔离级别

（1）读未提交，Read Uncommitted：某个事务还没提交的时候，修改的数据，就让别的事务给读到了，这个也叫做脏读。

（2）读已提交，Read Committed（不可重复读）：就是说事务A在跑的时候， 先查询了一个数据是值1，然后过了段时间，事务B把那个数据给修改了一下还提交了，此时事务A再次查询这个数据就成了值2了，这是读了人家事务提交的数据啊，所以是读已提交。

这个也叫做不可重复读，就是所谓的一个事务内对一个数据两次读，可能会读到不一样的值。

（3）可重复读，Read Repeatable：这个比上面那个再好点儿，就是说事务A在执行过程中，对某个数据的值，无论读多少次都是值1；哪怕这个过程中事务B修改了数据的值还提交了，但是事务A读到的还是自己事务开始时这个数据的值。

（4）串行化：如果要解决幻读，就需要使用串行化级别的隔离级别，所有事务都串行起来，不允许多个事务并行操作。

MySQL的默认隔离级别是Read Repeatable，就是可重复读，就是说每个事务都会开启一个自己要操作的某个数据的快照，事务期间，读到的都是这个数据的快照罢了，对一个数据的多次读都是一样的。

## 23.MySQL是如何实现Read Repeatable的

当我们使用innodb存储引擎，会在每行数据的最后加两个隐藏列，一个保存行的创建时间，一个保存行的删除时间，但是这儿存放的不是时间，而是事务id，事务id是mysql自己维护的自增的，全局唯一。

在一个事务内查询的时候，mysql只会查询创建时间的事务id小于等于当前事务id的行，这样可以确保这个行是在当前事务中创建，或者是之前创建的；

同时一个行的删除时间的事务id要么没有定义（就是没删除），要么是必当前事务id大（在事务开启之后才被删除）；满足这两个条件的数据都会被查出来。

## 24.悲观锁和乐观锁是啥？

mysql里的悲观锁是走select * from table where id=1 for update，就这个，意思是我很悲观，我担心自己拿不到这把锁，我必须先锁死，然后就我一个人可以干这事儿，别人都干不了了，不能加共享锁，也不能加排他锁。

乐观锁，就是说我觉得应该没啥问题，我修改的时候感觉差不多可以获取到锁，不需要提前搞一把锁，我就先查出来某个数据，select id,name,version from table where id=1，接着再执行各种业务逻辑之后再修改，update table set name=’新值’,version=version+1 where id=1 and version=1，就是说每次修改，比较一下这条数据的当前版本号跟我之前查出来的版本号是不是一样的，如果是一样的就修改然后把版本号加1，否则就不会更新任何一行数据，此时就重新查询后再次更新。

一般悲观锁什么时候用呢？比如你查出来了一条数据，要在内存中修改后再更新到数据库中去，但是如果这个过程中数据被别人更新了，你是不能直接干这个操作的，这个时候，你就得走上面那个操作，查询之后就不让别人更新了，你搞完了再说。

但是真有这种场景，推荐你还是用乐观锁把，悲观锁实现简单一点，但是太有风险了，很容易很容易死锁，比如事务A拿了数据1的锁，事务B拿了数据2的锁，然后事务A又要获取数据2的锁就会等待，事务B又要获取数据1的锁，也会等待。